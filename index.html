<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Uni Hyper Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    :root {
      --bg: #161821;
      --bg-gradient: radial-gradient(circle at top, #2a3245 0, #10121a 45%, #05060a 100%);
      --bg-elevated: #1f2230;
      --bg-sidebar: #181b27;
      --border: #2f3445;
      --text: #f7f7ff;
      --muted: #a4aac5;
      --accent: #7b8cff;
      --accent-soft: rgba(123, 140, 255, 0.16);
      --danger: #ff6b81;
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.55);
      --radius-card: 18px;
      --bg-primary: #0a0d1a;
      --bg-secondary: #12151f;
      --bg-card: #1a1d2e;
      --accent-hover: #8b9cff;
      --text-muted: #a4aac5;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .light {
      --bg: #f5f5fb;
      --bg-gradient: radial-gradient(circle at top, #ffffff 0, #eceefd 40%, #dde2ff 100%);
      --bg-elevated: #ffffff;
      --bg-sidebar: #f1f3ff;
      --border: #d3d7f0;
      --text: #1a1c2c;
      --muted: #6f7593;
      --accent: #4a5cff;
      --accent-soft: rgba(74, 92, 255, 0.18);
      --danger: #ff4d6a;
      --shadow-soft: 0 16px 40px rgba(32, 36, 90, 0.18);
      --radius-card: 18px;
      --bg-primary: #0a0d1a;
      --bg-secondary: #12151f;
      --bg-card: #1a1d2e;
      --accent-hover: #8b9cff;
      --text-muted: #a4aac5;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    /* ---------- Topbar ---------- */

    #topbar {
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
      background: rgba(5, 7, 15, 0.9);
      backdrop-filter: blur(18px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      z-index: 20;
    }

    body.light #topbar {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 12px 30px rgba(39, 46, 120, 0.25);
    }

    #topbar-left,
    #topbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #appTitle {
      font-weight: 800;
      font-size: 17px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #appTitle::before {
      content: "ğŸ“š";
      font-size: 16px;
    }

    button,
    select,
    input,
    textarea {
      font-family: inherit;
      font-size: 13px;
    }

    button,
    select {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 6px 11px;
      background: rgba(9, 11, 25, 0.9);
      color: var(--text);
      cursor: pointer;
      outline: none;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.15s ease transform, 0.15s ease box-shadow, 0.15s ease background-color, 0.15s ease border-color;
    }

    body.light button,
    body.light select {
      background: rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 0, 0, 0.05);
    }

    button:hover {
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0px) scale(0.97);
      box-shadow: none;
    }

    #darkModeBtn {
      font-size: 14px;
      padding-inline: 10px;
    }

    /* ---------- Tabbar ---------- */

    #tabbar {
      display: flex;
      align-items: center;
      padding: 5px 10px;
      background: radial-gradient(circle at top left, rgba(123, 140, 255, 0.2), transparent 40%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      gap: 4px;
      flex-wrap: wrap;
    }

    .tab-btn {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 4px 11px 5px;
      font-size: 12px;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.16s ease background-color, 0.16s ease color, 0.16s ease transform;
    }

    .tab-btn::before {
      font-size: 13px;
    }

    .tab-btn[data-tab="notes"]::before { content: "âœï¸"; }
    .tab-btn[data-tab="cards"]::before { content: "ğŸ´"; }
    .tab-btn[data-tab="planner"]::before { content: "ğŸ—“ï¸"; }
    .tab-btn[data-tab="formulas"]::before { content: "âˆ‘"; }
    .tab-btn[data-tab="tools"]::before { content: "ğŸ§®"; }
    .tab-btn[data-tab="learn"]::before { content: "ğŸ“–"; }
    .tab-btn[data-tab="tasks"]::before { content: "ğŸ“Œ"; }
    .tab-btn[data-tab="biochem"]::before { content: "ğŸ§¬"; }
    .tab-btn[data-tab="brain"]::before { content: "ğŸ’­"; }
    .tab-btn[data-tab="stats"]::before { content: "ğŸ“Š"; }

    .tab-btn.active {
      background: var(--accent-soft);
      border-color: rgba(255, 255, 255, 0.16);
      color: var(--text);
      transform: translateY(-1px);
    }

    /* ---------- Main Layout ---------- */

    #main {
      flex: 1;
      display: flex;
      min-height: 0;
      padding: 10px 10px 12px 10px;
      gap: 10px;
    }

    /* ---------- Notizen-Bereich ---------- */

    #notesLayout.section {
      flex: 1;
      display: none;
      min-height: 0;
      background: transparent;
      position: relative;
    }

    #notesLayout.section.active {
      display: flex;
      gap: 8px;
    }

    /* Seiten-KontextmenÃ¼ */
    #pageContextMenu {
      position: fixed;
      background: rgba(18, 21, 38, 0.98);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 5px;
      z-index: 200;
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
      min-width: 150px;
      display: none;
    }
    .ctx-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 9px 13px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.1s;
      color: var(--text);
      user-select: none;
    }
    .ctx-menu-item:hover { background: rgba(255,255,255,0.09); }
    .ctx-menu-item.danger { color: var(--danger); }

    /* â”€â”€ Sidebar Toggle Button (im Flex-Flow zwischen Sidebar und Canvas) â”€â”€ */
    #sidebarToggleBtn {
      flex-shrink: 0;
      width: 18px;
      align-self: stretch;
      border-radius: 8px;
      padding: 0;
      font-size: 9px;
      background: rgba(123, 140, 255, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: 0.18s ease background, 0.18s ease color;
      writing-mode: vertical-rl;
      letter-spacing: 1px;
    }
    #sidebarToggleBtn:hover { background: rgba(123, 140, 255, 0.28); color: var(--text); }

    /* â”€â”€ Sidebar â”€â”€ */
    #sidebarNotes {
      width: 190px;
      min-width: 190px;
      background: linear-gradient(180deg, rgba(15, 18, 32, 0.99), rgba(10, 12, 22, 0.99));
      border-radius: var(--radius-card);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: var(--shadow-soft);
      padding: 10px 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: hidden;
      transition: width 0.22s ease, min-width 0.22s ease, padding 0.22s ease, opacity 0.22s ease;
    }
    #sidebarNotes.collapsed {
      width: 0;
      min-width: 0;
      padding: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* Notebook row */
    #notebookRow {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #notebookRow select {
      flex: 1;
      font-size: 11px;
      min-width: 0;
      border-radius: 8px;
      padding: 5px 7px;
    }
    #notebookRow button {
      padding: 5px 7px;
      font-size: 12px;
      border-radius: 8px;
      flex-shrink: 0;
      min-width: 28px;
      min-height: 28px;
    }

    /* Pages header */
    #sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 6px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }
    #sidebar-section-title {
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.6;
      font-weight: 600;
    }
    #sidebar-header button {
      padding: 4px 9px;
      font-size: 14px;
      min-height: 30px;
      min-width: 30px;
    }

    /* Page list */
    #pageList {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 2px;
    }
    #pageList::-webkit-scrollbar { width: 3px; }
    #pageList::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.14); border-radius: 2px; }

    /* Page thumbnail â€“ GoodNotes style */
    .page-thumb {
      position: relative;
      background: rgba(10, 12, 24, 0.96);
      border-radius: 10px;
      border: 1.5px solid rgba(255,255,255,0.07);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
      cursor: pointer;
      overflow: hidden;
      transition: border-color 0.14s, box-shadow 0.14s, transform 0.1s;
      user-select: none;
    }
    .page-thumb:active { transform: scale(0.97); }
    .page-thumb.active {
      border-color: var(--accent);
      box-shadow: 0 4px 16px rgba(123,140,255,0.3);
    }

    /* Canvas preview inside thumbnail */
    .page-thumb-canvas {
      width: 100%;
      height: 95px;
      display: block;
      background: #fbfbff;
      border-radius: 8px 8px 0 0;
    }
    body.light .page-thumb-canvas { background: #fff; }

    /* Label bar */
    .page-thumb-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 7px;
      background: rgba(18, 21, 38, 0.96);
    }
    .page-thumb.active .page-thumb-label { background: rgba(123,140,255,0.2); }
    .page-thumb-name {
      font-size: 10px;
      color: var(--muted);
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .page-thumb.active .page-thumb-name { color: var(--text); }
    .page-thumb-num {
      font-size: 9px;
      opacity: 0.45;
      margin-left: 4px;
      flex-shrink: 0;
    }

    /* Delete button (visible on hover / long press) */
    .page-thumb-delete {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.88);
      color: white;
      font-size: 13px;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      border: none;
      cursor: pointer;
      z-index: 3;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }
    .page-thumb:hover .page-thumb-delete,
    .page-thumb.show-delete .page-thumb-delete { display: flex; }

    /* Template controls */
    #templateControls {
      border-top: 1px solid rgba(255,255,255,0.06);
      padding-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #templateControls label {
      font-size: 10px;
      opacity: 0.55;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-top: 4px;
    }
    #templateControls select {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 8px;
      width: 100%;
    }

    /* â”€â”€ Canvas wrapper â”€â”€ */
    #canvasWrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 6px;
      min-width: 0;
      gap: 6px;
      overflow: hidden;
    }

    /* Toolbar */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 3px;
      background: radial-gradient(circle at top left, rgba(123,140,255,0.28), rgba(14,16,30,0.97));
      padding: 5px 10px;
      border-radius: 999px;
      box-shadow: var(--shadow-soft);
      flex-wrap: wrap;
      border: 1px solid rgba(255,255,255,0.06);
      max-width: 100%;
      width: fit-content;
    }
    body.light #toolbar {
      background: radial-gradient(circle at top left, rgba(123,140,255,0.14), rgba(255,255,255,0.97));
    }
    body.light #sidebarNotes {
      background: linear-gradient(180deg, rgba(245,247,255,0.99), rgba(238,241,255,0.99));
      border-color: rgba(0,0,0,0.07);
    }
    body.light #sidebar-header { border-top-color: rgba(0,0,0,0.07); }
    body.light .page-thumb { background: rgba(240,242,255,0.98); border-color: rgba(0,0,0,0.09); }
    body.light .page-thumb.active { border-color: var(--accent); }
    body.light .page-thumb-label { background: rgba(225,228,250,0.96); }
    body.light .page-thumb.active .page-thumb-label { background: rgba(74,92,255,0.15); }
    body.light .page-thumb-name { color: #3a3d5c; }
    body.light .page-thumb.active .page-thumb-name { color: #1a1c2c; }
    body.light #templateControls { border-top-color: rgba(0,0,0,0.07); }
    body.light #sidebarToggleBtn { background: rgba(74,92,255,0.1); border-color: rgba(0,0,0,0.08); color: #3a3d5c; }
    body.light .tool-btn { background: rgba(240,242,255,0.9); border-color: rgba(0,0,0,0.07); color: #4a4d6a; }
    body.light .tool-btn.active { background: rgba(74,92,255,0.2); border-color: var(--accent); color: #1a1c2c; }
    body.light .stroke-btn.active { background: rgba(74,92,255,0.18); border-color: var(--accent); }
    body.light .toolbar-sep { background: rgba(0,0,0,0.1); }
    body.light #pageContextMenu { background: rgba(245,247,255,0.98); border-color: rgba(0,0,0,0.1); }
    body.light .ctx-menu-item { color: #1a1c2c; }
    body.light .ctx-menu-item:hover { background: rgba(0,0,0,0.05); }

    /* Toolbar separator */
    .toolbar-sep {
      width: 1px;
      height: 20px;
      background: rgba(255,255,255,0.09);
      margin: 0 3px;
      flex-shrink: 0;
    }

    /* Canvas container â€“ clips overflow during zoom */
    #canvasContainer {
      flex: 1;
      width: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border-radius: 14px;
    }

    #canvas {
      background-color: #fbfbff;
      border-radius: 18px;
      box-shadow: 0 22px 55px rgba(5,6,17,0.85);
      touch-action: none;
      border: 1px solid rgba(0,0,0,0.08);
      transform-origin: center center;
      will-change: transform;
      cursor: crosshair;
    }
    body.light #canvas { background-color: #ffffff; }

    input[type="color"] {
      border: none;
      background: transparent;
      width: 30px;
      height: 30px;
      padding: 0;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.18);
      cursor: pointer;
    }

    .tool-btn {
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 9px;
      font-size: 14px;
      background: rgba(6,8,20,0.82);
      cursor: pointer;
      color: var(--muted);
      min-height: 34px;
      min-width: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn.active {
      border-color: var(--accent);
      background: rgba(123,140,255,0.26);
      color: var(--text);
    }

    .stroke-btn {
      padding: 5px 10px;
      font-size: 13px;
      min-height: 32px;
      border-radius: 8px;
    }
    .stroke-btn.active {
      border-color: var(--accent);
      background: rgba(123,140,255,0.18);
      color: var(--text);
    }

    /* Zoom indicator */
    #zoomLabel {
      font-size: 11px;
      opacity: 0.65;
      min-width: 40px;
      text-align: center;
      pointer-events: none;
    }

    /* Touch mode toggle */
    #touchModeBtn.scroll-mode {
      border-color: var(--warning);
      background: rgba(245,158,11,0.2);
      color: var(--warning);
    }

    label {
      font-size: 11px;
      opacity: 0.8;
    }

    /* ---------- Generische Sektionen (andere Tabs) ---------- */

    .section {
      flex: 1;
      padding: 0;
      display: none;
      overflow: auto;
    }

    .section.active {
      display: block;
    }

    /* Planner iframe fills full height */
    #plannerSection.active {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 0;
    }
    #plannerSection iframe {
      flex: 1;
      min-height: 0;
    }
    /* cardsSection display handled in K2 CSS block below */

    .card {
      background: var(--bg-elevated);
      border-radius: var(--radius-card);
      padding: 11px 12px;
      margin-bottom: 10px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .card h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card h3::before {
      content: "â€¢";
      font-size: 18px;
      color: var(--accent);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .row > * {
      flex: 1;
      min-width: 150px;
    }

    input[type="text"],
    input[type="date"],
    input[type="number"],
    textarea,
    select#notebookSelect,
    select#templateSelect,
    select#studyDeckSelect {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 7px 11px;
      background: rgba(7, 9, 20, 0.9);
      color: var(--text);
      width: 100%;
      box-sizing: border-box;
    }

    body.light input[type="text"],
    body.light input[type="date"],
    body.light input[type="number"],
    body.light textarea,
    body.light select {
      background: rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 0, 0, 0.06);
    }

    textarea {
      min-height: 70px;
      border-radius: 14px;
      line-height: 1.4;
      resize: vertical;
    }

    .pill {
      border-radius: 999px;
      padding: 2px 9px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: inline-block;
      margin-right: 4px;
      margin-bottom: 4px;
      background: rgba(15, 18, 40, 0.9);
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      font-size: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
    }

    /* ---------- Lernen-Layout ---------- */
    #learnLayout {
      display: flex;
      gap: 10px;
      height: 100%;
    }

    #learnSidebar {
      width: 210px;
      background: var(--bg-sidebar);
      border-radius: var(--radius-card);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: var(--shadow-soft);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #learnSubjects,
    #learnTopics {
      margin-top: 4px;
      padding: 0;
      list-style: none;
      max-height: 40%;
      overflow-y: auto;
    }

    .learn-item {
      padding: 5px 9px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      margin-bottom: 4px;
      background: rgba(0,0,0,0.08);
      color: var(--muted);
      transition: 0.15s;
    }

    .learn-item.active {
      background: var(--accent-soft);
      color: var(--text);
    }

    #learnContent {
      flex: 1;
      overflow-y: auto;
    }

    .learn-heading {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .learn-subheading {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 8px;
    }

    .learn-section-title {
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      margin-bottom: 4px;
    }

    .learn-list {
      margin-top: 0;
      padding-left: 18px;
      font-size: 13px;
    }

    .learn-chiprow {
      margin-top: 4px;
      margin-bottom: 6px;
    }

    .learn-chip {
      display: inline-block;
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
      margin-right: 4px;
      margin-bottom: 4px;
    }

    @media (max-width: 860px) {
      #sidebarNotes { width: 160px; min-width: 160px; }
      button, select { font-size: 11px; padding: 4px 8px; }
      #toolbar { padding: 4px 8px; }
      .tool-btn { min-height: 38px; min-width: 38px; font-size: 15px; }
      #learnLayout { flex-direction: column; }
      #learnSidebar { width: 100%; flex-direction: row; overflow-x: auto; }
    }
    /* iPad: bigger touch targets */
    @media (hover: none) and (pointer: coarse) {
      .tool-btn { min-height: 44px; min-width: 44px; font-size: 16px; padding: 8px; }
      .stroke-btn { min-height: 40px; padding: 7px 13px; }
      #sidebar-header button { min-height: 38px; min-width: 38px; }
      .page-thumb-canvas { height: 110px; }
      #notebookRow button { min-height: 34px; min-width: 34px; }
    }


/* ========== AMINOSÃ„URE-STRUKTUR ========== */
/* ====== AminosÃ¤ure-Struktur (funktioniert garantiert) ====== */
/* ======= AminosÃ¤ure-Struktur (funktioniert garantiert) ====== */
.amino-structure {
  display: grid;
  grid-template-columns: auto auto auto;
  grid-template-rows: auto auto auto;
  justify-items: center;
  align-items: center;
  gap: 4px;
  font-size: 1.2rem;
  font-family: system-ui, sans-serif;
}

/* ========= AminosÃ¤ure-Struktur â€“ saubere Version ========= */

#flashcardPreview {
  margin: 20px 0;
  display: flex;
  justify-content: center;   /* Struktur in der Mitte des Karteikarten-Bereichs */
}

/* Die Karte mit der Struktur */
.amino-structure {
  display: grid;
  grid-template-columns: auto auto auto;
  grid-template-rows: auto auto auto;
  gap: 6px;
  justify-items: center;
  align-items: center;
  padding: 16px 20px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  font-size: 1.2rem;
  font-family: system-ui, sans-serif;
  width: max-content;        /* ganz wichtig: wird nur so breit wie der Inhalt */
}

/* Positionen der Atome */
.amino-structure .top    { grid-row: 1; grid-column: 2; }
.amino-structure .left   { grid-row: 2; grid-column: 1; }

.amino-structure .center {
  grid-row: 2;
  grid-column: 2;
  font-weight: 700;

  position: relative;
  z-index: 2;
  padding: 0 0.25em 0.05em;           /* bisschen Abstand um das C herum */
  background-color: #181a24;          /* gleiche Farbe wie dein Kartenhintergrund */
  border-radius: 4px;                 /* leicht abgerundet, damit es weich aussieht */
}

.amino-structure .right  { grid-row: 2; grid-column: 3; }
.amino-structure .bottom { grid-row: 3; grid-column: 2; }

/* Bindungen â€“ beide im selben Grid-Feld in der Mitte -> Kreuz */
.amino-structure .bond-v {
  grid-row: 2;
  grid-column: 2;
  width: 3px;
  height: 40px;              /* LÃ¤nge vertikale Linie */
  background-color: #a88242;
}

.amino-structure .bond-h {
  grid-row: 2;
  grid-column: 2;
  height: 3px;
  width: 70px;               /* LÃ¤nge horizontale Linie */
  background-color: #a88242;
}

/* SchÃ¶ne Anzeige fÃ¼r ASCII-AminosÃ¤ure-Strukturen */
.amino-pretty {
  white-space: pre;          /* ZeilenumbrÃ¼che und Leerzeichen beibehalten */
  font-family: "Fira Code", Consolas, monospace;
  font-size: 1.1rem;
  line-height: 1.4;
  text-align: center;
}

/* ===== Tools Cards: Project idea styling ===== */
.tool-note {
  font-size: 13px;
  line-height: 1.6;
  opacity: 0.96;
}

.tool-note h4 {
  margin: 12px 0 6px;
  font-size: 13px;
  font-weight: 700;
  opacity: 0.95;
}

.tool-note p {
  margin: 8px 0;
}

.tool-note ul {
  margin: 6px 0 10px;
  padding-left: 18px;
}

.tool-note li {
  margin: 4px 0;
}

.tool-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 8px 0 10px;
}

.tool-tag {
  font-size: 12px;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  opacity: 0.95;
}

.formula-box {
  margin-top: 8px;
  padding: 10px 12px;
  border-radius: 14px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.07);
}

.formula-mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 12px;
}

.formula-sub {
  margin-top: 6px;
  font-size: 12px;
  opacity: 0.85;
}

/* ===== Collapsible Tool Cards ===== */
.tool-card {
  background: var(--bg-elevated);
  border-radius: var(--radius-card);
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: var(--shadow-soft);
  margin-bottom: 10px;
  overflow: hidden;
}

.tool-header {
  cursor: pointer;
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 15px;
  font-weight: 600;
  transition: background 0.2s ease;
  user-select: none;
  list-style: none;
}

.tool-header::-webkit-details-marker {
  display: none;
}

.tool-header:hover {
  background: rgba(255, 255, 255, 0.02);
}

.tool-icon {
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: var(--accent-soft);
}

.tool-title {
  flex: 1;
}

.tool-content {
  padding: 16px;
  border-top: 1px solid rgba(255, 255, 255, 0.04);
}

.tool-card[open] .tool-header {
  background: rgba(255, 255, 255, 0.02);
}

/* ===== Bio-Simulation Tabs ===== */
.bio-tabs {
  display: flex;
  gap: 6px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
  padding-bottom: 8px;
}

.bio-tab {
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 8px;
  border: 1px solid transparent;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.2s ease;
}

.bio-tab:hover {
  background: rgba(255, 255, 255, 0.03);
}

.bio-tab.active {
  background: var(--accent-soft);
  border-color: rgba(255, 255, 255, 0.1);
  color: var(--text);
}

.bio-tab-content {
  display: none;
}

.bio-tab-content.active {
  display: block;
}

/* ===== Parameter Groups ===== */
.param-group {
  background: rgba(255, 255, 255, 0.02);
  border-radius: 10px;
  padding: 10px 12px;
  margin-bottom: 10px;
}

.param-group-title {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 8px;
  opacity: 0.9;
}

.bio-param {
  display: grid !important;
  grid-template-columns: 1fr 2fr auto;
  align-items: center;
  gap: 8px;
  font-size: 11px !important;
  opacity: 0.85 !important;
  margin-bottom: 8px !important;
}

.bio-param span:first-child {
  font-weight: 500;
}

.param-val {
  min-width: 50px;
  text-align: right;
  font-weight: 600;
  opacity: 1 !important;
}

.formula-sub {
  margin-top: 6px;
  font-size: 12px;
  opacity: 0.85;
}

.modelCard {
      margin: 10px 0 14px 0;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .modelCard summary {
      cursor: pointer;
      user-select: none;
      margin-bottom: 6px;
    }
    .modelCard .small {
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.5;
    }

</style>



<body>
  <!-- TOPBAR -->
  <div id="topbar">
    <div id="topbar-left">
      <div id="appTitle">Uni Hyper Notes</div>
    </div>
    <div id="topbar-right">
      <button id="darkModeBtn">ğŸŒ™ / â˜€ï¸</button>
      <button id="exportPageBtn" title="Seite als PNG exportieren">ğŸ–¼ï¸ PNG</button>
      <button id="exportJsonBtn" title="Backup herunterladen">ğŸ’¾ Backup</button>
      <button id="importJsonBtn" title="Backup laden">ğŸ“‚ Laden</button>
      <input type="file" id="importJsonInput" accept="application/json" style="display:none;">
    </div>
  </div>

  <!-- TABBAR -->
  <div id="tabbar">
    <button class="tab-btn active" data-tab="notes">Notizen</button>
    <button class="tab-btn" data-tab="cards">Karteikarten</button>
    <button class="tab-btn" data-tab="planner">Planer</button>
    <button class="tab-btn" data-tab="formulas">Formeln</button>
    <button class="tab-btn" data-tab="tools">Tools</button>
    <button class="tab-btn" data-tab="learn">Lernen</button>
    <button class="tab-btn" data-tab="tasks">Aufgaben</button>
    <button class="tab-btn" data-tab="biochem">Bio/Chemie</button>
    <button class="tab-btn" data-tab="brain">Brain-Dump</button>
    <button class="tab-btn" data-tab="stats">Stats</button>
  </div>

  <div id="main">
    <!-- NOTIZEN-TAB -->
    <div id="notesLayout" class="section active">

      <!-- â”€â”€ Sidebar â”€â”€ -->
      <div id="sidebarNotes">

        <!-- Notizbuch-Auswahl -->
        <div id="notebookRow">
          <select id="notebookSelect" title="Notizbuch wÃ¤hlen"></select>
          <button id="addNotebookBtn" title="Neues Notizbuch">ï¼‹</button>
          <button id="deleteNotebookBtn" title="Notizbuch lÃ¶schen" style="color:var(--danger)">ğŸ—‘</button>
        </div>

        <!-- Seiten-Header -->
        <div id="sidebar-header">
          <span id="sidebar-section-title">Seiten</span>
          <button id="addPageBtn" title="Neue Seite">ï¼‹</button>
        </div>

        <!-- Seiten-Thumbnails -->
        <div id="pageList"></div>

        <!-- Template-Einstellungen -->
        <div id="templateControls">
          <label for="templateSelect">Vorlage</label>
          <select id="templateSelect">
            <option value="blank">Blanko</option>
            <option value="lined">Liniert</option>
            <option value="dotted">Gepunktet</option>
            <option value="grid">Kariert</option>
          </select>
          <label for="templateSizeSelect">RastergrÃ¶ÃŸe</label>
          <select id="templateSizeSelect">
            <option value="small">Fein</option>
            <option value="medium" selected>Mittel</option>
            <option value="large">GroÃŸ</option>
          </select>
        </div>
      </div>

      <!-- Sidebar-Toggle (zwischen Sidebar und Canvas) -->
      <button id="sidebarToggleBtn" title="Sidebar ein-/ausblenden">â—€</button>

      <!-- â”€â”€ Canvas-Bereich â”€â”€ -->
      <div id="canvasWrapper">

        <!-- Toolbar -->
        <div id="toolbar">
          <!-- Zeichenwerkzeuge -->
          <button class="tool-btn active" data-tool="pen" title="Stift">âœï¸</button>
          <button class="tool-btn" data-tool="highlighter" title="Marker">ğŸ–Šï¸</button>
          <button class="tool-btn" data-tool="eraser" title="Radierer">â¬œ</button>
          <button class="tool-btn" data-tool="line" title="Linie">â•±</button>
          <button class="tool-btn" data-tool="rect" title="Rechteck">â–­</button>
          <button class="tool-btn" data-tool="circle" title="Kreis">â—¯</button>

          <div class="toolbar-sep"></div>

          <!-- Farbe & StÃ¤rke -->
          <input type="color" id="colorPicker" value="#000000" title="Farbe wÃ¤hlen">
          <button class="stroke-btn active" data-width="2" title="DÃ¼nn">Â·</button>
          <button class="stroke-btn" data-width="5" title="Mittel">â€”</button>
          <button class="stroke-btn" data-width="9" title="Dick">â”</button>

          <div class="toolbar-sep"></div>

          <!-- Aktionen -->
          <button id="undoBtn" title="RÃ¼ckgÃ¤ngig (Strg+Z)">â†¶</button>
          <button id="redoBtn" title="Wiederholen (Strg+Y)">â†·</button>
          <button id="clearBtn" title="Seite leeren">ğŸ§¹</button>

          <div class="toolbar-sep"></div>

          <!-- Zoom-Steuerung -->
          <button id="zoomOutBtn" title="Herauszoomen">âˆ’</button>
          <span id="zoomLabel">100%</span>
          <button id="zoomInBtn" title="Hineinzoomen">ï¼‹</button>
          <button id="zoomResetBtn" title="Zoom zurÃ¼cksetzen">âŠ¡</button>

          <div class="toolbar-sep"></div>

          <!-- Touch-Modus (Finger: Zeichnen / Scrollen) -->
          <button id="touchModeBtn" title="Touch-Modus umschalten" style="font-size:13px;">âœï¸</button>
        </div>

        <!-- Canvas-Container (Overflow fÃ¼r Zoom/Pan) -->
        <div id="canvasContainer">
          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- KARTEIKARTEN-TAB -->
    <div id="cardsSection" class="section">
      <iframe 
        id="karteikarten-frame"
        src="karteikarten/index.html" 
        style="width:100%; height:100%; border:none; display:block;"
        allowfullscreen>
      </iframe>
    </div>

    <!-- PLANER-TAB -->
    <div id="plannerSection" class="section" style="padding:0;overflow:hidden;">
      <iframe
        id="plannerFrame"
        src="planner/index.html"
        style="width:100%;height:100%;border:none;display:block;"
        title="Planner"
      ></iframe>
    </div>

    <!-- FORMELN-TAB -->
    <div id="formulasSection" class="section">
      <div class="card">
        <h3>Formel hinzufÃ¼gen</h3>
        <div class="row">
          <div><input type="text" id="formulaName" placeholder="Name (z.B. ideale Gasgleichung)"></div>
          <div><input type="text" id="formulaExpression" placeholder="Formel (z.B. pÂ·V = nÂ·RÂ·T)"></div>
        </div>
        <div class="row">
          <div><input type="text" id="formulaTopic" placeholder="Thema (z.B. Allgemeine Chemie / Thermodynamik)"></div>
          <div><input type="text" id="formulaVariables" placeholder="Variablen & Einheiten (p=..., V=..., ...)"></div>
        </div>
        <div class="row">
          <div><textarea id="formulaNotes" placeholder="Hinweise, typische Fehler, etc."></textarea></div>
          <div style="flex:0 0 auto; align-self:flex-end; display:flex; flex-direction:column; gap:6px;">
            <button id="addFormulaBtn">ï¼‹ Formel speichern</button>
            <button id="loadBiotechFormulasBtn" type="button">ğŸ“¥ Biotech-Basisformeln laden</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Formelsammlung</h3>
        <input type="text" id="formulaFilter" placeholder="Suche nach Name / Thema..." style="margin-bottom:6px;">
        <div id="formulaList"></div>
      </div>
    </div>

    <!-- TOOLS-TAB (Rechentool) -->
    <div id="toolsSection" class="section">

      <!-- Chemie-Rechentool -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">âš—ï¸</span>
          <span class="tool-title">Chemie-Rechentool</span>
        </summary>
        <div class="tool-content">
          <div class="row">
            <div>
              <select id="toolFormulaSelect">
                <option value="dilution">VerdÃ¼nnung (câ‚Â·Vâ‚ = câ‚‚Â·Vâ‚‚)</option>
                <option value="lambert">Lambert-Beer-Gesetz (A = ÎµÂ·cÂ·l)</option>
              </select>
            </div>
          </div>
          <div id="toolInputs" style="margin-top:8px;"></div>
          <div style="margin-top:6px;">
            <button id="toolCalcBtn">Berechnen</button>
            <span id="toolResult" style="font-size:13px; margin-left:8px;"></span>
          </div>
        </div>
      </details>

      <!-- pH-Rechner -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ§ª</span>
          <span class="tool-title">pH-Rechner</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:400px;">
            <label>
              Hâº-Konzentration (mol/L):
              <input id="phH" type="number" step="0.0000001" value="0.0001" placeholder="z.B. 0.0001">
            </label>
            <button id="phCalcBtn">pH berechnen</button>
            <div id="phResult" style="font-size:14px; font-weight:600; margin-top:4px;"></div>
          </div>
        </div>
      </details>

      <!-- Molmasse-Rechner -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">âš–ï¸</span>
          <span class="tool-title">Molmasse-Rechner</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:400px;">
            <label>
              Summenformel eingeben (z.B. H2O, NaCl, C6H12O6):
              <input id="molFormula" type="text" placeholder="z.B. H2O">
            </label>
            <button id="molCalcBtn">Molmasse berechnen</button>
            <div id="molResult" style="font-size:14px; font-weight:600; margin-top:4px;"></div>
          </div>
        </div>
      </details>

      <!-- Graphen-Zeichen-Tool -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ“ˆ</span>
          <span class="tool-title">Funktions-Plotter</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:700px;">
            <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap;">
              <label style="flex:1; min-width:200px;">
                Funktion (z.B. x^2, sin(x), 2*x+1):
                <input id="graphFunc" type="text" placeholder="x^2" value="x^2">
              </label>
              <label style="width:90px;">
                x von:
                <input id="graphXmin" type="number" value="-10" step="0.5">
              </label>
              <label style="width:90px;">
                bis:
                <input id="graphXmax" type="number" value="10" step="0.5">
              </label>
            </div>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:6px;">
              <button id="graphPlotBtn">ğŸ“Š Plotten</button>
              <button id="graphAddBtn">â• HinzufÃ¼gen</button>
              <button id="graphClearBtn">ğŸ—‘ï¸ Clear</button>
              <button id="graphToggleYAxis">âš™ï¸ Y-Achse</button>
            </div>
            
            <!-- Analyse-Features -->
            <div style="display:flex; gap:6px; flex-wrap:wrap; padding:8px; background:rgba(123,140,255,0.08); border-radius:8px;">
              <div style="font-size:11px; font-weight:600; width:100%; margin-bottom:4px;">ğŸ“Š Analyse:</div>
              <button id="graphDerivBtn" title="Ableitung anzeigen">ğŸ“ˆ Ableitung</button>
              <button id="graphZerosBtn" title="Nullstellen anzeigen">ğŸ¯ Nullstellen</button>
              <button id="graphExtremaBtn" title="Extrema anzeigen">â›°ï¸ Extrema</button>
              <button id="graphPolarBtn" title="Polar-Modus">ğŸŒ€ Polar</button>
            </div>
            
            <!-- Zoom/Pan Controls -->
            <div style="display:grid; grid-template-columns:auto 1fr auto; gap:8px; padding:8px; background:rgba(255,255,255,0.04); border-radius:8px; align-items:center;">
              <div style="font-size:11px; font-weight:600;">ğŸ” Navigation:</div>
              <div style="display:flex; gap:4px; justify-content:center; flex-wrap:wrap;">
                <button id="graphZoomInBtn" title="Hineinzoomen">ğŸ” +</button>
                <button id="graphZoomOutBtn" title="Herauszoomen">ğŸ” âˆ’</button>
                <button id="graphResetZoomBtn" title="Zoom zurÃ¼cksetzen">â†º Reset</button>
                <button id="graphPanUpBtn" title="Nach oben">â†‘</button>
                <button id="graphPanDownBtn" title="Nach unten">â†“</button>
                <button id="graphPanLeftBtn" title="Nach links">â†</button>
                <button id="graphPanRightBtn" title="Nach rechts">â†’</button>
                <button id="graphCenterBtn" title="Zentrieren">âŠ™ Center</button>
              </div>
              <div id="graphZoomLevel" style="font-size:11px; opacity:0.8; min-width:60px; text-align:right;">1.0x</div>
            </div>
            
            <div style="padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px; font-size:10px; opacity:0.8;">
              ğŸ’¡ <b>Maus:</b> Mausrad = Zoom | Drag = Pan | Doppelklick = Reset | Shift+Click = Tangente<br>
              ğŸ“ <b>Funktionen:</b> sin, cos, tan, ln, log, exp, sqrt, abs, pi, e, factorial, heaviside, etc.<br>
              ğŸ“ <b>Parametrisch:</b> Eingabe als "x(t); y(t)" z.B. "cos(t); sin(t)" fÃ¼r Kreis
            </div>
            <!-- Manuelle Y-Achsen-Einstellung -->
            <div id="graphManualYAxisDiv" style="display:none; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px;">
              <div style="font-size:11px; font-weight:600; margin-bottom:6px; opacity:0.9;">ğŸ“ Y-Achse manuell:</div>
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:11px;">
                <label style="display:flex; flex-direction:column; gap:2px;">
                  <span style="opacity:0.8;">y min</span>
                  <input id="graphYmin" type="number" value="" placeholder="auto" step="1" style="font-size:11px; padding:3px;">
                </label>
                <label style="display:flex; flex-direction:column; gap:2px;">
                  <span style="opacity:0.8;">y max</span>
                  <input id="graphYmax" type="number" value="" placeholder="auto" step="1" style="font-size:11px; padding:3px;">
                </label>
              </div>
              <div style="margin-top:6px; display:flex; gap:6px;">
                <button id="graphApplyYAxis" style="font-size:11px; padding:4px 10px;">âœ“ Anwenden</button>
                <button id="graphResetYAxis" style="font-size:11px; padding:4px 10px;">â†» Auto</button>
              </div>
            </div>
            <canvas id="graphCanvas" width="2000" height="1200" 
                    style="width:100%; max-width:1200px; height:auto; border-radius:12px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08); cursor:grab;">
            </canvas>
            <div id="graphInfo" style="font-size:11px; opacity:.7;"></div>
          </div>
        </div>
      </details>

      <!-- Bakterienwachstums-Simulation -->
      <details class="tool-card" id="bioSimCard">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ§¬</span>
          <span class="tool-title">Bakterienwachstums-Simulation</span>
        </summary>
        <div class="tool-content">

          <!-- Mini-Tabs fÃ¼r Parameter-Gruppen -->
          <div class="bio-tabs">
            <button class="bio-tab active" data-bio-tab="basic">Basis-Parameter</button>
            <button class="bio-tab" data-bio-tab="environment">Umwelt</button>
            <button class="bio-tab" data-bio-tab="advanced">Advanced</button>
          </div>

          <div style="display:grid; grid-template-columns: 1fr 1.2fr; gap:16px; margin-top:16px;">
            
            <!-- Parameter-Bereich -->
            <div>
              <!-- Basis-Parameter -->
              <div class="bio-tab-content active" data-bio-content="basic">
                <div class="param-group">
                  <div class="param-group-title">ğŸ¦  Population</div>
                  <label class="bio-param">
                    <span>Startpopulation Nâ‚€</span>
                    <input id="bioN0" type="range" min="10" max="1000000" step="10" value="1000">
                    <span id="bioN0Val" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Wachstumsrate râ‚€</span>
                    <input id="bioR0" type="range" min="0.05" max="1.2" step="0.01" value="0.60">
                    <span id="bioR0Val" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>KapazitÃ¤t Kâ‚€</span>
                    <input id="bioK0" type="range" min="100" max="1000000" step="100" value="200000">
                    <span id="bioK0Val" class="param-val"></span>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">â±ï¸ Simulation</div>
                  <label class="bio-param">
                    <span>Dauer (h)</span>
                    <input id="bioTmax" type="range" min="1" max="72" step="1" value="24">
                    <span id="bioTmaxVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Zeitschritt dt (h)</span>
                    <input id="bioDt" type="range" min="0.01" max="0.5" step="0.01" value="0.05">
                    <span id="bioDtVal" class="param-val"></span>
                  </label>
                </div>
              </div>

              <!-- Umwelt-Parameter -->
              <div class="bio-tab-content" data-bio-content="environment">
                <div class="param-group">
                  <div class="param-group-title">ğŸŒ¡ï¸ Umweltbedingungen</div>
                  <label class="bio-param">
                    <span>NÃ¤hrstoffe (%)</span>
                    <input id="bioNutr" type="range" min="0" max="100" step="1" value="70">
                    <span id="bioNutrVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Temperatur (Â°C)</span>
                    <input id="bioTemp" type="range" min="0" max="50" step="0.5" value="37">
                    <span id="bioTempVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>pH-Wert</span>
                    <input id="bioPH" type="range" min="3" max="10" step="0.1" value="7.0">
                    <span id="bioPHVal" class="param-val"></span>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">âš¡ Presets</div>
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                    <button type="button" id="bioPresetOptimal">âœ… Optimal</button>
                    <button type="button" id="bioPresetCold">â„ï¸ Kalt</button>
                    <button type="button" id="bioPresetPHStress">âš ï¸ pH-Stress</button>
                    <button type="button" id="bioPresetLowNutr">ğŸ½ï¸ Arm</button>
                  </div>
                </div>
              </div>

              <!-- Advanced Parameter -->
              <div class="bio-tab-content" data-bio-content="advanced">
                <div class="param-group">
                  <div class="param-group-title">âš™ï¸ Erweitert</div>
                  <label class="bio-param">
                    <span>Stress-Schwelle</span>
                    <input id="bioStressThr" type="range" min="0.05" max="0.80" step="0.01" value="0.30">
                    <span id="bioStressThrVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Sterberate (1/h)</span>
                    <input id="bioDeathMax" type="range" min="0.00" max="1.50" step="0.01" value="0.25">
                    <span id="bioDeathMaxVal" class="param-val"></span>
                  </label>
                  <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                    <input id="bioAdvancedToggle" type="checkbox">
                    <span style="font-size:12px;">Integrator-Auswahl aktivieren</span>
                  </label>
                  <label id="bioIntegratorWrap" style="display:none; margin-top:8px;">
                    <span style="font-size:12px;">Integrator:</span>
                    <select id="bioIntegrator" style="margin-left:6px; font-size:12px;">
                      <option value="euler">Euler</option>
                      <option value="heun">RK2 / Heun</option>
                    </select>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">â„¹ï¸ Modell</div>
                  <div style="font-size:11px; line-height:1.5; opacity:0.8;">
                    <div><b>Gleichung:</b> dN/dt = rÂ·NÂ·(1âˆ’N/K) âˆ’ dÂ·N</div>
                    <div style="margin-top:4px;"><b>Umwelt:</b> Fitness â†’ r, NÃ¤hrstoffe â†’ K</div>
                    <div style="margin-top:4px;"><b>Numerik:</b> Euler (Standard) / RK2</div>
                  </div>
                </div>
              </div>

              <!-- Buttons -->
              <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:12px;">
                <button id="bioRunBtn">â–¶ï¸ Simulieren</button>
                <button id="bioAddBtn">â• Vergleich</button>
                <button id="bioClearBtn">ğŸ—‘ï¸ Clear</button>
              </div>
            </div>

            <!-- Canvas-Bereich -->
            <div>
              <canvas id="bioCanvas" width="1200" height="750"
                      style="width:100%; height:auto; border-radius:12px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08);">
              </canvas>
              
              <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; font-size:11px;">
                <button id="bioExportPlotBtn" style="font-size:11px; padding:4px 8px;">ğŸ“· PNG</button>
                <button id="bioExportCsvBtn" style="font-size:11px; padding:4px 8px;">ğŸ“Š CSV</button>
                <button id="bioExportJsonBtn" style="font-size:11px; padding:4px 8px;">ğŸ“„ JSON</button>
                <span style="width:8px;"></span>
                <button id="bioAxisLockBtn" style="font-size:11px; padding:4px 8px;">ğŸ”’ Lock</button>
                <button id="bioAxisAutoBtn" style="font-size:11px; padding:4px 8px;">ğŸ”“ Auto</button>
                <span id="bioAxisStatus" style="opacity:.7; margin-left:6px;"></span>
              </div>

              <!-- Manuelle Achsen-Einstellung -->
              <div id="bioManualAxisDiv" style="display:none; margin-top:8px; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px;">
                <div style="font-size:11px; font-weight:600; margin-bottom:6px; opacity:0.9;">ğŸ“ Achsen manuell einstellen:</div>
                <div style="display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:6px; font-size:11px;">
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">t min (h)</span>
                    <input id="bioAxisTmin" type="number" value="0" step="1" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">t max (h)</span>
                    <input id="bioAxisTmax" type="number" value="24" step="1" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">N min</span>
                    <input id="bioAxisNmin" type="number" value="0" step="1000" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">N max</span>
                    <input id="bioAxisNmax" type="number" value="200000" step="1000" style="font-size:11px; padding:3px;">
                  </label>
                </div>
                <div style="margin-top:6px; display:flex; gap:6px;">
                  <button id="bioApplyAxisBtn" style="font-size:11px; padding:4px 10px;">âœ“ Anwenden</button>
                  <button id="bioToggleManualAxis" style="font-size:11px; padding:4px 10px;">âœ• SchlieÃŸen</button>
                </div>
              </div>
              <button id="bioToggleManualAxis" style="font-size:11px; padding:4px 8px; margin-top:6px;">âš™ï¸ Achsen manuell</button>

              <div id="bioInfo" style="margin-top:8px; font-size:11px; opacity:.7;"></div>
            </div>

          </div>

        </div>
      </details>


    </div>



    <!-- LERNEN-TAB -->
    <div id="learnSection" class="section">
      <div id="learnLayout">
        <div id="learnSidebar">
          <div>
            <div style="font-size:11px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.7;">FÃ¤cher</div>
            <ul id="learnSubjects"></ul>
          </div>
          <div>
            <div style="font-size:11px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.7; margin-top:6px;">Themen</div>
            <ul id="learnTopics"></ul>
          </div>
        </div>
        <div id="learnContent">
          <!-- wird per JS gefÃ¼llt -->
        </div>
      </div>
    </div>

    <!-- AUFGABEN-TAB -->
    <div id="tasksSection" class="section">
      <div class="card">
        <h3>Rechenaufgabe / VerstÃ¤ndnisaufgabe hinzufÃ¼gen</h3>
        <div class="row">
          <div><input type="text" id="taskTitle" placeholder="Kurzbeschreibung (z.B. pV=nRT umstellen)"></div>
          <div><input type="text" id="taskTopic" placeholder="Thema / Modul (z.B. Allg. Chemie)"></div>
        </div>
        <div class="row">
          <div><textarea id="taskText" placeholder="Aufgabe (Text oder kopierter Inhalt)"></textarea></div>
          <div><textarea id="taskNotes" placeholder="Dein LÃ¶sungsweg / Notizen (optional)"></textarea></div>
        </div>
        <div class="row">
          <div style="flex:0 0 auto;"><button id="addTaskBtn">ï¼‹ Aufgabe speichern</button></div>
        </div>
      </div>

      <div class="card">
        <h3>Aufgaben-Liste</h3>
        <div id="taskList"></div>
      </div>
    </div>

    <!-- BRAIN-DUMP-TAB -->
    <div id="brainSection" class="section">
      <div class="card">
        <h3>Brain-Dump (Gedanken, Sorgen, Ideen)</h3>
        <textarea id="brainText" placeholder="Alles, was im Kopf rumschwirrt..."></textarea>
        <div style="margin-top:6px;">
          <button id="saveBrainBtn">Speichern</button>
          <span id="brainStatus" style="font-size:11px; opacity:0.7; margin-left:6px;"></span>
        </div>
      </div>

      <div class="card">
        <h3>Vergangene EintrÃ¤ge</h3>
        <div id="brainHistory"></div>
      </div>
    </div>

    <!-- BIO/CHEMIE-TAB -->
    <div id="biochemSection" class="section">
      <div class="card" style="padding: 0; overflow: hidden; height: calc(100vh - 150px);">
        <iframe 
          id="aminoFrame" 
          src="amino-tool/index.html" 
          style="width: 100%; height: 100%; border: none; display: block;"
          title="AminosÃ¤uren 3D Viewer"
        ></iframe>
      </div>
    </div>

    <!-- STATS-TAB -->
    <!-- STATS-TAB -->
<div id="statsSection" class="section">
  	<div class="card">
   	 <h3>Lern-Stats (einfach)</h3>
   	 <div id="statsContent"></div>
  	</div>

  <div class="card">
    	<h3>Sync-Einstellungen</h3>
   	 <div class="row">
     		 <div>
        <input type="text" id="syncIdInput" placeholder="z.B. CARINA-UNI-01">
      </div>
      <div style="flex:0 0 auto;">
        <button id="syncSaveIdBtn">Sync-ID speichern</button>
      </div>
    </div>
    <div style="margin-top:6px; font-size:12px; opacity:0.8;">
      GerÃ¤te mit der gleichen Sync-ID greifen auf dieselben Cloud-Daten zu.
      Wenn du keine Sync-ID setzt, bleibt alles nur lokal auf diesem GerÃ¤t.
    </div>
    <div id="syncStatus" style="margin-top:4px; font-size:11px; opacity:0.7;"></div>
  </div>
</div>


<script type="module">

// ---------- Firebase Setup ----------
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC0gBG9LNOOjWib7u5a5Ztq2bd9MGg7k",
  authDomain: "uni-hyper-notes.firebaseapp.com",
  projectId: "uni-hyper-notes",
  storageBucket: "uni-hyper-notes.firebasestorage.app",
  messagingSenderId: "1430311668000",
  appId: "1:1430311668000:web:802d30dea4e71fabfa77f45",
  measurementId: "G-2QN7W0W73K"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Sync-ID
let syncId = localStorage.getItem("uniHyperNotes_syncId") || null;

function askForSyncId() {
  if (!syncId) {
    const defaultId = "user-" + Math.random().toString(36).slice(2, 8);
    const entered = prompt("Sync-ID eingeben oder neue anlegen:", defaultId);
    syncId = (entered || defaultId).trim();
    localStorage.setItem("uniHyperNotes_syncId", syncId);
  }
  return syncId;
}

// --- Elemente fÃ¼r die Sync-UI ---
const syncIdInput  = document.getElementById("syncIdInput");
const syncSaveBtn  = document.getElementById("syncSaveIdBtn");
const syncStatusEl = document.getElementById("syncStatus");

// Sync-ID ins Eingabefeld schreiben (falls schon vorhanden)
if (syncIdInput && syncId) {
  syncIdInput.value = syncId;
}

// Statusanzeige bequem setzen
function updateSyncStatus(msg) {
  if (syncStatusEl) {
    syncStatusEl.textContent = msg;
  }
  console.log("[SYNC]", msg);
}

// ---------- LERN-DATEN (Allgemeine Chemie, erweitert) ----------
const learnData = {
  subjects: [
    {
      id: "allg-chem",
      name: "Allgemeine Chemie",
      description:
        "Grundlagen des Aufbaus der Materie, chemische Bindungen, StÃ¶chiometrie, SÃ¤ure-Base, Redox, Titrationen & Laborsicherheit â€“ auf Klausur-Niveau.",
      topics: [
        {
          id: "aufbau-materie",
          title: "Aufbau der Materie & Atome",
          tags: ["Atome", "ElektronenhÃ¼lle", "Kern"],
          goals: [
            "Aufbau von Atomen (Protonen, Neutronen, Elektronen) sicher erklÃ¤ren.",
            "Ordnungszahl, Massenzahl und Isotope unterscheiden und Beispiele angeben.",
            "Elektronenkonfiguration fÃ¼r einfache Elemente schreiben (z. B. H, He, C, O, Na, Cl)."
          ],
          summary:
            "Materie besteht aus Atomen. Ein Atom besitzt einen positiv geladenen Kern (Protonen und Neutronen) und eine negativ geladene ElektronenhÃ¼lle. Die Ordnungszahl Z entspricht der Protonenzahl und definiert das Element. Isotope haben dieselbe Protonenzahl, aber unterschiedliche Neutronenzahlen. FÃ¼r die Chemie sind vor allem die Valenzelektronen (AuÃŸenelektronen) entscheidend, da sie an Bindungen beteiligt sind.",
          keyPoints: [
            "Ordnungszahl Z = Anzahl der Protonen = Anzahl der Elektronen im neutralen Atom.",
            "Massenzahl A â‰ˆ Protonen + Neutronen; Neutronenzahl N = A âˆ’ Z.",
            "Isotope: z. B. Â¹Â²C, Â¹Â³C, Â¹â´C â€“ alle Kohlenstoff, aber mit unterschiedlicher Massenzahl.",
            "Elektronenkonfiguration zeigt Verteilung in Schalen/Unterschalen (z. B. 1sÂ² 2sÂ² 2pÂ²).",
            "Valenzelektronen bestimmen ReaktivitÃ¤t (z. B. Edelgase: volle Schale â†’ sehr reaktionstrÃ¤ge)."
          ],
          formulas: ["A = Z + N"],
          visual: `
            <div>Atommodell (vereinfachtes Kugelmodell):</div>
            <svg viewBox="0 0 140 80" width="140" height="80">
              <circle cx="45" cy="40" r="18" fill="rgba(123,140,255,0.35)" stroke="currentColor"/>
              <circle cx="95" cy="40" r="26" fill="none" stroke="currentColor" stroke-dasharray="4 3"/>
              <circle cx="95" cy="16" r="3" fill="currentColor"/>
              <circle cx="116" cy="40" r="3" fill="currentColor"/>
              <circle cx="74" cy="40" r="3" fill="currentColor"/>
            </svg>
            <div style="font-size:11px;opacity:0.8;margin-top:4px;">Innen: Kern (pâº, nâ°) â€“ auÃŸen: Elektronen auf Schale.</div>
          `
        },
        {
          id: "periodensystem",
          title: "Periodensystem der Elemente (PSE)",
          tags: ["PSE", "Trends", "Gruppen"],
          goals: [
            "Perioden und Gruppen im PSE sicher benennen.",
            "Hauptgruppen (Alkalimetalle, Erdalkalimetalle, Halogene, Edelgase) zuordnen.",
            "Trends von Atomradius und ElektronegativitÃ¤t qualitativ beschreiben."
          ],
          summary:
            "Das Periodensystem ordnet alle bekannten Elemente nach steigender Ordnungszahl. In einer Gruppe (Spalte) stehen Elemente mit Ã¤hnlicher Valenzelektronenkonfiguration und Ã¤hnlichen chemischen Eigenschaften. In einer Periode (Zeile) nimmt die Ordnungszahl von links nach rechts zu. Wichtige Trends: der Atomradius nimmt innerhalb einer Periode von links nach rechts ab, innerhalb einer Gruppe von oben nach unten zu. Die ElektronegativitÃ¤t zeigt das umgekehrte Verhalten.",
          keyPoints: [
            "Gruppen: z. B. 1. Hauptgruppe = Alkalimetalle (Li, Na, K, ...); 17. Hauptgruppe = Halogene; 18. Hauptgruppe = Edelgase.",
            "Perioden: horizontale Zeilen â€“ geben an, wie viele Schalen im Atom besetzt sind.",
            "Atomradius â†“ nach rechts kleiner, â†‘ nach unten grÃ¶ÃŸer.",
            "ElektronegativitÃ¤t â†‘ nach rechts grÃ¶ÃŸer (bis F), â†‘ nach oben grÃ¶ÃŸer.",
            "Metalle stehen Ã¼berwiegend links unten, Nichtmetalle rechts oben."
          ],
          formulas: [],
          visual: `
            <div style="font-size:11px;margin-bottom:4px;">Sehr vereinfachtes Mini-PSE (nur Hauptgruppen):</div>
            <pre style="font-size:10px;line-height:1.2;">
H                                                   He
Li Be                                      B  C  N  O  F  Ne
Na Mg                                      Al Si P  S  Cl Ar
K  Ca                                      Ga Ge As Se Br Kr
            </pre>
          `
        },
        {
          id: "orbitale",
          title: "Atomorbitale: s- und p-Orbitale",
          tags: ["Orbitale", "s-Orbital", "p-Orbital"],
          goals: [
            "Begriff Orbital (Wahrscheinlichkeitswolke) formulieren.",
            "s-Orbitale als kugelfÃ¶rmig und p-Orbitale als hantelfÃ¶rmig skizzieren.",
            "FÃ¼r p-Orbitale die drei Raumrichtungen (pâ‚“, páµ§, p_z) angeben."
          ],
          summary:
            "Ein Orbital ist kein 'Planet auf einer Kreisbahn', sondern ein Bereich im Raum, in dem sich ein Elektron mit hoher Wahrscheinlichkeit aufhÃ¤lt. s-Orbitale sind kugelfÃ¶rmig um den Kern verteilt. p-Orbitale sind hantelfÃ¶rmig mit zwei Lobes und besitzen drei rÃ¤umliche Ausrichtungen (pâ‚“, páµ§, p_z). In der Klausur wird oft verlangt, ein 1s-Orbital und drei p-Orbitale zu skizzieren und sinnvoll zu beschriften.",
          keyPoints: [
            "s-Orbitale: kugelfÃ¶rmig, 1s liegt am niedrigsten, dann 2s, 3s ...",
            "p-Orbitale: hantelfÃ¶rmig, jeweils zwei 'Lappen' (Lobes) â€“ drei Ausrichtungen: x-, y- und z-Achse.",
            "Maximal 2 Elektronen pro Orbital (mit entgegengesetztem Spin).",
            "Skizze: s-Orbital = Kreis/Kugel; p-Orbital = zwei Kreise/Ellipsen gegenÃ¼berliegend mit Kern in der Mitte."
          ],
          formulas: [],
          visual: `
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <div>
                <div style="font-size:11px;margin-bottom:2px;">s-Orbital (1s)</div>
                <svg viewBox="0 0 70 70" width="70" height="70">
                  <circle cx="35" cy="35" r="22"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="35" cy="35" r="3" fill="currentColor"/>
                </svg>
              </div>
              <div>
                <div style="font-size:11px;margin-bottom:2px;">p-Orbital (z. B. p<sub>z</sub>)</div>
                <svg viewBox="0 0 90 70" width="90" height="70">
                  <circle cx="45" cy="20" r="14"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="45" cy="50" r="14"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="45" cy="35" r="3" fill="currentColor"/>
                </svg>
              </div>
            </div>
            <div style="font-size:11px;opacity:0.8;margin-top:4px;">FÃ¼r die Klausur: Kugel fÃ¼r s, Hantel fÃ¼r p â€“ sauber beschriften reicht vÃ¶llig.</div>
          `
        },
        {
          id: "mo-n2",
          title: "MolekÃ¼lorbitale (MO) â€“ Beispiel Nâ‚‚",
          tags: ["MO-Theorie", "Nâ‚‚", "Bindungsordnung"],
          goals: [
            "Grundidee der MO-Theorie wiedergeben (Orbitale kombinieren zu bindenden/antibindenden MOs).",
            "Ein einfaches MO-Schema fÃ¼r homonukleare zweiatomige MolekÃ¼le skizzieren (z. B. Nâ‚‚).",
            "Bindungsordnung fÃ¼r Nâ‚‚ berechnen und deuten kÃ¶nnen."
          ],
          summary:
            "In der MO-Theorie werden Atomorbitale zu MolekÃ¼lorbitalen kombiniert: bindende (energetisch niedriger) und antibindende (energetisch hÃ¶her). FÃ¼r Nâ‚‚ kombinierst du 2s- und 2p-Orbitale der beiden N-Atome. Wichtig in der Klausur: MO-Schema zeichnen, Energieniveaus sortieren und Elektronen mit Pfeilen eintragen. Danach kannst du die Bindungsordnung bestimmen.",
          keyPoints: [
            "Bindende MOs (Ïƒ, Ï€) liegen energetisch tiefer, antibindende (Ïƒ*, Ï€*) hÃ¶her.",
            "FÃ¼r Nâ‚‚ (14 eâ» pro MolekÃ¼l, also 7 pro Atom): Bindungsordnung = (Bindende eâ» âˆ’ Antibindende eâ»)/2.",
            "Typisch fÃ¼r Nâ‚‚: Bindungsordnung 3 â†’ Dreifachbindung.",
            "MO-Schema sauber mit Pfeilen (â†‘â†“) fÃ¼llen â€“ Hundsche Regel & Pauli-Prinzip beachten."
          ],
          formulas: [
            "Bindungsordnung = (N<sub>bindend</sub> âˆ’ N<sub>antibindend</sub>) / 2"
          ],
          visual: `
            <div style="font-size:11px;margin-bottom:4px;">Sehr vereinfachtes MO-Schema (nur qualitativ):</div>
            <pre style="font-size:10px;line-height:1.2;">
           Ïƒ*2p   (antibindend)
      Ï€2p  Ï€2p
           Ïƒ2p   (bindend)
           Ïƒ*2s
           Ïƒ2s

    Pfeile von unten nach oben eintragen (Energie â†‘).
            </pre>
          `
        ,

      detailBlocks: [
        {
          title: "Schalen, Unterschalen & Orbitale (Haus-Analogie)",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Ein <b>Orbital</b> ist kein Planet auf einer Kreisbahn, sondern ein Aufenthaltsbereich, in dem sich ein Elektron mit hoher Wahrscheinlichkeit aufhÃ¤lt.</p>

              <p>Bild dir ein Haus:</p>
              <ul>
                <li><b>Schale (n)</b> = Stockwerk (n = 1, 2, 3, ...).</li>
                <li><b>Unterschale</b> = Zimmerart im Stockwerk (s, p, d, f).</li>
                <li><b>Orbital</b> = ein konkretes Zimmer, in dem max. 2 Elektronen wohnen.</li>
              </ul>

              <p>Welche Unterschalen es pro Schale geben kann:</p>
              <ul>
                <li>n = 1 â†’ nur 1s</li>
                <li>n = 2 â†’ 2s, 2p</li>
                <li>n = 3 â†’ 3s, 3p, 3d</li>
                <li>n = 4 â†’ 4s, 4p, 4d, 4f</li>
              </ul>
            </div>
          `
        },
        {
          title: "s- vs. p-Orbitale â€“ Formen & KapazitÃ¤t",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>s-Orbitale:</b></p>
              <ul>
                <li>Form: kugelfÃ¶rmig (&bdquo;s&rdquo; â‰ˆ <i>sphere</i>).</li>
                <li>Pro Schale gibt es genau <b>1 s-Orbital</b> (1s, 2s, 3s...).</li>
                <li>Jedes Orbital kann max. <b>2 Elektronen</b> mit entgegengesetztem Spin (â†‘â†“) aufnehmen.</li>
              </ul>

              <p><b>p-Orbitale:</b></p>
              <ul>
                <li>Form: hantel-/erdnussfÃ¶rmig (&bdquo;p&rdquo; â‰ˆ <i>peanut/propeller</i>).</li>
                <li>Pro Schale gibt es <b>3 p-Orbitale</b>: p<sub>x</sub>, p<sub>y</sub>, p<sub>z</sub>.</li>
                <li>Jedes p-Orbital kann wieder 2 Elektronen aufnehmen â†’ insgesamt <b>6 Elektronen</b> in einer p-Unterschale.</li>
              </ul>

              <p>Beispiel 2. Schale (n = 2):</p>
              <ul>
                <li>2s â†’ 1 Orbital â†’ max. 2 eâ»</li>
                <li>2p â†’ 3 Orbitale â†’ max. 6 eâ»</li>
                <li>Gesamt in Schale 2: max. 8 eâ» (2sÂ² 2pâ¶)</li>
              </ul>
            </div>
          `
        },
        {
          title: "Elektronenkonfiguration & Hundsche Regel (2. Periode)",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Elektronenkonfiguration schreibt auf, wie die Elektronen auf die Orbitale verteilt sind, z. B.:</p>

              <p><b>Beispiel Sauerstoff:</b> O: 1sÂ² 2sÂ² 2pâ´</p>
              <ul>
                <li>1sÂ² â†’ 2 Elektronen im 1s-Orbital (innere Schale).</li>
                <li>2sÂ² â†’ 2 Elektronen im 2s-Orbital.</li>
                <li>2pâ´ â†’ 4 Elektronen in den drei 2p-Orbitalen zusammen.</li>
              </ul>

              <p><b>Hundsche Regel (fÃ¼r p-Orbitale):</b></p>
              <ul>
                <li>Entartete Orbitale (z. B. p<sub>x</sub>, p<sub>y</sub>, p<sub>z</sub>) werden zuerst <b>einzeln</b> mit Elektronen gleicher Spinrichtung besetzt (â†‘, â†‘, â†‘).</li>
                <li>Erst danach werden sie gepaart (â†‘â†“, â†‘â†“, â†‘).</li>
              </ul>

              <p><b>Valenzelektronen:</b></p>
              <ul>
                <li>Die Elektronen in der Ã¤uÃŸersten, nicht vollen Schale (bei der 2. Periode: 2s und 2p).</li>
                <li>Beispiele: O hat 6 Valenzelektronen (2sÂ² 2pâ´), F hat 7 (2sÂ² 2pâµ).</li>
              </ul>
            </div>
          `
        },
        {
          title: "Merkkasten fÃ¼r Klausur: Orbitale & MO kurz und knackig",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <ul>
                <li><b>Orbital</b> = Aufenthaltsbereich eines Elektrons, max. 2 Elektronen pro Orbital (â†‘â†“).</li>
                <li><b>s</b>-Orbital = kugelfÃ¶rmig, 1 s-Orbital pro Schale.</li>
                <li><b>p</b>-Orbitale = 3 StÃ¼ck pro Schale, hantelfÃ¶rmig (p<sub>x</sub>, p<sub>y</sub>, p<sub>z</sub>), zusammen max. 6 Elektronen.</li>
                <li>Elektronenkonfiguration: von unten nach oben auffÃ¼llen (1s, 2s, 2p, 3s...), Pauli-Prinzip und Hundsche Regel beachten.</li>
                <li><b>Valenzelektronen</b> = Elektronen der Ã¤uÃŸersten Schale (fÃ¼r Bâ€“Ne: alles, was in 2s und 2p sitzt).</li>
                <li>FÃ¼r MO-Theorie spÃ¤ter wichtig: aus Atomorbitalen (AOs) werden MolekÃ¼lorbitale (MOs), aus 2 AOs â†’ 1 bindendes + 1 antibindendes MO.</li>
              </ul>
              <p style="margin-top:4px; opacity:0.8;">
                Wenn du diese Punkte sicher drauf hast, verstehst du die MO-Schemata (Ïƒ, Ï€, Ïƒ*, Ï€*) viel leichter.
              </p>
            </div>
          `
        }
      ]
      },


        {
          id: "stoechiometrie",
          title: "StÃ¶chiometrie & chemisches Rechnen",
          tags: ["Molare Masse", "Stoffmenge", "Gleichungen"],
          goals: [
            "Stoffmenge aus Masse und molarer Masse berechnen.",
            "Reaktionsgleichungen korrekt nach Atomanzahl ausgleichen.",
            "Grobe Ãœberschlagsrechnungen beherrschen (z. B. mg â†’ mmol)."
          ],
          summary:
            "StÃ¶chiometrie beantwortet die Frage: Wie viel von welcher Substanz reagiert miteinander? Grundlage ist die Stoffmenge n in mol. Ãœber die molare Masse M verknÃ¼pfst du Masse und Stoffmenge. In Klausuraufgaben geht es oft darum, Reaktionsgleichungen zu formulieren, auszubalancieren und aus einer gegebenen Masse oder Konzentration die gesuchte Menge zu bestimmen.",
          keyPoints: [
            "Stoffmenge: n = m / M (mit m in g, M in g/mol â†’ n in mol).",
            "Konzentration: c = n / V (mit V in L, c in mol/L).",
            "Reaktionsgleichung zuerst verbal verstehen, dann nach Atomen ausgleichen.",
            "Im Zweifel: zuerst Metalle, dann Nichtmetalle, dann H und O ausgleichen â€“ oder deine bevorzugte Reihenfolge.",
            "Immer Einheiten mitfÃ¼hren (mg â†’ g â†’ mol)."
          ],
          formulas: [
            "n = m / M",
            "c = n / V"
          ]
        },
        {
  id: "saeure-base-ph",
  title: "SÃ¤ure-Base & pH-Wert (inkl. NaOH)",
  tags: ["BrÃ¸nsted", "pH", "starke Basen"],
  goals: [
    "SÃ¤uren und Basen nach BrÃ¸nsted definieren.",
    "pH starker SÃ¤uren und pH starker Basen (z. B. NaOH) sicher berechnen.",
    "Zusammenhang zwischen pH, pOH und [Hâº]/[OHâ»] sowie dem Ionenprodukt des Wassers (K<sub>w</sub>) nutzen.",
    "Zwischen starken und schwachen SÃ¤uren/Basen unterscheiden und die passenden Rechenwege kennen."
  ],
  summary:
    "Nach BrÃ¸nsted ist eine SÃ¤ure ein Protonendonator und eine Base ein Protonenakzeptor. Starke SÃ¤uren/Basen dissoziieren im betrachteten Konzentrationsbereich praktisch vollstÃ¤ndig, schwache nur teilweise. FÃ¼r starke SÃ¤uren/Basen kannst du die Konzentration direkt mit [Hâº] oder [OHâ»] gleichsetzen. Ãœber pH, pOH und das Ionenprodukt des Wassers (Kw) lÃ¤sst sich die jeweils andere GrÃ¶ÃŸe berechnen. In Klausuren geht es hÃ¤ufig um das sichere Anwenden weniger Standardrezepte.",
  keyPoints: [
    "BrÃ¸nsted-SÃ¤ure: Protonendonator; BrÃ¸nsted-Base: Protonenakzeptor.",
    "Starke SÃ¤ure/Base: nahezu vollstÃ¤ndige Dissoziation â†’ [Hâº] â‰ˆ c(SÃ¤ure), [OHâ»] â‰ˆ c(Base).",
    "Wasserautoionisation: Hâ‚‚O â‡Œ Hâº + OHâ»; K<sub>w</sub> = [Hâº]Â·[OHâ»] â‰ˆ 1,0Â·10â»Â¹â´ (25 Â°C).",
    "pH = âˆ’logâ‚â‚€([Hâº]); pOH = âˆ’logâ‚â‚€([OHâ»]); pH + pOH = 14 (bei 25 Â°C).",
    "FÃ¼r NaOH: [OHâ»] = c(NaOH) (starke Base, 1:1-StÃ¶chiometrie).",
    "FÃ¼r starke SÃ¤uren/Basen reicht meist das einfache Rezept â€“ schwache SÃ¤uren/Basen brauchen Gleichgewichtsbetrachtung (K<sub>a</sub> oder K<sub>b</sub>) oder NÃ¤herungen."
  ],
  formulas: [
    "pH = âˆ’logâ‚â‚€([Hâº])",
    "pOH = âˆ’logâ‚â‚€([OHâ»])",
    "pH + pOH = 14 (bei 25 Â°C)",
    "K<sub>w</sub> = [Hâº]Â·[OHâ»] â‰ˆ 1,0Â·10â»Â¹â´"
  ],
  visual: `
    <div style="font-size:11px;margin-bottom:4px;">Rechenwege auf einen Blick:</div>
    <pre style="font-size:10px;line-height:1.3;">
Starke SÃ¤ure (z. B. HCl):
    c(HCl) = 0,010 mol/L
    â†’ [Hâº] â‰ˆ 0,010 mol/L
    â†’ pH = âˆ’log(0,010) = 2

Starke Base (z. B. NaOH):
    c(NaOH) = 0,010 mol/L
    â†’ [OHâ»] â‰ˆ 0,010 mol/L
    â†’ pOH = 2
    â†’ pH = 14 âˆ’ 2 = 12
    </pre>
  `,
  detailBlocks: [
    {
      title: "Definitionen & Grundbegriffe",
      content: `
        <ul style="padding-left:18px; margin:0;">
          <li><b>BrÃ¸nsted-SÃ¤ure:</b> Teilchen, das ein Proton (Hâº) abgeben kann. Beispiel: HCl, HNOâ‚ƒ, CHâ‚ƒCOOH.</li>
          <li><b>BrÃ¸nsted-Base:</b> Teilchen, das ein Proton aufnehmen kann. Beispiel: OHâ», NHâ‚ƒ, CHâ‚ƒCOOâ».</li>
          <li><b>Konjugiertes SÃ¤ure-Base-Paar:</b> SÃ¤ure und Base, die sich nur um ein Proton unterscheiden (z. B. HCl/Clâ»).</li>
          <li><b>Starke SÃ¤ure/Base:</b> Dissoziiert in Wasser praktisch vollstÃ¤ndig (im betrachteten Konzentrationsbereich).</li>
          <li><b>Schwache SÃ¤ure/Base:</b> Nur teilweise dissoziiert; es stellt sich ein Gleichgewicht ein (K<sub>a</sub> oder K<sub>b</sub> beschreibt die StÃ¤rke).</li>
          <li><b>pH-Skala:</b> MaÃŸ fÃ¼r die Wasserstoffionenkonzentration; pH &lt; 7 sauer, pH = 7 neutral, pH &gt; 7 basisch (bei 25 Â°C).</li>
        </ul>
      `
    },
    {
      title: "Rezept: pH starker SÃ¤uren",
      content: `
        <ol style="padding-left:18px; margin:0;">
          <li><b>PrÃ¼fen:</b> Ist es eine starke SÃ¤ure? (z. B. HCl, HBr, HI, HNOâ‚ƒ, Hâ‚‚SOâ‚„ (1. Proton), HClOâ‚„)</li>
          <li><b>Spezies bestimmen:</b> Wie viele Hâº pro MolekÃ¼l? (z. B. HCl â†’ 1 Hâº, Hâ‚‚SOâ‚„ â†’ 2 Hâº)</li>
          <li><b>[Hâº] berechnen:</b> [Hâº] â‰ˆ <i>n<sub>Hâº</sub></i> Â· c(SÃ¤ure).</li>
          <li><b>pH berechnen:</b> pH = âˆ’logâ‚â‚€([Hâº]).</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          Beispiel: c(HCl) = 0,050 mol/L â†’ starke einprotonige SÃ¤ure â‡’ [Hâº] â‰ˆ 0,050 mol/L â‡’ pH = âˆ’log(0,050) â‰ˆ 1,30.
        </div>
      `
    },
    {
      title: "Rezept: pH starker Basen (z. B. NaOH)",
      content: `
        <ol style="padding-left:18px; margin:0;">
          <li><b>PrÃ¼fen:</b> Ist es eine starke Base? (z. B. NaOH, KOH, Ba(OH)â‚‚).</li>
          <li><b>Spezies bestimmen:</b> Wie viele OHâ» pro Formeleinheit? (NaOH â†’ 1, Ba(OH)â‚‚ â†’ 2).</li>
          <li><b>[OHâ»] berechnen:</b> [OHâ»] â‰ˆ <i>n<sub>OHâ»</sub></i> Â· c(Base).</li>
          <li><b>pOH berechnen:</b> pOH = âˆ’logâ‚â‚€([OHâ»]).</li>
          <li><b>pH berechnen:</b> pH = 14 âˆ’ pOH (bei 25 Â°C).</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          Beispiel: c(NaOH) = 0,020 mol/L â†’ [OHâ»] â‰ˆ 0,020 mol/L â†’ pOH = âˆ’log(0,020) â‰ˆ 1,70 â†’ pH â‰ˆ 12,30.
        </div>
      `
    },
    {
      title: "Beispielaufgabe (klassischer Klausurstil)",
      content: `
        <div style="font-size:12px; margin-bottom:4px;">
          <b>Aufgabe:</b> Berechne den pH-Wert einer 0,010 mol/L Natronlauge (NaOH). Gehe von vollstÃ¤ndiger Dissoziation aus.
        </div>
        <ol style="padding-left:18px; margin:0;">
          <li><b>Schritt 1:</b> NaOH ist eine starke Base, 1:1-StÃ¶chiometrie: NaOH â†’ Naâº + OHâ».</li>
          <li><b>Schritt 2:</b> [OHâ»] â‰ˆ c(NaOH) = 0,010 mol/L.</li>
          <li><b>Schritt 3:</b> pOH = âˆ’log(0,010) = 2.</li>
          <li><b>Schritt 4:</b> pH = 14 âˆ’ pOH = 14 âˆ’ 2 = 12.</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          <b>Antwort:</b> pH â‰ˆ 12, die LÃ¶sung ist deutlich basisch.
        </div>
      `
    },
    {
      title: "Typische Klausurfallen & MerksÃ¤tze",
      content: `
        <ul style="padding-left:18px; margin:0;">
          <li><b>Falle 1:</b> pH direkt aus c(Base) berechnen (statt Ã¼ber pOH) â‡’ immer erst [OHâ»] â†’ pOH â†’ pH.</li>
          <li><b>Falle 2:</b> Mehrprotonige SÃ¤uren/Basen ignorieren:
              z. B. Hâ‚‚SOâ‚„ â€“ im ersten Schritt gibt es 2 Hâº pro MolekÃ¼l â†’ [Hâº] â‰ˆ 2Â·c(Hâ‚‚SOâ‚„).</li>
          <li><b>Falle 3:</b> Falsche Einheiten: Konzentrationen mÃ¼ssen in mol/L eingesetzt werden, nicht in g/L.</li>
          <li><b>Falle 4:</b> K<sub>w</sub> vergessen: Bei sehr verdÃ¼nnten LÃ¶sungen oder wenn nur [OHâ»] gegeben ist, hilft K<sub>w</sub> = [Hâº][OHâ»].</li>
          <li><b>Merksatz:</b> "Stark" heiÃŸt: ich darf [Hâº] bzw. [OHâ»] (fast) gleich der Anfangskonzentration setzen.</li>
        </ul>
      `
    }
  ]
}
,
{
  id: "titrationen",
  title: "Titrationen (SÃ¤ure-Base, FÃ¤llung, Komplexometrie, Redox)",
  tags: ["Titration", "Ã„quivalenzpunkt", "Titrationskurve", "Gehaltsbestimmung"],
  goals: [
    "Das Grundprinzip einer Titration erklÃ¤ren kÃ¶nnen.",
    "Ã„quivalenzpunkt, Umschlagpunkt und Endpunkt sicher unterscheiden.",
    "Gehaltsbestimmung aus câ‚Â·Vâ‚ = câ‚‚Â·Vâ‚‚ in einfachen FÃ¤llen durchfÃ¼hren.",
    "Den Unterschied zwischen SÃ¤ure-Base-, FÃ¤llungs-, komplexometrischen und Redoxtitrationen kennen."
  ],
  summary:
    "Bei einer Titration wird eine MaÃŸlÃ¶sung definierter Konzentration zu einer Probe gegeben, bis die stÃ¶chiometrische Menge erreicht ist (Ã„quivalenzpunkt). Ãœber das verbrauchte Volumen und die bekannte Konzentration der MaÃŸlÃ¶sung kann man die Konzentration der Probe berechnen. In der Klausur sind typische Themen: SÃ¤ure-Base-Titrationen, Ã„quivalenzpunkt-Bestimmung, Indikatorwahl, einfache Gehaltsberechnung.",
  keyPoints: [
    "MaÃŸlÃ¶sung: LÃ¶sung bekannter Konzentration (c bekannt).",
    "ProbelÃ¶sung: zu untersuchende LÃ¶sung (c gesucht).",
    "Ã„quivalenzpunkt: stÃ¶chiometrisch genaues MengenverhÃ¤ltnis erreicht.",
    "Umschlagpunkt/Endpunkt: der tatsÃ¤chlich beobachtete Farbumschlag des Indikators (liegt nahe am Ã„quivalenzpunkt).",
    "Titrationskurve: grafische Darstellung von pH (oder Potential) gegen zugegebenes Volumen.",
    "Standardrezept Gehaltsbestimmung: câ‚Â·Vâ‚ = câ‚‚Â·Vâ‚‚ (nach Stoffmenge n = cÂ·V)."
  ],
  formulas: [
    "n = c Â· V",
    "c(ProbelÃ¶sung) = (c(MaÃŸlÃ¶sung) Â· V(MaÃŸlÃ¶sung)) / V(ProbelÃ¶sung) (bei einfacher 1:1-StÃ¶chiometrie)",
    "fÃ¼r andere VerhÃ¤ltnisse: Î½â‚Â·câ‚Â·Vâ‚ = Î½â‚‚Â·câ‚‚Â·Vâ‚‚ (Î½ = stÃ¶chiometrischer Koeffizient)"
  ],
  visual: `
    <div style="font-size:11px;margin-bottom:4px;">Idealisierte SÃ¤ure-Base-Titrationskurve (starke SÃ¤ure mit starker Base):</div>
    <pre style="font-size:10px;line-height:1.2;">
pH
14 |                           ______
   |                        __/
   |                     __/
   |                  __/
   |               __/
   |            __/
   |         __/
   |      __/
   |   __/
   |__/
   +--------------------------------- V
          &uarr;
     Ã„quivalenzpunkt (starker Anstieg)
    </pre>
  `,
  detailBlocks: [
    {
      title: "Grundprinzip der Titration",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li>Man gibt eine <b>MaÃŸlÃ¶sung</b> definierter Konzentration tropfenweise zu einer <b>ProbelÃ¶sung</b> unbekannter Konzentration.</li>
          <li>Die reagierenden Stoffe stehen in einer <b>stÃ¶chiometrischen Reaktionsgleichung</b> (z. B. 1:1 oder 1:2).</li>
          <li>Am <b>Ã„quivalenzpunkt</b> sind die Stoffmengen im stÃ¶chiometrisch richtigen VerhÃ¤ltnis umgesetzt.</li>
          <li>Ãœber das verbrauchte Volumen der MaÃŸlÃ¶sung und ihre Konzentration kann man die Stoffmenge berechnen und daraus die Konzentration der Probe.</li>
          <li>Ein <b>Indikator</b> (oder pH-Meter/LeitfÃ¤higkeit) zeigt an, wann der Endpunkt (nahe beim Ã„quivalenzpunkt) erreicht ist.</li>
        </ul>
      `
    },
    {
      title: "SÃ¤ure-Base-Titrationen (stark/stark)",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>Beispiel:</b> HCl (starke SÃ¤ure) mit NaOH (starke Base).</li>
          <li>Reaktionsgleichung: HCl + NaOH â†’ NaCl + Hâ‚‚O (1:1-VerhÃ¤ltnis).</li>
          <li><b>Vor dem Ã„P:</b> LÃ¶sung ist sauer, pH wird durch Ãœberschuss an HCl bestimmt.</li>
          <li><b>Am Ã„P:</b> StÃ¶chiometrisch gleiche Stoffmenge HCl und NaOH umgesetzt, pH â‰ˆ 7 (bei starken SÃ¤uren/Basen in Wasser).</li>
          <li><b>Nach dem Ã„P:</b> LÃ¶sung ist basisch, pH wird durch Ãœberschuss an NaOH bestimmt.</li>
        </ul>
        <div style="font-size:11px;margin-top:6px;">
          <b>Gehaltsberechnung (1:1):</b> c(HCl) = c(NaOH) Â· V(NaOH) / V(HCl) 
        </div>
      `
    },
    {
      title: "Titrationen mit anderen StÃ¶chiometrien",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li>Reaktionsgleichung muss immer <b>zuerst</b> aufgestellt und ausgeglichen werden.</li>
          <li>Beispiel: 2 HCl + Naâ‚‚COâ‚ƒ â†’ 2 NaCl + Hâ‚‚O + COâ‚‚ â†’ VerhÃ¤ltnis 2:1.</li>
          <li>Dann gilt: 2 Â· n(Naâ‚‚COâ‚ƒ) = n(HCl) oder allgemein: Î½â‚Â·nâ‚ = Î½â‚‚Â·nâ‚‚.</li>
          <li>Ãœbertragen auf Konzentration und Volumen: Î½â‚Â·câ‚Â·Vâ‚ = Î½â‚‚Â·câ‚‚Â·Vâ‚‚.</li>
          <li>Das ist die <b>allgemeine Gehaltsgleichung</b> fÃ¼r Titrationen.</li>
        </ul>
      `
    },
    {
      title: "Beispielaufgabe (Gehaltsbestimmung)",
      content: `
        <div style="font-size:12px;margin-bottom:4px;">
          <b>Aufgabe:</b> 25,0 mL SalzsÃ¤ure werden mit 0,100 mol/L NaOH titriert. Der Ã„quivalenzpunkt liegt bei 18,6 mL NaOH. Berechne c(HCl).
        </div>
        <ol style="padding-left:18px;margin:0;">
          <li>Reaktionsgleichung: HCl + NaOH â†’ NaCl + Hâ‚‚O (1:1).</li>
          <li>Formel: c(HCl) Â· V(HCl) = c(NaOH) Â· V(NaOH).</li>
          <li>Einsetzen: c(HCl) Â· 25,0 mL = 0,100 mol/L Â· 18,6 mL.</li>
          <li>Volumina in L umrechnen oder kÃ¼rzen, da beide in mL: c(HCl) = 0,100 Â· 18,6 / 25,0 mol/L.</li>
          <li>c(HCl) â‰ˆ 0,0744 mol/L.</li>
        </ol>
        <div style="font-size:11px;margin-top:6px;">
          <b>Antwort:</b> Die SalzsÃ¤ure hat eine Konzentration von ca. 0,074 mol/L.
        </div>
      `
    },
    {
      title: "Andere Titrationsarten (Ãœberblick)",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>FÃ¤llungstitration:</b> Bildung eines schwerlÃ¶slichen Niederschlags (z. B. Agâº + Clâ» â†’ AgClâ†“) â€“ Ã„P Ã¼ber LeitfÃ¤higkeit oder Indikator.</li>
          <li><b>Komplexometrische Titration:</b> Bildung von Komplexen (z. B. EDTA-Titration von CaÂ²âº/MgÂ²âº) â€“ Indikatoren sind oft Metallindikatoren.</li>
          <li><b>Redoxtitration:</b> Redoxreaktion zwischen MaÃŸ- und ProbelÃ¶sung (z. B. Permanganattitration) â€“ Ã„P Ã¼ber Potentialsprung oder EigenfÃ¤rbung.</li>
        </ul>
      `
    },
    {
      title: "Typische Klausurfallen & MerksÃ¤tze",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>Falle 1:</b> StoÃŸzahlen ignorieren â†’ immer zuerst Reaktionsgleichung sauber ausgleichen.</li>
          <li><b>Falle 2:</b> Volumen in mL einsetzen, obwohl in der Formel L gebraucht werden â†’ Einheit checken!</li>
          <li><b>Falle 3:</b> Ã„quivalenzpunkt und Umschlagpunkt verwechseln.</li>
          <li><b>Falle 4:</b> câ‚Â·Vâ‚ = câ‚‚Â·Vâ‚‚ anwenden, obwohl VerhÃ¤ltnis â‰  1:1 â†’ dann braucht man Î½â‚Â·câ‚Â·Vâ‚ = Î½â‚‚Â·câ‚‚Â·Vâ‚‚.</li>
          <li><b>Merksatz:</b> <i>â€Erst Reaktionsgleichung, dann rechnen.â€œ</i></li>
        </ul>
      `
    }
  ]
},

{
 id: "redox",
 title: "Redoxreaktionen & elektrochemische Spannungsreihe",
 tags: ["Oxidation", "Reduktion", "Redox", "Elektrochemie"],
 goals: [
   "Oxidation und Reduktion sicher definieren (Elektronenabgabe/-aufnahme).",
   "Oxidationszahlen zuweisen und einfache Redoxgleichungen interpretieren kÃ¶nnen.",
   "Die elektrochemische Spannungsreihe zur Vorhersage der Reaktionsrichtung nutzen.",
   "Grundidee von galvanischer Zelle, Standardpotential und Nernst-Gleichung verstehen (auf Klausur-Niveau)."
 ],
 summary:
   "Redoxreaktionen sind Elektronentransferprozesse: Oxidation bedeutet Elektronenabgabe, Reduktion Elektronenaufnahme. Die elektrochemische Spannungsreihe ordnet Halbzellen nach ihren Standardelektrodenpotenzialen. Elemente mit sehr negativem Potential geben leicht Elektronen ab (starke Reduktionsmittel), solche mit hohem Potential wirken als Oxidationsmittel. In galvanischen Zellen wird die freie Reaktionsenergie in elektrische Energie umgewandelt.",
 keyPoints: [
   "Oxidation: Elektronenabgabe (Oxidationszahl wird grÃ¶ÃŸer).",
   "Reduktion: Elektronenaufnahme (Oxidationszahl wird kleiner).",
   "Oxidationsmittel wird selbst reduziert, Reduktionsmittel selbst oxidiert.",
   "Spannungsreihe: Metalle mit negativeren EÂ°-Werten sind stÃ¤rkere Reduktionsmittel.",
   "Zellspannung EÂ°(Zelle) = EÂ°(Kathode) âˆ’ EÂ°(Anode).",
   "Nernst-Gleichung beschreibt KonzentrationsabhÃ¤ngigkeit des Potentials."
 ],
 formulas: [
   "EÂ°(Zelle) = EÂ°(Kathode) âˆ’ EÂ°(Anode)",
   "Nernst (vereinfacht, 25 Â°C): E = EÂ° âˆ’ (0,059 V / z) Â· log(Q)"
 ],
 visual: `
   <div style="font-size:11px;margin-bottom:4px;">Beispiel: Daniell-Element (Zn/Cu-Zelle)</div>
   <pre style="font-size:10px;line-height:1.3;">
Anode (Oxidation):   Zn â†’ ZnÂ²âº + 2 eâ»     (EÂ° â‰ˆ âˆ’0,76 V)
Kathode (Reduktion): CuÂ²âº + 2 eâ» â†’ Cu     (EÂ° â‰ˆ +0,34 V)

Zellreaktion:        Zn + CuÂ²âº â†’ ZnÂ²âº + Cu

EÂ°(Zelle) = EÂ°(Kathode) âˆ’ EÂ°(Anode)
       = (+0,34 V) âˆ’ (âˆ’0,76 V)
       = +1,10 V
   </pre>
 `,
 detailBlocks: [
   {
     title: "Oxidation, Reduktion & Oxidationszahlen",
     content: `
       <ul style="padding-left:18px;margin:0;">
         <li><b>Oxidation:</b> Abgabe von Elektronen (eâ»). Oxidationszahl wird <b>hÃ¶her</b>.</li>
         <li><b>Reduktion:</b> Aufnahme von Elektronen. Oxidationszahl wird <b>niedriger</b>.</li>
         <li><b>Oxidationsmittel:</b> Stoff, der andere oxidiert (nimmt Elektronen auf) â†’ wird selbst <b>reduziert</b>.</li>
         <li><b>Reduktionsmittel:</b> Stoff, der andere reduziert (gibt Elektronen ab) â†’ wird selbst <b>oxidiert</b>.</li>
         <li>Oxidationszahlen helfen, Elektronenzahl bei Redoxreaktionen nachzuvollziehen (Klausurklassiker).</li>
       </ul>
     `
   },
   {
     title: "Elektrochemische Spannungsreihe (Prinzip)",
     content: `
       <ul style="padding-left:18px;margin:0;">
         <li>Liste von Halbzellen mit ihren <b>Standardelektrodenpotenzialen EÂ°</b> (in V gegen Standard-Wasserstoffelektrode).</li>
         <li>Je <b>negativer</b> EÂ°, desto leichter gibt die Spezies Elektronen ab â†’ gutes Reduktionsmittel.</li>
         <li>Je <b>positiver</b> EÂ°, desto leichter nimmt die Spezies Elektronen auf â†’ gutes Oxidationsmittel.</li>
         <li><b>Regel:</b> Halbzelle mit grÃ¶ÃŸerem EÂ° wirkt als <b>Kathode</b>, die mit kleinerem EÂ° als <b>Anode</b>.</li>
       </ul>
     `
   },
   {
     title: "Galvanische Zelle (am Beispiel Zn/Cu)",
     content: `
       <ol style="padding-left:18px;margin:0;">
         <li><b>Anode:</b> Zn-Elektrode in ZnÂ²âº-LÃ¶sung, hier lÃ¤uft die Oxidation: Zn â†’ ZnÂ²âº + 2 eâ».</li>
         <li><b>Kathode:</b> Cu-Elektrode in CuÂ²âº-LÃ¶sung, hier lÃ¤uft die Reduktion: CuÂ²âº + 2 eâ» â†’ Cu.</li>
         <li>Elektronen flieÃŸen Ã¼ber den Ã¤uÃŸeren Leiter von der Anode zur Kathode.</li>
         <li>Die <b>SalzbrÃ¼cke</b> sorgt fÃ¼r Ladungsausgleich (Ionentransport), damit der Strom nicht abreiÃŸt.</li>
         <li>Die gemessene Spannung entspricht E(Zelle).</li>
       </ol>
     `
   },
   {
     title: "Nernst-Gleichung (auf Klausurniveau)",
     content: `
       <div style="font-size:12px;margin-bottom:4px;">
         Die Nernst-Gleichung beschreibt, wie sich das Elektrodenpotential mit der Konzentration der beteiligten Ionen Ã¤ndert.
       </div>
       <div style="padding-left:18px;font-size:12px;">
         <b>Allgemein (25 Â°C):</b><br/>
         E = EÂ° âˆ’ (0,059 V / z) Â· log(Q)
       </div>
       <ul style="padding-left:18px;margin-top:4px;">
         <li>E: aktuelles Elektrodenpotential.</li>
         <li>EÂ°: Standardelektrodenpotential (bei 1 mol/L).</li>
         <li>z: Zahl der Ã¼bertragenen Elektronen.</li>
         <li>Q: Reaktionsquotient (VerhÃ¤ltnis Produkte/Edukte).</li>
       </ul>
       <div style="font-size:11px;margin-top:6px;">
         In vielen Klausuren reicht es zu wissen, dass hÃ¶here Produktkonzentration das Potential verschiebt
         und dass aus Konzentrationsunterschieden eine messbare Spannung entsteht.
       </div>
     `
   },
   {
     title: "Typische Klausuraufgaben & Fallen",
        content: `
          <ul style="padding-left:18px;margin:0;">
            <li>Halbreaktionen identifizieren (was wird oxidiert, was reduziert?).</li>
            <li>EÂ°(Zelle) berechnen aus Tabellenwerten â†’ Kathode minus Anode.</li>
            <li>Vorhersagen, ob eine Redoxreaktion freiwillig ablÃ¤uft (EÂ°(Zelle) > 0 â‡’ tendenziell freiwillig).</li>
            <li><b>Falle 1:</b> Anode/Kathode verwechseln (Merksatz: â€Anode = Oxidationâ€œ).</li>
            <li><b>Falle 2:</b> Falsche Vorzeichen bei Potentialen (EÂ° nicht einfach addieren, sondern Kathode âˆ’ Anode).</li>
            <li><b>Falle 3:</b> z in der Nernst-Gleichung vergessen.</li>
          </ul>
        `
      }
    ]            // schlieÃŸt detailBlocks
  },              // schlieÃŸt Topic "redox"


{
  id: "orbital-grundlagen",
  title: "Was ist ein Orbital?",
  tags: ["Orbitale", "Grundlagen", "Quantenzahlen"],
  goals: [
    "Verstehen, was mit 'Orbital' in der Chemie gemeint ist.",
    "Den Unterschied zwischen Bohr-Modell (Bahnen) und Orbitalmodell (Wolken) erklÃ¤ren kÃ¶nnen.",
    "Die Rolle der wichtigsten Quantenzahlen (n, l, m_l, m_s) grob einordnen.",
    "Begreifen, warum Orbitale fÃ¼r Bindungen und Elektronenkonfigurationen so wichtig sind."
  ],
  summary:
    "Ein Orbital ist kein feste Kreisbahn wie im Bohr-Modell, sondern ein quantenmechanisch beschriebener Raumbereich um den Atomkern, in dem sich ein Elektron mit hoher Wahrscheinlichkeit aufhÃ¤lt. Jedes Orbital gehÃ¶rt zu einem bestimmten Energieniveau und hat eine typische rÃ¤umliche Form. Es kann maximal zwei Elektronen mit entgegengesetztem Spin aufnehmen. Orbitale sind die Grundlage dafÃ¼r, wie Elektronen in Atomen verteilt sind und wie chemische Bindungen entstehen.",

  keyPoints: [
    "Ein Orbital beschreibt einen Aufenthaltswahrscheinlichkeitsbereich eines Elektrons mit bestimmter Energie.",
    "Im Bohr-Modell kreisen Elektronen auf festen Bahnen; im Orbitalmodell denkt man in Elektronenwolken mit Wahrscheinlichkeiten.",
    "Jedes Orbital wird durch Quantenzahlen beschrieben: n (Hauptquantenzahl), l (Form), m_l (Orientierung) und m_s (Spin).",
    "In jedes Orbital passen maximal zwei Elektronen mit entgegengesetztem Spin (Pauli-Prinzip).",
    "Orbitale sind die Basis fÃ¼r Elektronenkonfigurationen, Periodensystem-Aufbau und chemische Bindungen."
  ],

  formulas: [
    "Hauptquantenzahl n = 1, 2, 3, ... (Schale / grobe Energie)",
    "Nebenquantenzahl l = 0 (s), 1 (p), 2 (d), 3 (f) (Form des Orbitals)",
    "m_l = -l, ..., 0, ..., +l (Orientierung im Raum)",
    "m_s = +1/2 oder -1/2 (Spin des Elektrons)"
  ],

  visual: `
    <div class="learn-visual">
      <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
        Bohr-Modell (links, Bahnen) vs. Orbitalmodell (rechts, Elektronenwolken).
      </div>

      <div style="display:flex; flex-wrap:wrap; gap:24px; justify-content:center; align-items:flex-start;">

        <!-- Bohr-Modell -->
        <div style="text-align:center;">
          <svg viewBox="0 0 140 140" width="130" height="130">
            <!-- Kern -->
            <circle cx="70" cy="70" r="6" fill="currentColor" />
            <!-- Bahnen -->
            <circle cx="70" cy="70" r="22" fill="none" stroke="currentColor" stroke-width="0.8" />
            <circle cx="70" cy="70" r="40" fill="none" stroke="currentColor" stroke-width="0.8" />
            <!-- Elektronen als Punkte auf Bahnen -->
            <circle cx="92" cy="70" r="2" fill="currentColor" />
            <circle cx="48" cy="70" r="2" fill="currentColor" />
            <circle cx="70" cy="30" r="2" fill="currentColor" />
            <circle cx="70" cy="110" r="2" fill="currentColor" />
          </svg>
          <div style="font-size:12px; margin-top:4px;">Bohr-Modell: Elektronen auf festen Bahnen</div>
        </div>

        <!-- Orbitalmodell -->
        <div style="text-align:center;">
          <svg viewBox="0 0 140 140" width="130" height="130">
            <!-- Kern -->
            <circle cx="70" cy="70" r="5" fill="currentColor" />
            <!-- â€Wolkeâ€œ -->
            <radialGradient id="orbitalCloud" cx="50%" cy="50%" r="50%">
              <stop offset="0%" stop-opacity="0.8" />
              <stop offset="100%" stop-opacity="0" />
            </radialGradient>
            <circle cx="70" cy="70" r="40" fill="none" stroke="currentColor" stroke-width="0.8" stroke-dasharray="3 3" />
            <circle cx="70" cy="70" r="26" fill="none" stroke="currentColor" stroke-width="0.5" stroke-dasharray="2 3" />
          </svg>
          <div style="font-size:12px; margin-top:4px;">Orbitalmodell: Aufenthaltswahrscheinlichkeitswolke</div>
        </div>

      </div>

      <div style="font-size:11px; opacity:0.7; margin-top:6px;">
        Wichtig ist der Denkwechsel: weg von festen Bahnen, hin zu Wahrscheinlichkeitsverteilungen (Elektronenwolken).
      </div>
    </div>
  `,

  detailBlocks: [
    {
      title: "Vom Bohr-Modell zum Orbitalmodell",
      content:
        "Das Bohr-Modell stellt Elektronen auf festen Kreisbahnen um den Kern dar. Dieses Bild ist anschaulich, aber physikalisch nicht korrekt. In der Quantenmechanik werden Elektronen durch Wellenfunktionen beschrieben, deren Betragsquadrat eine Aufenthaltswahrscheinlichkeit ergibt. Die Bereiche mit hoher Aufenthaltswahrscheinlichkeit haben bestimmte Formen und Energieniveaus â€“ das sind die Orbitale."
    },
    {
      title: "Was ein Orbital beschreibt",
      content:
        "Ein einzelnes Orbital fasst mehrere Eigenschaften zusammen: Es gehÃ¶rt zu einer bestimmten Schale (Hauptquantenzahl n), es hat eine bestimmte Form (Nebenquantenzahl l), eine rÃ¤umliche Orientierung (m_l) und kann maximal zwei Elektronen mit entgegengesetztem Spin aufnehmen (m_s). Man kann sich ein Orbital als Elektronenwolke vorstellen, in der es wahrscheinlich ist, das Elektron anzutreffen."
    },
    {
      title: "Warum Orbitale fÃ¼r Chemie so wichtig sind",
      content:
        "Die Verteilung der Elektronen auf die verschiedenen Orbitale bestimmt, wie reaktiv ein Atom ist, welche Ladung es bevorzugt annimmt und wie es Bindungen eingeht. Valenzelektronen sitzen in den Ã¤uÃŸeren Orbitalen und sind direkt an Bindungen beteiligt. Ohne das Orbitalbild kÃ¶nnte man viele PhÃ¤nomene wie BindungsstÃ¤rke, MolekÃ¼lgeometrie oder den Aufbau des Periodensystems nur auswendig lernen, statt sie zu verstehen."
    }
  ]
},


{
  id: "orbitale",
  title: "Atomorbitale: s- und p-Orbitale",
  tags: ["Orbitale", "s-Orbital", "p-Orbitale"],
  goals: [
    "Verstehen, was ein Atomorbital ist und wie es sich vom Bohr-Modell unterscheidet.",
    "s-Orbitale und p-Orbitale korrekt skizzieren und beschriften kÃ¶nnen.",
    "Die wichtigsten Quantenzahlen (n, l, mâ‚—, mâ‚›) im Zusammenhang mit s- und p-Orbitalen einordnen.",
    "Wissen, ab welcher Schale p-Orbitale auftreten und wie viele es pro Schale gibt."
  ],
  summary:
    "Orbitale beschreiben Aufenthaltswahrscheinlichkeiten von Elektronen im Atom. s-Orbitale sind kugelfÃ¶rmig und besitzen Rotationssymmetrie, p-Orbitale sind hantelfÃ¶rmig und liegen als px-, py- und pz-Orbital entlang der Raumachsen vor. Jedes Orbital kann maximal zwei Elektronen mit entgegengesetztem Spin aufnehmen. In der Klausur ist wichtig, die Formen von s- und p-Orbitalen sauber skizzieren und richtig beschriften zu kÃ¶nnen.",

  keyPoints: [
    "Ein Orbital ist ein rÃ¤umlicher Aufenthaltsbereich eines Elektrons mit bestimmter Energie (kein Planetenbahn-Modell).",
    "Die Form der Orbitale wird Ã¼ber die Nebenquantenzahl l festgelegt: l = 0 â†’ s (kugelfÃ¶rmig), l = 1 â†’ p (hantelfÃ¶rmig).",
    "s-Orbitale: kugelfÃ¶rmig, pro Schale gibt es genau ein s-Orbital (1s, 2s, 3s, ...).",
    "p-Orbitale: hantelfÃ¶rmig mit zwei Lappen; es gibt immer drei gleichwertige p-Orbitale (px, py, pz) ab n = 2.",
    "Jedes Orbital kann maximal 2 Elektronen mit entgegengesetztem Spin aufnehmen (Pauli-Prinzip).",
    "Typische Klausuraufgabe: Skizze eines s-Orbitals und eines p-Orbitals mit Achsenbeschriftung und Kernpunkt."
  ],

  formulas: [
    "Hauptquantenzahl: n = 1, 2, 3, ...",
    "Nebenquantenzahl: l = 0 (s), 1 (p), 2 (d), 3 (f)",
    "m_l = -l, ..., 0, ..., +l",
    "m_s = +1/2 oder -1/2"
  ],

  visual: `
    <div class="learn-visual">
      <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
        Vereinfachte Skizzen fÃ¼r ein s-Orbital und p-Orbitale (px, py, pz).
      </div>
      <div style="display:flex; gap:24px; flex-wrap:wrap; justify-content:center; align-items:flex-start;">

        <!-- s-Orbital -->
        <div style="text-align:center;">
          <svg viewBox="0 0 120 120" width="110" height="110">
            <circle cx="60" cy="60" r="3" fill="currentColor" />
            <circle cx="60" cy="60" r="35" fill="none" stroke="currentColor" stroke-width="1.5" />
          </svg>
          <div style="font-size:12px; margin-top:4px;">s-Orbital (kugelfÃ¶rmig)</div>
        </div>

        <!-- p<sub>x</sub>-Orbital -->
        <div style="text-align:center;">
          <svg viewBox="0 0 120 120" width="110" height="110">
            <line x1="10" y1="60" x2="110" y2="60" stroke="currentColor" stroke-width="0.8" />
            <text x="108" y="52" style="font-size:10px; fill:currentColor;">x</text>
            <ellipse cx="40" cy="60" rx="18" ry="35" fill="none" stroke="currentColor" stroke-width="1.5" />
            <ellipse cx="80" cy="60" rx="18" ry="35" fill="none" stroke="currentColor" stroke-width="1.5" />
            <circle cx="60" cy="60" r="3" fill="currentColor" />
          </svg>
          <div style="font-size:12px; margin-top:4px;">p<sub>x</sub>-Orbital (hantelfÃ¶rmig)</div>
        </div>

        <!-- p<sub>y</sub>-Orbital -->
        <div style="text-align:center;">
          <svg viewBox="0 0 120 120" width="110" height="110">
            <line x1="60" y1="10" x2="60" y2="110" stroke="currentColor" stroke-width="0.8" />
            <text x="66" y="16" style="font-size:10px; fill:currentColor;">y</text>
            <ellipse cx="60" cy="40" rx="18" ry="35" fill="none" stroke="currentColor" stroke-width="1.5" />
            <ellipse cx="60" cy="80" rx="18" ry="35" fill="none" stroke="currentColor" stroke-width="1.5" />
            <circle cx="60" cy="60" r="3" fill="currentColor" />
          </svg>
          <div style="font-size:12px; margin-top:4px;">p<sub>y</sub>-Orbital</div>
        </div>

        <!-- p<sub>z</sub>-Orbital (schematisch) -->
        <div style="text-align:center;">
          <svg viewBox="0 0 120 120" width="110" height="110">
            <circle cx="60" cy="60" r="3" fill="currentColor" />
            <ellipse cx="60" cy="60" rx="30" ry="12" fill="none" stroke="currentColor" stroke-width="1.5" />
            <ellipse cx="60" cy="60" rx="8" ry="28" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3 3" />
            <text x="82" y="50" style="font-size:10px; fill:currentColor;">z</text>
          </svg>
          <div style="font-size:12px; margin-top:4px;">p<sub>z</sub>-Orbital (senkrecht zur Zeichenebene)</div>
        </div>

      </div>
      <div style="font-size:11px; opacity:0.7; margin-top:6px;">
        In der Klausur reichen oft stark vereinfachte Skizzen, wichtig sind: Kugelform fÃ¼r s, zwei Lappen fÃ¼r p und korrekte Beschriftung (Achsen, Kern).
      </div>
    </div>
  `,

  detailBlocks: [
    {
      title: "Intuition: Warum sprechen wir von Orbitalen?",
      content:
        "Das Bohr-Modell beschreibt Elektronen auf festen Kreisbahnen. FÃ¼r einfache Wasserstoff-Ã¤hnliche Systeme funktioniert das nÃ¤herungsweise, ist aber physikalisch nicht korrekt. In der Quantenmechanik werden Elektronen durch Wellenfunktionen beschrieben, deren Betragsquadrat eine Aufenthaltswahrscheinlichkeit ergibt. Die daraus entstehenden 'Elektronenwolken' mit bestimmter Energie und Form nennen wir Orbitale."
    },
    {
      title: "Die Rolle der Quantenzahlen",
      content:
        "Die Hauptquantenzahl n gibt Energie und GrÃ¶ÃŸe der Schale an. Die Nebenquantenzahl l legt die Form des Orbitals fest (s, p, d, f). Die magnetische Quantenzahl m_l beschreibt die Orientierung im Raum, bei p-Orbitalen fÃ¼hrt das zu px, py und pz. Die Spinquantenzahl m_s unterscheidet zwei Elektronen im selben Orbital. FÃ¼r Klausuraufgaben zu s- und p-Orbitalen reicht es meist, n und l richtig zuzuordnen und zu wissen, ab welcher Schale p-Orbitale auftreten."
    },
    {
      title: "Skizzen-Tipps fÃ¼r die Klausur",
      content:
        "s-Orbitale als Kugel: einen Kreis um den Kern zeichnen, Beschriftung z. B. '2s'. p-Orbitale als Hanteln: zwei Lappen, Kernpunkt in der Mitte, dazu eine Achse und Beschriftung (px, py). Es ist besser, eine einfache, saubere Skizze mit klarer Beschriftung zu haben, als ein Ã¼berladenes Bild mit vielen Details. Achte darauf, dass bei einem p-Orbital immer beide Lappen eingezeichnet sind."
    }

  ]
},


    {
      id: "mo-schema-elektronenkonfig",
      title: "MO-Schema & Elektronenkonfiguration",
      tags: ["MO-Schema", "MolekÃ¼lorbitale", "Elektronenkonfiguration"],
      goals: [
        "Elektronenkonfiguration von Atomen nach dem Aufbauprinzip, Pauli-Prinzip und Hundscher Regel aufschreiben kÃ¶nnen.",
        "Einfache MO-Schemata zeichnen und bindende sowie antibindende MolekÃ¼lorbitale unterscheiden kÃ¶nnen.",
        "Die Bindungsordnung aus einem MO-Schema berechnen und interpretieren kÃ¶nnen.",
        "Aus dem MO-Schema ableiten kÃ¶nnen, ob ein MolekÃ¼l paramagnetisch oder diamagnetisch ist."
      ],
      summary:
        "Die Elektronenkonfiguration beschreibt die Verteilung der Elektronen auf Atomorbitalen. In der MolekÃ¼lorbitaltheorie Ã¼berlappen Atomorbitale zu MolekÃ¼lorbitalen, die als bindende oder antibindende Orbitale auftreten. Durch Eintragen der Elektronen in ein MO-Schema lassen sich Bindungsordnung, StabilitÃ¤t und Magnetismus eines MolekÃ¼ls bestimmen.",

      keyPoints: [
        "Elektronenkonfiguration wird nach dem Aufbauprinzip von energetisch niedrigen zu hÃ¶heren Orbitalen aufgebaut (z. B. 1s, 2s, 2p, 3s, 3p, 4s, 3d...).",
        "Pauli-Prinzip: Maximal 2 Elektronen mit entgegengesetztem Spin pro Orbital.",
        "Hundsche Regel: Entartete Orbitale (z. B. die 3 p-Orbitale) werden zunÃ¤chst einzeln mit parallelem Spin besetzt, bevor Elektronen gepaart werden.",
        "Aus zwei Atomorbitalen entstehen immer zwei MolekÃ¼lorbitale: ein bindendes (energetisch tiefer) und ein antibindendes (energetisch hÃ¶her, mit * gekennzeichnet).",
        "Bindungsordnung BO = (n_bindend âˆ’ n_antibindend) / 2. BO = 0 bedeutet keine stabile Bindung.",
        "Paramagnetische MolekÃ¼le besitzen ungepaarte Elektronen im MO-Schema, diamagnetische nur gepaarte Elektronen."
      ],

      formulas: [
        "Beispiel: O (Z = 8): 1sÂ² 2sÂ² 2pâ´",
        "Bindungsordnung: BO = (n_bindend âˆ’ n_antibindend) / 2"
      ],

           visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            MO-Schemata wie in der Klausur: Energieniveauschemata (1a/1b) und fertiges Fâ‚‚-MolekÃ¼l mit eingetragenen Elektronen.
          </div>

          <div style="display:flex; flex-wrap:wrap; gap:24px; justify-content:center;">
            <div style="text-align:center;">
              <img src="Images/mo-1a-1b.png" style="max-width:260px; height:auto; border-radius:6px;">
              <div style="font-size:12px; margin-top:4px;">
                Vergleich der beiden Schemen:<br>
                <b>Abbildung 1a</b> (links): Oâ‚‚, Fâ‚‚, Neâ‚‚<br>
                <b>Abbildung 1b</b> (rechts): Bâ‚‚, Câ‚‚, Nâ‚‚
              </div>
            </div>

            <div style="text-align:center;">
              <img src="Images/mo-f2-full.png" style="max-width:260px; height:auto; border-radius:6px;">
              <div style="font-size:12px; margin-top:4px;">
                Fertiges MO-Schema fÃ¼r <b>Fâ‚‚</b> wie in der MusterlÃ¶sung (alle 14 Valenzelektronen eingetragen).
              </div>
            </div>
          </div>

          <div style="font-size:11px; opacity:0.7; margin-top:6px;">
            Tipp: Du kannst hier spÃ¤ter eigene Skizzen fÃ¼r Oâ‚‚, Câ‚‚ usw. einfÃ¼gen, damit es genau zu deinen Klausuraufgaben passt.
          </div>
        </div>
      `,


      detailBlocks: [
        {
          title: "Elektronenkonfiguration kurz & klausurrelevant",
          content:
            "Die Elektronenkonfiguration beschreibt, wie die Elektronen eines Atoms auf Orbitale verteilt sind. Sie wird nach dem Aufbauprinzip von niedriger zu hÃ¶herer Energie aufgebaut. Das Pauli-Prinzip begrenzt die Besetzung jedes Orbitals auf zwei Elektronen mit entgegengesetztem Spin, die Hundsche Regel sorgt zuerst fÃ¼r mÃ¶glichst viele ungepaarte Elektronen in entarteten Orbitalen. FÃ¼r die Klausur solltest du Elektronenkonfigurationen sicher schreiben und einfache KÃ¤stchenschemata zeichnen kÃ¶nnen."
        },
        {
          title: "Idee der MolekÃ¼lorbitale",
          content:
            "Wenn sich zwei Atome zu einem MolekÃ¼l verbinden, Ã¼berlappen ihre Atomorbitale und bilden MolekÃ¼lorbitale. Aus zwei Atomorbitale entstehen ein bindendes und ein antibindendes MO. Elektronen im bindenden MO stabilisieren das MolekÃ¼l, Elektronen im antibindenden MO schwÃ¤chen die Bindung. Das Energieniveau der bindenden MOs liegt unterhalb, das der antibindenden oberhalb der ursprÃ¼nglichen Atomorbitale. Im MO-Schema werden die Elektronen wieder von unten nach oben in die MOs eingetragen."
        },
        {
          title: "Bindungsordnung & Magnetismus verstehen",
          content:
            "Die Bindungsordnung BO = (n_bindend âˆ’ n_antibindend) / 2 gibt an, wie stark die Bindung zwischen zwei Atomen ist. Eine hÃ¶here Bindungsordnung bedeutet in der Regel stÃ¤rkere und kÃ¼rzere Bindungen. ZusÃ¤tzlich zeigt dir das MO-Schema, ob ein MolekÃ¼l paramagnetisch (ungepaarte Elektronen) oder diamagnetisch (alle Elektronen gepaart) ist. In vielen Klausuraufgaben reicht es, ein vereinfachtes MO-Schema zu zeichnen, die Elektronen zu verteilen und dann die Bindungsordnung zu berechnen."
        },
        {
          title: "Typische Klausuraufgaben & wie du sie beantwortest",
          content: `
            <div style="padding-left:18px; font-size:13px; line-height:1.5;">
              <ol style="margin-top:0;">
                <li style="margin-bottom:10px;">
                  <b>Elektronenkonfiguration angeben</b><br>
                  <b>Schritt 1:</b> Ordnungszahl Z im Periodensystem ablesen (Anzahl der Elektronen im neutralen Atom).<br>
                  <b>Schritt 2:</b> Orbitale in der richtigen Reihenfolge auffÃ¼llen (1s, 2s, 2p, 3s, 3p, 4s, 3d, ...), max. 2 Elektronen pro Orbital.<br>
                  <b>Schritt 3:</b> Elektronenkonfiguration in der Form 1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>4</sup> aufschreiben.<br>
                  <i>Beispiel:</i> O (Z = 8) â†’ 1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>4</sup>.
                </li>

                <li style="margin-bottom:10px;">
                  <b>MO-Schema zeichnen & Bindungsordnung bestimmen</b><br>
                  <b>Schritt 1:</b> Gesamtzahl der Elektronen im MolekÃ¼l bestimmen (z. B. Hâ‚‚ â†’ 2 eâ», Heâ‚‚ â†’ 4 eâ»).<br>
                  <b>Schritt 2:</b> Vereinfachtes MO-Schema zeichnen: bindendes Ïƒ(1s) unten, antibindendes Ïƒ*(1s) oben.<br>
                  <b>Schritt 3:</b> Elektronen von unten nach oben in die MOs eintragen, max. 2 eâ» pro MO.<br>
                  <b>Schritt 4:</b> Bindungsordnung berechnen: BO = (n<sub>bindend</sub> âˆ’ n<sub>antibindend</sub>) / 2.<br>
                  <i>Beispiel Hâ‚‚:</i> 2 eâ» in Ïƒ(1s), 0 eâ» in Ïƒ*(1s) â†’ BO = (2 âˆ’ 0) / 2 = 1 (stabile Einfachbindung).<br>
                  <i>Beispiel Heâ‚‚:</i> 2 eâ» in Ïƒ(1s), 2 eâ» in Ïƒ*(1s) â†’ BO = (2 âˆ’ 2) / 2 = 0 (keine stabile Bindung).
                </li>

                <li style="margin-bottom:10px;">
                  <b>Paramagnetisch oder diamagnetisch?</b><br>
                  <b>Schritt 1:</b> Im MO-Schema nach ungepaarten Elektronen suchen.<br>
                  <b>Schritt 2:</b> Mindestens ein ungepaartes Elektron â†’ MolekÃ¼l ist <b>paramagnetisch</b>.<br>
                  <b>Schritt 3:</b> Alle Elektronen gepaart (â†‘â†“) â†’ MolekÃ¼l ist <b>diamagnetisch</b>.
                </li>

                <li style="margin-bottom:10px;">
                  <b>BindungsstÃ¤rke & BindungslÃ¤nge vergleichen</b><br>
                  <b>Schritt 1:</b> FÃ¼r jedes MolekÃ¼l die Bindungsordnung bestimmen.<br>
                  <b>Schritt 2:</b> Merksatz: HÃ¶here BO â†’ stÃ¤rkere & kÃ¼rzere Bindung; niedrigere BO â†’ schwÃ¤chere & lÃ¤ngere Bindung.<br>
                  <i>Beispiel:</i> BO(A) = 2, BO(B) = 1 â†’ Bindung in A ist stÃ¤rker und kÃ¼rzer als in B.
                </li>
              </ol>
            </div>
          `
        }
      ]
    },

    {
      id: "strahlung-energie",
      title: "Strahlung & Energieeinheiten (Joule & eV)",
      tags: ["Strahlung", "Photonenenergie", "eV", "Joule"],
      goals: [
        "Verstehen, was ein Photon ist und wie elektromagnetische Strahlung beschrieben wird.",
        "Die ZusammenhÃ¤nge zwischen WellenlÃ¤nge Î», Frequenz Î½ und Lichtgeschwindigkeit c anwenden.",
        "Die Energie eines Photons mit E = hÂ·Î½ bzw. E = hÂ·c/Î» berechnen kÃ¶nnen.",
        "Das Elektronenvolt (eV) definieren und sicher zwischen Joule und eV umrechnen.",
        "Typische Klausuraufgaben zu Photonenergie, eVâ€“Joule-Umrechnung, Spannung und Photonenzahl systematisch lÃ¶sen kÃ¶nnen."
      ],
      summary: `
        Elektromagnetische Strahlung (Licht, UV, RÃ¶ntgenstrahlung ...) kann sowohl als Welle (mit WellenlÃ¤nge Î» und Frequenz Î½) als auch als Teilchenstrom aus Photonen beschrieben werden.
        Jedes Photon trÃ¤gt eine bestimmte Energie, die nur von der WellenlÃ¤nge bzw. Frequenz der Strahlung abhÃ¤ngt. Ãœber die Formeln E = hÂ·Î½ und E = hÂ·c/Î» lassen sich aus Î» oder Î½ die
        Energie einzelner Photonen berechnen. In der Atomphysik ist neben der SI-Einheit Joule besonders das Elektronenvolt (eV) wichtig: 1 eV ist die Energie, die ein Elektron beim Durchlaufen
        einer Spannung von 1 V gewinnt. FÃ¼r die Klausur ist vor allem wichtig, WellenlÃ¤ngen korrekt in Meter umzurechnen, mit den Naturkonstanten h und c sauber zu rechnen und sicher zwischen
        Joule und eV hin- und herzuwandeln.
      `,
      keyPoints: [
        "Elektromagnetische Strahlung kann als Welle (Î», Î½) und als Strom von Photonen betrachtet werden (Welle-Teilchen-Dualismus).",
        "Frequenz und WellenlÃ¤nge hÃ¤ngen zusammen Ã¼ber: Î½ = c / Î» (c â‰ˆ 3,00 Â· 10^8 m/s).",
        "Photonenenergie: E = hÂ·Î½ = hÂ·c/Î» (h â‰ˆ 6,626 Â· 10^-34 JÂ·s). Je kleiner Î», desto grÃ¶ÃŸer E.",
        "Elektronenvolt: 1 eV ist die Energie, die ein Elektron beim Durchlaufen von 1 V gewinnt â†’ 1 eV = 1,602 Â· 10^-19 J.",
        "Umrechnung: Joule â†’ eV: E_eV = E_J / (1,602 Â· 10^-19); eV â†’ Joule: E_J = E_eV Â· 1,602 Â· 10^-19.",
        "Elektron an Spannung U: Energie = U eV (fÃ¼r ein Elektron) bzw. U Â· e Joule.",
        "Typische Klausuraufgaben: Photonenergie aus Î», WellenlÃ¤nge aus gegebener Energie, Energie eines Elektrons im elektrischen Feld, Anzahl Photonen aus einer Gesamtenergie."
      ],
      formulas: [
        "Î½ = c / Î»",
        "E = h Â· Î½",
        "E = h Â· c / Î»",
        "1 eV = 1,602 Â· 10^-19 J",
        "E_eV = E_J / (1,602 Â· 10^-19)",
        "E_J = E_eV Â· 1,602 Â· 10^-19",
        "E(Elektron) = e Â· U â‰™ U eV"
      ],
      visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            Ãœbersicht Ã¼ber die wichtigsten GrÃ¶ÃŸen der Photonenergie:
          </div>
          <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
WellenlÃ¤nge:        Î»  [m]        (z. B. 500 nm = 500 Â· 10^-9 m)
Frequenz:          Î½  [Hz]       (Î½ = c / Î»)
Lichtgeschwindigkeit: c â‰ˆ 3,00 Â· 10^8 m/s
Planck-Konstante:  h â‰ˆ 6,626 Â· 10^-34 JÂ·s

Photonenergie:     E = hÂ·Î½ = hÂ·c/Î»

Elektronenvolt:    1 eV = 1,602 Â· 10^-19 J
Umrechnung:
  eV â†’ Joule:      E_J = E_eV Â· 1,602 Â· 10^-19
  Joule â†’ eV:      E_eV = E_J / (1,602 Â· 10^-19)

Elektron an U Volt:
  E = U eV  (fÃ¼r ein Elektron)
          </pre>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">
            Merkhilfe: <b>kleine WellenlÃ¤nge â†’ groÃŸe Frequenz â†’ groÃŸe Photonenergie.</b>
          </div>
        </div>
      `,
      detailBlocks: [
        {
          title: "Elektromagnetische Strahlung & Photon-Begriff",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Elektromagnetische Strahlung (z. B. Radiowellen, sichtbares Licht, UV, RÃ¶ntgenstrahlung) kann auf zwei Arten beschrieben werden:</p>
              <ul>
                <li>Als <b>Welle</b>: charakterisiert durch die <b>WellenlÃ¤nge</b> Î» (in m) und die <b>Frequenz</b> Î½ (in Hz).</li>
                <li>Als <b>Teilchenstrom</b> aus <b>Photonen</b>: jedes Photon trÃ¤gt ein bestimmtes Energiepaket.</li>
              </ul>
              <p>WellenlÃ¤nge und Frequenz stehen Ã¼ber die Lichtgeschwindigkeit c in Beziehung:</p>
              <p style="text-align:center; margin:6px 0;"><b>Î½ = c / Î»</b></p>
              <p>FÃ¼r sichtbares Licht liegen die WellenlÃ¤ngen grob im Bereich von 400 nm (violett) bis 700 nm (rot). KÃ¼rzere WellenlÃ¤ngen (UV, RÃ¶ntgen) bedeuten hÃ¶herenergetische Photonen.</p>
            </div>
          `
        },
        {
          title: "Wichtige GrÃ¶ÃŸen & Naturkonstanten",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>FÃ¼r Berechnungen rund um Photonenergie und eV brauchst du nur wenige Konstanten:</p>
              <ul>
                <li><b>Lichtgeschwindigkeit</b>: c â‰ˆ 3,00 Â· 10<sup>8</sup> m/s.</li>
                <li><b>Planck-Konstante</b>: h â‰ˆ 6,626 Â· 10<sup>-34</sup> JÂ·s.</li>
                <li><b>Elementarladung</b> (Ladung eines Elektrons): e = 1,602 Â· 10<sup>-19</sup> C.</li>
              </ul>
              <p>Einheiten & Umrechnungen, die du dir merken solltest:</p>
              <ul>
                <li>1 nm = 10<sup>-9</sup> m â†’ Beispiel: 500 nm = 500 Â· 10<sup>-9</sup> m = 5,00 Â· 10<sup>-7</sup> m.</li>
                <li>Frequenz in Hz bedeutet â€Schwingungen pro Sekundeâ€œ, 1 Hz = 1/s.</li>
                <li>Joule (J) ist die SI-Einheit der Energie, eV ist eine praktische â€Atomphysik-Einheitâ€œ.</li>
              </ul>
            </div>
          `
        },
        {
          title: "Photonenergie: E = hÂ·Î½ = hÂ·c/Î»",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die Energie eines einzelnen Photons ist direkt proportional zur Frequenz und umgekehrt proportional zur WellenlÃ¤nge:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>E = h Â· Î½ = h Â· c / Î»</b>
              </p>
              <ul>
                <li><b>E</b> in Joule (J)</li>
                <li><b>h</b> Planck-Konstante (JÂ·s)</li>
                <li><b>Î½</b> Frequenz (Hz)</li>
                <li><b>Î»</b> WellenlÃ¤nge (m)</li>
                <li><b>c</b> Lichtgeschwindigkeit (m/s)</li>
              </ul>
              <p>Ablaufschema fÃ¼r Aufgaben mit gegebener WellenlÃ¤nge Î»:</p>
              <ol>
                <li>Î» in Meter umrechnen (nm â†’ m).</li>
                <li>Mit <b>E = hÂ·c/Î»</b> die Photonenenergie in Joule berechnen.</li>
                <li>Falls gefragt: Joule â†’ eV umrechnen.</li>
              </ol>
              <p>Typische GrÃ¶ÃŸenordnung: sichtbares Licht hat Photonenenergien von ca. 2 bis 3 eV (~10<sup>-19</sup> J).</p>
            </div>
          `
        },
        {
          title: "Elektronenvolt (eV) & Umrechnung zu Joule",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>Definition:</b> 1 Elektronenvolt (1 eV) ist die Energie, die ein Elektron gewinnt, wenn es eine Spannung von 1 Volt durchlÃ¤uft.</p>
              <p>Mathematisch: E = e Â· U, also fÃ¼r U = 1 V:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>1 eV = 1,602 Â· 10<sup>-19</sup> J</b>
              </p>
              <p>Damit erhÃ¤ltst du die Umrechnungsformeln:</p>
              <ul>
                <li><b>eV â†’ Joule</b>: E<sub>J</sub> = E<sub>eV</sub> Â· 1,602 Â· 10<sup>-19</sup> J/eV</li>
                <li><b>Joule â†’ eV</b>: E<sub>eV</sub> = E<sub>J</sub> / (1,602 Â· 10<sup>-19</sup> J/eV)</li>
              </ul>
              <p>Beispiele:</p>
              <ul>
                <li>2,0 eV â†’ E = 2,0 Â· 1,602 Â· 10<sup>-19</sup> J â‰ˆ 3,20 Â· 10<sup>-19</sup> J.</li>
                <li>4,0 Â· 10<sup>-19</sup> J â†’ E = (4,0 Â· 10<sup>-19</sup> J) / (1,602 Â· 10<sup>-19</sup> J/eV) â‰ˆ 2,5 eV.</li>
              </ul>
              <p>Merke: eV ist fÃ¼r atomare Energien sehr handlich, Joule ist die offizielle SI-Einheit â€“ die Klausur will oft beides.</p>
            </div>
          `
        },
        {
          title: "Elektron im elektrischen Feld: Energie aus Spannung",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>FÃ¼r ein Elektron, das eine Spannung U durchlÃ¤uft, gilt:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>E = e Â· U</b>
              </p>
              <p>Da 1 eV = e Â· 1 V, folgt fÃ¼r ein Elektron ganz einfach:</p>
              <ul>
                <li>Bei 1 V â†’ 1 eV</li>
                <li>Bei 10 V â†’ 10 eV</li>
                <li>Bei 120 V â†’ 120 eV</li>
              </ul>
              <p>In Joule gerechnet:</p>
              <p>E<sub>J</sub> = U Â· 1,602 Â· 10<sup>-19</sup> J</p>
              <p><b>Beispiel:</b> U = 120 V</p>
              <ul>
                <li>E = 120 eV</li>
                <li>E<sub>J</sub> = 120 Â· 1,602 Â· 10<sup>-19</sup> â‰ˆ 1,92 Â· 10<sup>-17</sup> J</li>
              </ul>
            </div>
          `
        },
        {
          title: "Typische Klausurwege â€“ Rezepte",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>1) Photonenergie aus gegebener WellenlÃ¤nge Î»</b></p>
              <ol>
                <li>Î» in Meter umrechnen (nm â†’ m).</li>
                <li>Mit E = h Â· c / Î» die Energie in Joule berechnen.</li>
                <li>Wenn eV verlangt sind: E<sub>eV</sub> = E<sub>J</sub> / (1,602 Â· 10<sup>-19</sup>).</li>
              </ol>

              <p><b>2) WellenlÃ¤nge aus gegebener Energie in eV</b></p>
              <ol>
                <li>E in Joule umrechnen: E<sub>J</sub> = E<sub>eV</sub> Â· 1,602 Â· 10<sup>-19</sup>.</li>
                <li>Aus E = hÂ·c/Î» nach Î» umstellen: Î» = hÂ·c / E.</li>
                <li>Ergebnis in nm angeben (m â†’ nm).</li>
              </ol>

              <p><b>3) Elektron an Spannung U</b></p>
              <ol>
                <li>Energie in eV: E = U eV.</li>
                <li>Falls Joule gefragt sind: E<sub>J</sub> = U Â· 1,602 Â· 10<sup>-19</sup> J.</li>
              </ol>

              <p><b>4) Anzahl Photonen bei gegebener Gesamtenergie</b></p>
              <ol>
                <li>Zuerst Energie eines Photons aus der WellenlÃ¤nge bestimmen (E<sub>Photon</sub> = hÂ·c/Î»).</li>
                <li>Dann: Anzahl N = E<sub>gesamt</sub> / E<sub>Photon</sub>.</li>
              </ol>
              <p>Wenn du diese vier â€Rezepteâ€œ beherrschst, kannst du praktisch jede Standardaufgabe aus diesem Themenblock bearbeiten.</p>
            </div>
          `
        },
        {
          title: "Klausurbeispiele Schritt fÃ¼r Schritt",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>Beispiel 1: Photonenergie fÃ¼r Î» = 550 nm (sichtbares Licht)</b></p>
              <p>Gegeben: Î» = 550 nm.</p>
              <ol>
                <li>Umrechnung: 550 nm = 550 Â· 10<sup>-9</sup> m = 5,50 Â· 10<sup>-7</sup> m.</li>
                <li>Photonenergie: E â‰ˆ hÂ·c/Î» â‰ˆ 3,6 Â· 10<sup>-19</sup> J.</li>
                <li>In eV: E â‰ˆ (3,6 Â· 10<sup>-19</sup> J) / (1,602 Â· 10<sup>-19</sup> J/eV) â‰ˆ 2,3 eV.</li>
              </ol>

              <p><b>Beispiel 2: UV-Photon mit Î» = 250 nm</b></p>
              <ol>
                <li>250 nm = 2,50 Â· 10<sup>-7</sup> m.</li>
                <li>E â‰ˆ hÂ·c/Î» â‰ˆ 8,0 Â· 10<sup>-19</sup> J.</li>
                <li>E in eV: â‰ˆ 5,0 eV â†’ deutlich energiereicher als sichtbares Licht.</li>
              </ol>

              <p><b>Beispiel 3: Energie gegeben (3,0 eV) â€“ WellenlÃ¤nge gesucht</b></p>
              <ol>
                <li>E in Joule: E<sub>J</sub> = 3,0 eV Â· 1,602 Â· 10<sup>-19</sup> â‰ˆ 4,81 Â· 10<sup>-19</sup> J.</li>
                <li>Î» = hÂ·c/E â‰ˆ (6,626 Â· 10<sup>-34</sup> Â· 3,00 Â· 10<sup>8</sup>) / (4,81 Â· 10<sup>-19</sup>) â‰ˆ 4,1 Â· 10<sup>-7</sup> m.</li>
                <li>In nm: Î» â‰ˆ 410 nm (violett/blau-violett).</li>
              </ol>

              <p><b>Beispiel 4: Elektron an U = 120 V</b></p>
              <ol>
                <li>Energie in eV: E = 120 eV.</li>
                <li>In Joule: E<sub>J</sub> = 120 Â· 1,602 Â· 10<sup>-19</sup> â‰ˆ 1,92 Â· 10<sup>-17</sup> J.</li>
              </ol>

              <p><b>Beispiel 5: Anzahl Photonen in einem Laserpuls</b></p>
              <p>Gegeben: Î» = 500 nm, Gesamtenergie E<sub>gesamt</sub> = 1,0 Â· 10<sup>-3</sup> J.</p>
              <ol>
                <li>Photonenergie bei 500 nm: E<sub>Photon</sub> â‰ˆ 4,0 Â· 10<sup>-19</sup> J.</li>
                <li>Anzahl N = E<sub>gesamt</sub> / E<sub>Photon</sub> â‰ˆ (1,0 Â· 10<sup>-3</sup>) / (4,0 Â· 10<sup>-19</sup>) â‰ˆ 2,5 Â· 10<sup>15</sup> Photonen.</li>
              </ol>
              <p style="margin-top:6px;">
                Du musst die Rechenwege nicht auswendig lernen â€“ wichtig ist, dass du die GrÃ¶ÃŸenordnungen kennst und sauber mit Zehnerpotenzen und der Umrechnung zwischen Joule und eV umgehen kannst.
              </p>
            </div>
          `
        }
      ]
    },
    {
      id: "stoechiometrie-ph-gehalt",
      title: "StÃ¶chiometrie, pH & Gehaltsbestimmung",
      tags: ["StÃ¶chiometrie", "pH", "Titration", "Gehaltsbestimmung"],
      goals: [
        "Die grundlegenden stÃ¶chiometrischen GrÃ¶ÃŸen (n, m, M, c, V) sicher anwenden kÃ¶nnen.",
        "Reaktionsgleichungen aufstellen, ausgleichen und StoffmengenverhÃ¤ltnisse daraus ablesen kÃ¶nnen.",
        "Den pH starker SÃ¤uren und Basen (z. B. HCl, NaOH) aus Konzentrationen berechnen kÃ¶nnen.",
        "Die Logik von Titrationen und Gehaltsbestimmungen verstehen und auf Klausuraufgaben anwenden kÃ¶nnen.",
        "pH nach einer Neutralisationsreaktion mit Ãœberschuss einer Komponente berechnen kÃ¶nnen."
      ],
      summary: `
        In diesem Thema verknÃ¼pfst du drei wichtige Bausteine der Allgemeinen Chemie: StÃ¶chiometrie, pH-Berechnung und Gehaltsbestimmung.
        StÃ¶chiometrie liefert dir das Handwerkszeug, um aus Massen und Volumina Stoffmengen zu berechnen und mit Reaktionsgleichungen zu arbeiten.
        Ãœber den pH-Begriff kannst du die StÃ¤rke saurer bzw. basischer LÃ¶sungen quantitativ beschreiben â€“ zumindest fÃ¼r starke SÃ¤uren und Basen mit relativ einfachen Formeln.
        Mit der Titrations- und Gehaltsbestimmung verbindest du beides: anhand der benÃ¶tigten Menge einer MaÃŸlÃ¶sung kann der Gehalt einer unbekannten Probe berechnet werden.
        Genau dieser Themenmix ist typisch fÃ¼r Klausuraufgaben, bei denen du Schritt fÃ¼r Schritt von Reaktionsgleichung Ã¼ber Stoffmengen bis hin zu pH oder Massenanteil rechnen musst.
      `,
      keyPoints: [
        "Stoffmenge n, Masse m, molare Masse M und Konzentration c gehÃ¶ren zu den GrundgrÃ¶ÃŸen der StÃ¶chiometrie: n = m/M, n = cÂ·V.",
        "Reaktionsgleichungen mÃ¼ssen ausgeglichen werden, bevor Stoffmengen aus dem stÃ¶chiometrischen VerhÃ¤ltnis berechnet werden.",
        "pH = âˆ’log10[H+] fÃ¼r starke SÃ¤uren; pOH = âˆ’log10[OHâˆ’] fÃ¼r starke Basen und pH + pOH = 14 bei 25 Â°C.",
        "Bei starken SÃ¤uren/Basen gilt nÃ¤herungsweise: [H+] â‰ˆ c(SÃ¤ure) bzw. [OHâˆ’] â‰ˆ c(Base), solange keine anderen Effekte dominieren.",
        "Titrationen nutzen eine MaÃŸlÃ¶sung bekannter Konzentration, um eine unbekannte Stoffmenge Ã¼ber das stÃ¶chiometrische VerhÃ¤ltnis zu bestimmen.",
        "Nach einer neutralisationsreaktion mit Ãœberschuss kann der pH aus der Ã¼brig gebliebenen starken SÃ¤ure oder Base berechnet werden."
      ],
      formulas: [
        "n = m / M",
        "n = c Â· V",
        "c = n / V",
        "pH = âˆ’log10 [H+]",
        "pOH = âˆ’log10 [OHâˆ’]",
        "pH + pOH = 14 (bei 25 Â°C)",
        "HCl + NaOH â†’ NaCl + H2O",
        "H2SO4 + 2 NaOH â†’ Na2SO4 + 2 H2O"
      ],
      visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            StÃ¶chiometrie, pH und Titration auf einen Blick:
          </div>
          <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
Stoffmenge:           n [mol]     n = m / M  oder  n = c Â· V
Masse:                m [g]
Molmasse:             M [g/mol]
Konzentration:        c [mol/L]  (Mol pro Liter)
Volumen:              V [L]      (mL â†’ L: durch 1000 teilen)

pH starker SÃ¤uren:    pH = âˆ’log10[Hâº]     (z.B. HCl)
pH starker Basen:     pOH = âˆ’log10[OHâ»], pH + pOH = 14 (25 Â°C)
                       [OHâ»] â‰ˆ c(NaOH) bei starker Base

Neutralisation:
  HCl + NaOH â†’ NaCl + Hâ‚‚O           (1 : 1 VerhÃ¤ltnis)
  Hâ‚‚SOâ‚„ + 2 NaOH â†’ Naâ‚‚SOâ‚„ + 2 Hâ‚‚O   (1 : 2 VerhÃ¤ltnis)

Titration:
  n(MaÃŸlÃ¶sung) = c Â· V
  StoÃŸzahl Ã¼ber Reaktionsgleichung auf gesuchte Stoffmenge Ã¼bertragen.
          </pre>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">
            Merkhilfe: <b>Immer zuerst die Reaktionsgleichung ausgleichen, dann n berechnen, dann pH oder Masse bestimmen.</b>
          </div>
        </div>
      `,
      detailBlocks: [
        {
          title: "StÃ¶chiometrie-Grundlagen: n, m, M, c & Reaktionsgleichung",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>StÃ¶chiometrie beschreibt, wie viel von welchen Stoffen in einer Reaktion beteiligt ist. Die wichtigsten GrÃ¶ÃŸen sind:</p>
              <ul>
                <li><b>Stoffmenge n</b> in mol.</li>
                <li><b>Masse m</b> in g.</li>
                <li><b>Molare Masse M</b> in g/mol (z. B. NaCl: M â‰ˆ 58,5 g/mol).</li>
                <li><b>Stoffmengenkonzentration c</b> in mol/L.</li>
                <li><b>Volumen V</b> in L (mL â†’ L: durch 1000).</li>
              </ul>
              <p>Standardbeziehungen:</p>
              <ul>
                <li><b>n = m / M</b> â†’ aus Masse und molarer Masse die Stoffmenge bestimmen.</li>
                <li><b>m = n Â· M</b> â†’ aus Stoffmenge die Masse berechnen.</li>
                <li><b>c = n / V</b> und <b>n = c Â· V</b> â†’ VerknÃ¼pfung von Konzentration, Volumen und Stoffmenge.</li>
              </ul>
              <p>Die <b>Reaktionsgleichung</b> ist dein stÃ¶chiometrischer Fahrplan. Beispiel Neutralisation:</p>
              <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:6px; border-radius:6px;">
HCl + NaOH â†’ NaCl + Hâ‚‚O  (1 : 1 VerhÃ¤ltnis)
Hâ‚‚SOâ‚„ + 2 NaOH â†’ Naâ‚‚SOâ‚„ + 2 Hâ‚‚O  (1 : 2 VerhÃ¤ltnis)
              </pre>
              <p>Allgemeine Vorgehensweise in Aufgaben:</p>
              <ol>
                <li>Reaktionsgleichung aufstellen und <b>ausgleichen</b>.</li>
                <li>Alle gegebenen GrÃ¶ÃŸen in SI-Einheiten umrechnen (m in g, V in L).</li>
                <li>Gegebene Stoffmengen berechnen (n = m/M oder n = cÂ·V).</li>
                <li>Mit <b>Koeffizienten</b> aus der Reaktionsgleichung VerhÃ¤ltnis bestimmen und gesuchte Stoffmenge ausrechnen.</li>
                <li>Gesuchte GrÃ¶ÃŸe (Masse, Konzentration etc.) aus n berechnen.</li>
              </ol>
            </div>
          `
        },
        {
          title: "pH, pOH & starke SÃ¤uren/Basen",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Der <b>pH-Wert</b> ist ein MaÃŸ fÃ¼r die Konzentration an Oxoniumionen (Hâº) in einer LÃ¶sung:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>pH = âˆ’log<sub>10</sub>[Hâº]</b>
              </p>
              <p>FÃ¼r starke SÃ¤uren (z. B. HCl) nimmt man an, dass sie in verdÃ¼nnter LÃ¶sung vollstÃ¤ndig dissoziieren:</p>
              <ul>
                <li>HCl â†’ Hâº + Clâ» â†’ [Hâº] â‰ˆ c(HCl)</li>
              </ul>
              <p>FÃ¼r starke Basen (z. B. NaOH) gilt:</p>
              <ul>
                <li>NaOH â†’ Naâº + OHâ» â†’ [OHâ»] â‰ˆ c(NaOH)</li>
              </ul>
              <p>Der pOH-Wert ist analog definiert:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>pOH = âˆ’log<sub>10</sub>[OHâ»]</b>
              </p>
              <p>In Wasser bei 25 Â°C gilt:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>pH + pOH = 14</b>
              </p>
              <p>Vorgehen fÃ¼r starke Basen:</p>
              <ol>
                <li>[OHâ»] aus c(Base) bestimmen.</li>
                <li>pOH = âˆ’log[OHâ»] berechnen.</li>
                <li>pH = 14 âˆ’ pOH berechnen.</li>
              </ol>
              <p>Typische Werte:</p>
              <ul>
                <li>c(HCl) = 0,10 mol/L â†’ pH â‰ˆ 1,0</li>
                <li>c(NaOH) = 0,010 mol/L â†’ [OHâ»] = 0,010 â†’ pOH = 2 â†’ pH = 12</li>
              </ul>
            </div>
          `
        },
        {
          title: "Titration & Gehaltsbestimmung â€“ allgemeine Logik",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Bei einer <b>Titration</b> wird eine Probe unbekannter Zusammensetzung (z. B. SÃ¤ure oder Base) mit einer <b>MaÃŸlÃ¶sung bekannter Konzentration</b> umgesetzt, bis ein bestimmter Punkt (meist Ã„quivalenzpunkt) erreicht ist.</p>
              <p>Am <b>Ã„quivalenzpunkt</b> sind die Stoffmengen von SÃ¤ure und Base im <b>stÃ¶chiometrisch richtigen VerhÃ¤ltnis</b>, das du aus der Reaktionsgleichung ablesen kannst.</p>
              <p>Algorithmus fÃ¼r Gehaltsbestimmungen:</p>
              <ol>
                <li><b>Reaktionsgleichung</b> korrekt aufstellen und ausgleichen (z. B. Hâ‚‚SOâ‚„ + 2 NaOH â†’ ...).</li>
                <li>Stoffmenge der MaÃŸlÃ¶sung berechnen: n(MaÃŸ) = c(MaÃŸ) Â· V(MaÃŸ) (mit V in L).</li>
                <li>Ãœber das stÃ¶chiometrische VerhÃ¤ltnis aus der Gleichung die Stoffmenge der gesuchten Komponente bestimmen.</li>
                <li>Aus der Stoffmenge die Masse berechnen: m = n Â· M.</li>
                <li>Falls ein Gehalt in Prozent gefragt ist: w = (m(gesucht) / m(Probe)) Â· 100 %.</li>
              </ol>
              <p>Beispielreaktion fÃ¼r eine Neutralisation:</p>
              <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:6px; border-radius:6px;">
Hâ‚‚SOâ‚„ + 2 NaOH â†’ Naâ‚‚SOâ‚„ + 2 Hâ‚‚O

â†’ 1 mol Hâ‚‚SOâ‚„ neutralisiert 2 mol NaOH.
              </pre>
              <p>Mit diesem Schema kannst du alle klassischen Gehaltsbestimmungsaufgaben bearbeiten, in denen eine SÃ¤ure-/Base-Probe mit einer MaÃŸlÃ¶sung titriert wird.</p>
            </div>
          `
        },
        {
          title: "pH nach Neutralisation mit Ãœberschuss",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Oft werden SÃ¤ure und Base zusammengegeben, aber nicht im stÃ¶chiometrisch exakten VerhÃ¤ltnis â€“ es bleibt ein <b>Ãœberschuss</b> von SÃ¤ure oder Base Ã¼brig. Der pH der Mischung wird dann durch diesen Ãœberschuss bestimmt.</p>
              <p>Vorgehen:</p>
              <ol>
                <li>Reaktionsgleichung aufstellen und ausgleichen.</li>
                <li>Stoffmengen von SÃ¤ure und Base berechnen: n = cÂ·V.</li>
                <li>Ãœber das stÃ¶chiometrische VerhÃ¤ltnis die tatsÃ¤chlich reagierte Stoffmenge bestimmen.</li>
                <li>Ãœbrig gebliebenen Ãœberschuss berechnen: n(Ãœberschuss) = n(Ausgang) âˆ’ n(verbrauchte).</li>
                <li>Gesamtvolumen der LÃ¶sung berechnen (Summe der Volumina, falls additiv angenommen).</li>
                <li>Aus n(Ãœberschuss) und V(gesamt) die Konzentration [Hâº] oder [OHâ»] berechnen.</li>
                <li>Aus [Hâº]/[OHâ»] pH bzw. pOH und dann pH berechnen.</li>
              </ol>
              <p>Wichtig: Nur der Ãœberschuss einer starken SÃ¤ure/Base bestimmt den pH. Die neutralisierten Anteile ergeben ein Salz (z. B. NaCl), das in diesen einfachen Beispielen den pH nicht wesentlich stÃ¶rt.</p>
            </div>
          `
        },
        {
          title: "Klausurbeispiele Schritt fÃ¼r Schritt",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>Beispiel 1: Titration HCl mit NaOH â€“ Konzentration berechnen</b></p>
              <p>Gegeben: 25,0 mL HCl werden mit 0,100 mol/L NaOH titriert, am Ã„quivalenzpunkt wurden 18,0 mL NaOH verbraucht.</p>
              <ol>
                <li>Reaktion: HCl + NaOH â†’ NaCl + Hâ‚‚O (1 : 1).</li>
                <li>n(NaOH) = 0,100 mol/L Â· 0,0180 L = 1,80 Â· 10â»Â³ mol.</li>
                <li>Am Ã„P: n(HCl) = n(NaOH) = 1,80 Â· 10â»Â³ mol.</li>
                <li>c(HCl) = n / V = 1,80 Â· 10â»Â³ mol / 0,0250 L = 0,072 mol/L.</li>
              </ol>

              <p><b>Beispiel 2: pH einer starken Base</b></p>
              <p>Gegeben: c(NaOH) = 0,020 mol/L.</p>
              <ol>
                <li>[OHâ»] = 0,020 mol/L.</li>
                <li>pOH = âˆ’log(0,020) â‰ˆ 1,70.</li>
                <li>pH = 14 âˆ’ 1,70 = 12,30.</li>
              </ol>

              <p><b>Beispiel 3: Gehaltsbestimmung Ã¼ber RÃ¼cktitration mit Hâ‚‚SOâ‚„</b></p>
              <p>Gegeben: Probe Base X wird in 50,0 mL 0,100 mol/L Hâ‚‚SOâ‚„ gelÃ¶st. Der SÃ¤ureÃ¼berschuss wird mit 0,100 mol/L NaOH titriert, am Ã„P wurden 20,0 mL NaOH verbraucht. X reagiert 1:1 mit Hâº, M(X) = 40,0 g/mol.</p>
              <ol>
                <li>n(Hâ‚‚SOâ‚„) = 0,100 Â· 0,0500 = 5,00 Â· 10â»Â³ mol â†’ n(Hâº)_anfangs = 2 Â· 5,00 Â· 10â»Â³ = 1,00 Â· 10â»Â² mol.</li>
                <li>n(NaOH) = 0,100 Â· 0,0200 = 2,00 Â· 10â»Â³ mol â†’ n(Hâº)_Ã¼brig = 2,00 Â· 10â»Â³ mol.</li>
                <li>n(Hâº)_von X verbraucht = 1,00 Â· 10â»Â² âˆ’ 2,00 Â· 10â»Â³ = 8,00 Â· 10â»Â³ mol.</li>
                <li>X reagiert 1:1 mit Hâº â†’ n(X) = 8,00 Â· 10â»Â³ mol.</li>
                <li>m(X) = n Â· M = 8,00 Â· 10â»Â³ mol Â· 40,0 g/mol = 0,320 g = 320 mg.</li>
              </ol>

              <p><b>Beispiel 4: pH nach Zugabe von NaOH zu HCl (Ãœberschuss)</b></p>
              <p>Gegeben: 50,0 mL 0,100 mol/L HCl + 30,0 mL 0,050 mol/L NaOH.</p>
              <ol>
                <li>n(HCl) = 0,100 Â· 0,0500 = 5,00 Â· 10â»Â³ mol.</li>
                <li>n(NaOH) = 0,050 Â· 0,0300 = 1,50 Â· 10â»Â³ mol.</li>
                <li>HCl + NaOH reagieren 1:1 â†’ NaOH ist limitierend, HCl im Ãœberschuss.</li>
                <li>n(HCl)_Ã¼brig = 5,00 Â· 10â»Â³ âˆ’ 1,50 Â· 10â»Â³ = 3,50 Â· 10â»Â³ mol.</li>
                <li>V_gesamt = (50,0 + 30,0) mL = 80,0 mL = 0,0800 L.</li>
                <li>[Hâº] = n(HCl)_Ã¼brig / V_gesamt = 3,50 Â· 10â»Â³ / 0,0800 â‰ˆ 4,38 Â· 10â»Â² mol/L.</li>
                <li>pH â‰ˆ âˆ’log(4,38 Â· 10â»Â²) â‰ˆ 1,4 (stark sauer).</li>
              </ol>

              <p style="margin-top:6px;">
                Wenn du diese Beispiele nachvollziehen kannst, hast du die typischen Klausuraufgaben zu StÃ¶chiometrie, pH und Gehaltsbestimmung sehr gut im Griff: erst Reaktionsgleichung, dann Stoffmengen, dann pH oder Masse/Gehalt.
              </p>
            </div>
          `
        }
      ]
    },

    {
      id: "radioaktiver-zerfall-halbwertszeit",
      title: "Radioaktiver Zerfall & Halbwertszeit",
      tags: ["RadioaktivitÃ¤t", "Halbwertszeit", "Zerfall", "Exponentialfunktionen"],
      goals: [
        "Verstehen, was radioaktiver Zerfall ist und welche Rolle die Halbwertszeit spielt.",
        "Die Definition der Halbwertszeit T1/2 sicher anwenden kÃ¶nnen.",
        "Die allgemeine Zerfallsformel N(t) = N0 Â· (1/2)^(t/T1/2) auf Masse, Teilchenzahl oder AktivitÃ¤t anwenden kÃ¶nnen.",
        "Umgekehrt aus einer gegebenen Restmenge die vergangene Zeit t bestimmen kÃ¶nnen.",
        "Typische Klausuraufgaben (z. B. 200 g â†’ 25 g nach mehreren Halbwertszeiten) Schritt fÃ¼r Schritt lÃ¶sen kÃ¶nnen."
      ],
      summary: `
        Beim radioaktiven Zerfall wandeln sich instabile Atomkerne spontan in andere Kerne um. Der Zerfall einzelner Kerne ist zufÃ¤llig,
        aber fÃ¼r eine groÃŸe Anzahl von Kernen lÃ¤sst sich das Verhalten sehr gut mit einer Exponentialfunktion beschreiben:
        Pro Zeitintervall zerfÃ¤llt immer der gleiche Bruchteil, nicht die gleiche absolute Menge.
        Die Halbwertszeit Tâ‚/â‚‚ gibt an, nach welcher Zeit die HÃ¤lfte der ursprÃ¼nglichen Menge zerfallen ist.
        Nach jeder weiteren Halbwertszeit halbiert sich die verbleibende Menge erneut.
        Mathematisch lÃ¤sst sich der Zerfall Ã¼ber N(t) = Nâ‚€ Â· (1/2)^(t/Tâ‚/â‚‚) (oder Ã¤quivalent mit der Zerfallskonstante Î») beschreiben.
        Das gleiche Gesetz gilt fÃ¼r Teilchenzahl, Masse und AktivitÃ¤t. In der Klausur werden hÃ¤ufig Aufgaben gestellt,
        bei denen entweder die Restmenge nach einer gegebenen Zeit oder die benÃ¶tigte Zeit fÃ¼r einen gewÃ¼nschten Restanteil berechnet werden muss.
      `,
      keyPoints: [
        "Radioaktiver Zerfall ist ein statistischer, spontaner Prozess, der sich makroskopisch als exponentielle Abnahme zeigt.",
        "Die Halbwertszeit T1/2 ist die Zeit, nach der die HÃ¤lfte der ursprÃ¼nglichen Menge eines radioaktiven Stoffes zerfallen ist.",
        "Nach n Halbwertszeiten gilt: N = N0 Â· (1/2)^n (z. B. n = 3 â†’ N = N0/8).",
        "Allgemein: N(t) = N0 Â· (1/2)^(t/T1/2) fÃ¼r Teilchenzahl, Masse oder AktivitÃ¤t.",
        "Die Zerfallskonstante Î» hÃ¤ngt mit der Halbwertszeit zusammen Ã¼ber T1/2 = ln(2)/Î».",
        "Typische Aufgaben: Restmenge nach gegebener Zeit, benÃ¶tigte Zeit fÃ¼r bestimmten Anteil, Anzahl Halbwertszeiten bestimmen."
      ],
      formulas: [
        "N(t) = N0 Â· (1/2)^(t / T1/2)",
        "m(t) = m0 Â· (1/2)^(t / T1/2)",
        "A(t) = A0 Â· (1/2)^(t / T1/2)",
        "N(t) = N0 Â· e^(âˆ’Î» t)",
        "T1/2 = ln(2) / Î»",
        "Î» = ln(2) / T1/2",
        "t = T1/2 Â· ln(N(t)/N0) / ln(1/2)"
      ],
      visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            Halbwertszeit und Zerfall auf einen Blick:
          </div>
          <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
N(t):    Anzahl Kerne / Masse / AktivitÃ¤t zum Zeitpunkt t
Nâ‚€:      Anfangsmenge (t = 0)
Tâ‚/â‚‚:    Halbwertszeit

Nach n Halbwertszeiten (t = n Â· Tâ‚/â‚‚):
  N = Nâ‚€ Â· (1/2)â¿
  n = 1  â†’  N = Nâ‚€/2
  n = 2  â†’  N = Nâ‚€/4
  n = 3  â†’  N = Nâ‚€/8
  n = 4  â†’  N = Nâ‚€/16
  ...

Allgemein:
  N(t) = Nâ‚€ Â· (1/2)^(t / Tâ‚/â‚‚)
          </pre>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">
            Merkhilfe: <b>Nicht die absolute Menge pro Zeit ist konstant, sondern der <i>Bruchteil</i>, der zerfÃ¤llt.</b>
          </div>
        </div>
      `,
      detailBlocks: [
        {
          title: "Grundidee des radioaktiven Zerfalls",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Radioaktive Kerne sind instabil und kÃ¶nnen sich spontan in andere Kerne umwandeln. Der Zerfall einzelner Kerne ist zwar zufÃ¤llig,
              aber fÃ¼r eine groÃŸe Anzahl von Kernen ergibt sich ein sehr regelmÃ¤ÃŸiges Verhalten: die Anzahl der noch vorhandenen Kerne nimmt
              exponentiell ab.</p>
              <p>Wichtig ist die Unterscheidung:</p>
              <ul>
                <li>Auf der Ebene <b>einzelner Kerne</b> ist der Zerfall zufÃ¤llig.</li>
                <li>Auf der Ebene von vielen Kernen folgt die Abnahme einer <b>glatten Exponentialfunktion</b>.</li>
              </ul>
              <p>Dieses Verhalten gilt nicht nur fÃ¼r die Anzahl der Kerne N, sondern auch fÃ¼r die Masse m der Probe oder fÃ¼r die AktivitÃ¤t A (ZerfÃ¤lle pro Sekunde),
              weil alle GrÃ¶ÃŸen proportional zueinander sind.</p>
            </div>
          `
        },
        {
          title: "Halbwertszeit Tâ‚/â‚‚ â€“ Definition & Bedeutung",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die <b>Halbwertszeit</b> Tâ‚/â‚‚ ist eine zentrale GrÃ¶ÃŸe beim radioaktiven Zerfall.</p>
              <p><b>Definition:</b> Tâ‚/â‚‚ ist die Zeit, nach der die HÃ¤lfte der ursprÃ¼nglichen Menge eines radioaktiven Stoffes zerfallen ist.</p>
              <p>Wenn die Anfangsmenge Nâ‚€ (oder mâ‚€) ist, gilt:</p>
              <ul>
                <li>nach 1 Â· Tâ‚/â‚‚: N = Nâ‚€/2</li>
                <li>nach 2 Â· Tâ‚/â‚‚: N = Nâ‚€/4</li>
                <li>nach 3 Â· Tâ‚/â‚‚: N = Nâ‚€/8</li>
                <li>nach n Â· Tâ‚/â‚‚: N = Nâ‚€ Â· (1/2)â¿</li>
              </ul>
              <p>Das gleiche Schema gilt fÃ¼r die Masse m(t) oder fÃ¼r die AktivitÃ¤t A(t). Nach jeder weiteren Halbwertszeit halbiert sich die noch vorhandene Menge erneut.</p>
            </div>
          `
        },
        {
          title: "Allgemeine Zerfallsformeln & Zerfallskonstante Î»",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Es gibt zwei gleichwertige mathematische Beschreibungen des Zerfalls:</p>
              <p><b>1) Darstellung mit der Halbwertszeit:</b></p>
              <p style="text-align:center; margin:6px 0;">
                <b>N(t) = Nâ‚€ Â· (1/2)<sup>t / Tâ‚/â‚‚</sup></b>
              </p>
              <p>Analog fÃ¼r Masse und AktivitÃ¤t:</p>
              <ul>
                <li>m(t) = mâ‚€ Â· (1/2)<sup>t / Tâ‚/â‚‚</sup></li>
                <li>A(t) = Aâ‚€ Â· (1/2)<sup>t / Tâ‚/â‚‚</sup></li>
              </ul>
              <p><b>2) Darstellung mit der Zerfallskonstante Î»:</b></p>
              <p style="text-align:center; margin:6px 0;">
                <b>N(t) = Nâ‚€ Â· e<sup>âˆ’Î» t</sup></b>
              </p>
              <p>Die Zerfallskonstante Î» (Einheit 1/s, 1/a, ...) beschreibt die Zerfallswahrscheinlichkeit pro Zeiteinheit. Beide Darstellungen sind Ã¼ber</p>
              <p style="text-align:center; margin:6px 0;">
                <b>Tâ‚/â‚‚ = ln(2) / Î»  &nbsp;&nbsp;â†”&nbsp;&nbsp;  Î» = ln(2) / Tâ‚/â‚‚</b>
              </p>
              <p>miteinander verknÃ¼pft. In vielen Allgemeine-Chemie-Aufgaben reicht die Form mit der Halbwertszeit vÃ¶llig aus.</p>
            </div>
          `
        },
        {
          title: "Rezept 1: Restmenge nach gegebener Zeit t",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Typischer Aufgabentyp: <i>â€Wie viel ist nach t Zeit noch Ã¼brig?â€œ</i></p>
              <p><b>Gegeben:</b> Nâ‚€ oder mâ‚€, Halbwertszeit Tâ‚/â‚‚, Zeit t.</p>
              <p><b>Gesucht:</b> Restmenge N(t) oder m(t).</p>
              <p><b>Vorgehen:</b></p>
              <ol>
                <li><b>Anzahl Halbwertszeiten</b> berechnen: n = t / Tâ‚/â‚‚ (darf auch nicht ganzzahlig sein).</li>
                <li>Restanteil: (1/2)<sup>n</sup>.</li>
                <li>Restmenge: N(t) = Nâ‚€ Â· (1/2)<sup>t/Tâ‚/â‚‚</sup> oder m(t) = mâ‚€ Â· (1/2)<sup>t/Tâ‚/â‚‚</sup>.</li>
              </ol>
              <p><b>Beispiel:</b> mâ‚€ = 80 g, Tâ‚/â‚‚ = 10 Jahre, t = 25 Jahre.</p>
              <ul>
                <li>n = t/Tâ‚/â‚‚ = 25/10 = 2,5.</li>
                <li>m(t) = 80 g Â· (1/2)<sup>2,5</sup> = 80 g Â· (1/2)Â² Â· (1/2)<sup>0,5</sup> â‰ˆ 80 g Â· 1/4 Â· 1/âˆš2.</li>
              </ul>
              <p>In der Klausur ist vor allem wichtig, dass du die Formel richtig anwendest und mit dem Exponenten t/Tâ‚/â‚‚ umgehen kannst. Wenn t ein Vielfaches von Tâ‚/â‚‚ ist, wird es besonders einfach.</p>
            </div>
          `
        },
        {
          title: "Rezept 2: Zeit t aus gewÃ¼nschter Restmenge",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Hier lautet die typische Fragestellung: <i>â€Nach welcher Zeit sind nur noch x % der Anfangsmenge Ã¼brig?â€œ</i></p>
              <p><b>Gegeben:</b> Halbwertszeit Tâ‚/â‚‚, VerhÃ¤ltnis f = N(t)/Nâ‚€ (z. B. 0,10 fÃ¼r 10 %).</p>
              <p><b>Gesucht:</b> t.</p>
              <p>Aus der Zerfallsformel</p>
              <p style="text-align:center; margin:6px 0;">
                <b>N(t)/Nâ‚€ = (1/2)<sup>t/Tâ‚/â‚‚</sup></b>
              </p>
              <p>folgt nach Logarithmieren:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>t = Tâ‚/â‚‚ Â· ln(N(t)/Nâ‚€) / ln(1/2)</b>
              </p>
              <p><b>Beispiel:</b> Nach welcher Zeit sind nur noch 10 % Ã¼brig, Tâ‚/â‚‚ = 5 Jahre?</p>
              <ul>
                <li>f = N(t)/Nâ‚€ = 0,10.</li>
                <li>t = 5 a Â· ln(0,10) / ln(1/2).</li>
                <li>ln(0,10) â‰ˆ âˆ’2,3026, ln(1/2) â‰ˆ âˆ’0,6931.</li>
                <li>t â‰ˆ 5 a Â· (âˆ’2,3026 / âˆ’0,6931) â‰ˆ 5 a Â· 3,32 â‰ˆ 16,6 Jahre.</li>
              </ul>
              <p>Intuitiv passt das: nach 3 Halbwertszeiten (15 Jahre) wÃ¤ren 12,5 % Ã¼brig, nach 4 (20 Jahre) 6,25 % â†’ 10 % liegt dazwischen.</p>
            </div>
          `
        },
        {
          title: "Dein Beispiel: 200 g â†’ 25 g mit Tâ‚/â‚‚ = 4000 Jahren",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Das Beispiel aus deinen Notizen:</p>
              <p>Eine radioaktive Substanz hat am Anfang mâ‚€ = 200 g und eine Halbwertszeit von Tâ‚/â‚‚ = 4000 Jahren. Wie viel Gramm sind nach 12 000 Jahren vorhanden?</p>
              <p><b>LÃ¶sungsweg Ã¼ber Halbwertszeiten:</b></p>
              <ol>
                <li>Anzahl Halbwertszeiten: n = t / Tâ‚/â‚‚ = 12 000 a / 4000 a = 3.</li>
                <li>Restanteil: (1/2)Â³ = 1/8.</li>
                <li>Restmasse: m(t) = mâ‚€ Â· (1/8) = 200 g Â· 1/8 = 25 g.</li>
              </ol>
              <p>In Tabellenform:</p>
              <ul>
                <li>t = 0:   m = 200 g.</li>
                <li>t = 4000 a (1 Â· Tâ‚/â‚‚): m = 100 g.</li>
                <li>t = 8000 a (2 Â· Tâ‚/â‚‚): m = 50 g.</li>
                <li>t = 12 000 a (3 Â· Tâ‚/â‚‚): m = 25 g.</li>
              </ul>
              <p>Das ist exakt das Schema, das oft in Klausuren abgefragt wird: man erkennt, dass die gesuchte Zeit ein ganzzahliges Vielfaches der Halbwertszeit ist und halbiert die Masse entsprechend oft.</p>
            </div>
          `
        },
        {
          title: "AktivitÃ¤t A(t) und Anzahl Halbwertszeiten",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die <b>AktivitÃ¤t</b> A gibt die Anzahl der ZerfÃ¤lle pro Zeit (z. B. in Bq = ZerfÃ¤lle pro Sekunde) an. Da A proportional zur Anzahl der radioaktiven Kerne N ist, gilt fÃ¼r die AktivitÃ¤t das gleiche Zerfallsgesetz:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>A(t) = Aâ‚€ Â· (1/2)<sup>t/Tâ‚/â‚‚</sup></b>
              </p>
              <p>Typischer Aufgabentyp:</p>
              <p><i>â€Die AktivitÃ¤t einer Probe halbiert sich in 3 Tagen. Wie groÃŸ ist die AktivitÃ¤t nach 9 Tagen, wenn sie anfangs 8000 Bq betrÃ¤gt?â€œ</i></p>
              <p><b>LÃ¶sung:</b></p>
              <ul>
                <li>Tâ‚/â‚‚ = 3 Tage, t = 9 Tage â†’ n = t/Tâ‚/â‚‚ = 3.</li>
                <li>A(t) = Aâ‚€ Â· (1/2)Â³ = 8000 Bq Â· 1/8 = 1000 Bq.</li>
              </ul>
              <p>In vielen FÃ¤llen ist es am einfachsten, die Anzahl der Halbwertszeiten n (= t/Tâ‚/â‚‚) zu bestimmen und dann zu Ã¼berlegen, wie oft die Menge halbiert wird.</p>
            </div>
          `
        },
        {
          title: "Zusammenfassung & Klausurrezepte",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <ul>
                <li><b>Halbwertszeit Tâ‚/â‚‚:</b> Zeit, in der sich die vorhandene Menge halbiert.</li>
                <li><b>Exponentieller Zerfall:</b> N(t) = Nâ‚€ Â· (1/2)<sup>t/Tâ‚/â‚‚</sup>; analog fÃ¼r m(t) und A(t).</li>
                <li><b>Zerfallskonstante Î»:</b> N(t) = Nâ‚€ Â· e<sup>âˆ’Î» t</sup>, mit Tâ‚/â‚‚ = ln(2)/Î».</li>
                <li><b>Rezept â€Restmengeâ€œ:</b> t/Tâ‚/â‚‚ berechnen â†’ (1/2)<sup>t/Tâ‚/â‚‚</sup> â†’ mit Anfangsmenge multiplizieren.</li>
                <li><b>Rezept â€Zeit aus Restquoteâ€œ:</b> t = Tâ‚/â‚‚ Â· ln(N(t)/Nâ‚€) / ln(1/2).</li>
                <li><b>Besonders einfach:</b> wenn N(t)/Nâ‚€ eine saubere Potenz von 1/2 ist (1/2, 1/4, 1/8, ...), n direkt ablesen.</li>
                <li><b>Achtung bei Einheiten:</b> Tâ‚/â‚‚ und t mÃ¼ssen in der gleichen Zeiteinheit eingesetzt werden (z. B. beide in Jahren oder beide in Sekunden).</li>
              </ul>
              <p style="margin-top:6px;">
                Wenn du diese Punkte im Kopf hast und sicher mit (1/2)<sup>t/Tâ‚/â‚‚</sup> umgehen kannst, bist du fÃ¼r alle Standardaufgaben zum radioaktiven Zerfall in der Allgemeinen Chemie sehr gut vorbereitet.
              </p>
            </div>
          `
        }
      ]
    },


    {
      id: "massendefekt-bindungsenergie",
      title: "Massendefekt, Bindungsenergie & E = mcÂ²",
      tags: ["Massendefekt", "Bindungsenergie", "E = mcÂ²", "Kernphysik", "Energieeinheiten"],
      goals: [
        "Verstehen, warum Atomkerne leichter sind als die Summe ihrer Nukleonen (Massendefekt).",
        "Die Einsteinsche Gleichung E = mÂ·cÂ² auf radioaktive Prozesse anwenden kÃ¶nnen.",
        "Aus Massendefekt Î”m in u die Bindungsenergie eines Kerns in MeV berechnen kÃ¶nnen.",
        "Die Bindungsenergie pro Nukleon bestimmen und zur StabilitÃ¤tsabschÃ¤tzung nutzen kÃ¶nnen.",
        "Sicher zwischen den Einheiten u, MeV, eV und Joule umrechnen kÃ¶nnen."
      ],
      summary: `
        Beim Aufbau von Atomkernen wird Energie frei: die Masse des fertigen Kerns ist kleiner als die Summe der Massen seiner Protonen und Neutronen.
        Diese Massendifferenz nennt man Massendefekt Î”m. Ãœber die Einsteinsche Gleichung E = mÂ·cÂ² entspricht der Massendefekt einer bestimmten Energie,
        der sogenannten Bindungsenergie. Sie ist ein MaÃŸ dafÃ¼r, wie fest die Nukleonen im Kern gebunden sind. In der Kernphysik rechnet man dabei meist
        mit der atomaren Masseneinheit u und der Energieeinheit MeV. Ãœber die NÃ¤herung 1 uÂ·cÂ² â‰ˆ 931,5 MeV kann man Massendefekte in u direkt in MeV umrechnen.
        FÃ¼r viele Klausuraufgaben reicht es, aus dem Massendefekt die Bindungsenergie und die Bindungsenergie pro Nukleon zu bestimmen und einfache Umrechnungen
        zwischen MeV, eV und Joule durchzufÃ¼hren.
      `,
      keyPoints: [
        "Massendefekt Î”m = Summe der Massen von Protonen und Neutronen minus gemessene Kernmasse.",
        "Die â€fehlendeâ€œ Masse wurde bei der Kernbildung in Energie umgewandelt: E = Î”m Â· cÂ².",
        "Die Bindungsenergie ist die Energie, die frei wird (bzw. aufgebracht werden mÃ¼sste), wenn der Kern gebildet (bzw. wieder zerlegt) wird.",
        "1 u â‰ˆ 1,6605 Â· 10^-27 kg und 1 uÂ·cÂ² â‰ˆ 931,5 MeV â€“ sehr nÃ¼tzlich fÃ¼r Schnellrechnungen.",
        "Bindungsenergie pro Nukleon = E_Bindung / A ist ein MaÃŸ fÃ¼r die StabilitÃ¤t des Kerns.",
        "1 eV = 1,602 Â· 10^-19 J, 1 MeV = 10^6 eV â†’ MeV lassen sich einfach in Joule umrechnen."
      ],
      formulas: [
        "Î”m = (Z Â· m_p + N Â· m_n) âˆ’ m_Kern",
        "E_Bindung = Î”m Â· cÂ²",
        "E_Bindung[MeV] â‰ˆ Î”m[u] Â· 931,5 MeV/u",
        "E_pro Nukleon = E_Bindung / A",
        "1 u â‰ˆ 1,6605 Â· 10^-27 kg",
        "1 eV = 1,602 Â· 10^-19 J",
        "1 MeV = 10^6 eV"
      ],
      visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            Massendefekt & Bindungsenergie im Ãœberblick:
          </div>
          <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
Massendefekt:
  Î”m = (Z Â· m_p + N Â· m_n) âˆ’ m_Kern   (alle Massen in u)

Bindungsenergie:
  E_Bindung = Î”m Â· cÂ²

Praktische Einheit:
  1 u Â· cÂ² â‰ˆ 931,5 MeV
  â‡’ E_Bindung[MeV] â‰ˆ Î”m[u] Â· 931,5

Bindungsenergie pro Nukleon:
  E_pro Nukleon = E_Bindung / A

Einheiten:
  1 u â‰ˆ 1,6605 Â· 10^-27 kg
  1 eV = 1,602 Â· 10^-19 J
  1 MeV = 10^6 eV
          </pre>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">
            Merkhilfe: <b>â€Ein bisschen Masse â†’ sehr viel Energieâ€œ, weil cÂ² riesig ist.</b>
          </div>
        </div>
      `,
      detailBlocks: [
        {
          title: "Was ist der Massendefekt?",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Wenn du die Masse eines Atomkerns misst und mit der Summe der Massen seiner Bausteine vergleichst, stellst du fest:
              der Kern ist leichter als die Summe aus Protonen und Neutronen. Diese Differenz nennt man <b>Massendefekt</b> Î”m.</p>
              <p>FÃ¼r einen Kern mit Z Protonen und N Neutronen gilt:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>Î”m = (Z Â· m_p + N Â· m_n) âˆ’ m_Kern</b>
              </p>
              <ul>
                <li>Z = Protonenzahl (Ordnungszahl)</li>
                <li>N = Neutronenzahl</li>
                <li>m_p, m_n = Massen von Proton und Neutron (z. B. in u)</li>
                <li>m_Kern = gemessene Masse des fertigen Kerns</li>
              </ul>
              <p>Î”m ist in der Regel positiv, d. h. die Summe der Einzelmassen ist grÃ¶ÃŸer als die Kernmasse. Die â€fehlendeâ€œ Masse ist nicht verschwunden,
              sondern wurde in Bindungsenergie umgewandelt.</p>
            </div>
          `
        },
        {
          title: "E = mcÂ² und Bindungsenergie",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die Einsteinsche Gleichung verknÃ¼pft Masse und Energie:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>E = m Â· cÂ²</b>
              </p>
              <p>Daraus folgt: jede Masse m entspricht einer Energie E. Bei Kernprozessen bedeutet das:</p>
              <ul>
                <li>Wenn bei der Kernbildung eine Masse Î”m â€verschwindetâ€œ, wurde eine Energie <b>E_Bindung = Î”m Â· cÂ²</b> frei.</li>
                <li>Umgekehrt mÃ¼sstest du genau diese Energie zufÃ¼hren, um den Kern wieder in seine Nukleonen zu zerlegen.</li>
              </ul>
              <p>Man nennt E_Bindung die <b>Bindungsenergie</b> des Kerns. Sie beschreibt, wie fest die Nukleonen aneinander gebunden sind.</p>
            </div>
          `
        },
        {
          title: "Einheiten: u, MeV, eV und Joule",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>In der Kernphysik werden Massen oft in der <b>atomaren Masseneinheit</b> u angegeben:</p>
              <ul>
                <li>1 u â‰ˆ 1,6605 Â· 10â»Â²â· kg</li>
                <li>Masse eines Protons â‰ˆ 1,007 u, eines Neutrons â‰ˆ 1,009 u (typische GrÃ¶ÃŸenordnung).</li>
              </ul>
              <p>FÃ¼r Energien ist statt Joule oft das <b>Elektronenvolt</b> praktisch:</p>
              <ul>
                <li>1 eV = 1,602 Â· 10â»Â¹â¹ J</li>
                <li>1 MeV = 10â¶ eV</li>
              </ul>
              <p>Wichtiger Zusammenhang fÃ¼r schnelle Bindungsenergieberechnungen:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>1 u Â· cÂ² â‰ˆ 931,5 MeV</b>
              </p>
              <p>Wenn der Massendefekt Î”m in u gegeben ist, kannst du die Bindungsenergie direkt berechnen:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>E_Bindung[MeV] â‰ˆ Î”m[u] Â· 931,5</b>
              </p>
              <p>FÃ¼r Joule gilt dann:</p>
              <p style="text-align:center; margin:6px 0;">
                <b>E[J] = E[MeV] Â· 10â¶ Â· 1,602 Â· 10â»Â¹â¹</b>
              </p>
            </div>
          `
        },
        {
          title: "Rezept: Bindungsenergie aus Massendefekt",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Typischer Klausuraufgabentyp: <i>â€Berechnen Sie aus den Massendaten die Bindungsenergie eines Kerns.â€œ</i></p>
              <p><b>Vorgehen:</b></p>
              <ol>
                <li><b>Z und N bestimmen</b> (Protonen- und Neutronenzahl) aus Ordnungszahl Z und Massenzahl A (A = Z + N).</li>
                <li><b>Summe der Einzelmassen</b> rechnen:
                  <br>Z Â· m_p + N Â· m_n (alle Massen in der gleichen Einheit, meist in u).</li>
                <li><b>Massendefekt</b> bestimmen:
                  <br>Î”m = (Z Â· m_p + N Â· m_n) âˆ’ m_Kern.</li>
                <li><b>Bindungsenergie in MeV</b> berechnen:
                  <br>E_Bindung[MeV] â‰ˆ Î”m[u] Â· 931,5.</li>
                <li>Optional: <b>Bindungsenergie pro Nukleon</b>:
                  <br>E_pro Nukleon = E_Bindung / A.</li>
              </ol>
            </div>
          `
        },
        {
          title: "Beispiel 1: Fiktiver Kern mit Z = 2, N = 2",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Gegeben:</p>
              <ul>
                <li>Z = 2, N = 2 (A = 4).</li>
                <li>m_p = 1,007 u, m_n = 1,009 u.</li>
                <li>m_Kern = 4,001 u.</li>
              </ul>
              <p><b>1) Summe der Einzelmassen:</b></p>
              <p>m_Summe = 2 Â· 1,007 u + 2 Â· 1,009 u = 4,032 u.</p>
              <p><b>2) Massendefekt:</b></p>
              <p>Î”m = m_Summe âˆ’ m_Kern = 4,032 u âˆ’ 4,001 u = 0,031 u.</p>
              <p><b>3) Bindungsenergie:</b></p>
              <p>E_Bindung â‰ˆ 0,031 Â· 931,5 MeV â‰ˆ 28,9 MeV.</p>
              <p><b>4) Bindungsenergie pro Nukleon:</b></p>
              <p>E_pro Nukleon = 28,9 MeV / 4 â‰ˆ 7,2 MeV/Nukleon.</p>
              <p>Die GrÃ¶ÃŸe von 7â€“8 MeV/Nukleon ist typisch fÃ¼r gut gebundene, stabile Kerne.</p>
            </div>
          `
        },
        {
          title: "Beispiel 2: Î”m in u â†’ MeV und Joule",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Gegeben: Î”m = 0,20 u.</p>
              <p><b>1) Î”m â†’ MeV:</b></p>
              <p>E_Bindung â‰ˆ 0,20 Â· 931,5 MeV â‰ˆ 186,3 MeV.</p>
              <p><b>2) MeV â†’ Joule:</b></p>
              <ul>
                <li>1 MeV = 10â¶ eV, 1 eV = 1,602 Â· 10â»Â¹â¹ J.</li>
                <li>E[J] = 186,3 Â· 10â¶ Â· 1,602 Â· 10â»Â¹â¹ â‰ˆ 2,99 Â· 10â»Â¹Â¹ J.</li>
              </ul>
              <p>Man sieht: in Joule wirkt die Zahl â€kleinâ€œ, in MeV aber ist es eine typische Bindungsenergie im Nuklearbereich.</p>
            </div>
          `
        },
        {
          title: "Beispiel 3: Welcher Kern ist stabiler?",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Gegeben:</p>
              <ul>
                <li>Kern A: E_Bindung = 400 MeV, A = 50.</li>
                <li>Kern B: E_Bindung = 700 MeV, A = 100.</li>
              </ul>
              <p><b>Bindungsenergie pro Nukleon:</b></p>
              <p>A: E_pro Nukleon = 400 / 50 = 8,0 MeV/Nukleon.</p>
              <p>B: E_pro Nukleon = 700 / 100 = 7,0 MeV/Nukleon.</p>
              <p><b>Interpretation:</b></p>
              <p>Je grÃ¶ÃŸer die Bindungsenergie pro Nukleon, desto â€stÃ¤rker gebundenâ€œ ist der Kern. Im Vergleich ist Kern A stabiler als Kern B,
              obwohl B insgesamt eine grÃ¶ÃŸere absolute Bindungsenergie hat. FÃ¼r StabilitÃ¤tsvergleiche zÃ¤hlt die Energie pro Nukleon.</p>
            </div>
          `
        },
        {
          title: "Zusammenfassung & Klausurhinweise",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <ul>
                <li><b>Massendefekt Î”m</b> entsteht, weil der Kern leichter ist als die Summe der Massen seiner Nukleonen.</li>
                <li><b>Bindungsenergie</b> ist die Energie, die diesem Massendefekt entspricht: E_Bindung = Î”m Â· cÂ².</li>
                <li>Praktisch rechnet man mit Massen in u und Energien in MeV: 1 uÂ·cÂ² â‰ˆ 931,5 MeV.</li>
                <li><b>Rezept:</b> Î”m in u â†’ E_Bindung[MeV] = Î”m Â· 931,5 â†’ ggf. E_pro Nukleon = E_Bindung / A.</li>
                <li>FÃ¼r Umrechnungen: 1 MeV = 10â¶ eV, 1 eV = 1,602 Â· 10â»Â¹â¹ J.</li>
                <li>Bei StabilitÃ¤tsvergleichen ist die Bindungsenergie pro Nukleon entscheidend, nicht die absolute Gesamtenergie.</li>
              </ul>
              <p style="margin-top:6px;">
                Wenn du sicher mit Massendefekt in u, der Umrechnung zu MeV und der Bindungsenergie pro Nukleon umgehen kannst,
                bist du fÃ¼r alle Standardaufgaben zu Massendefekt und E = mcÂ² sehr gut vorbereitet.
              </p>
            </div>
          `
        }
      ]
    },

    {
      id: "volt-ampere-watt-energieeinheiten",
      title: "Volt, Ampere, Watt & Energieeinheiten (J, eV)",
      tags: ["Volt", "Ampere", "Watt", "Joule", "eV", "Leistung", "Energie"],
      goals: [
        "Die physikalischen GrÃ¶ÃŸen Ladung, StromstÃ¤rke, Spannung, Leistung und Energie sicher unterscheiden kÃ¶nnen.",
        "Die Grundformeln I = Q/t, U = E/Q, P = UÂ·I und E = PÂ·t anwenden kÃ¶nnen.",
        "Den Zusammenhang zwischen Volt, Ampere und Watt (P = UÂ·I) verstehen und nutzen kÃ¶nnen.",
        "Elektronenvolt (eV) als Energieeinheit verstehen und zwischen Joule und eV umrechnen kÃ¶nnen.",
        "Typische Dreisatz-/Rechenaufgaben zu Strom, Spannung, Leistung und Energie schrittweise lÃ¶sen kÃ¶nnen."
      ],
      summary: `
        In diesem Thema verbindest du die wichtigsten elektrischen GrundgrÃ¶ÃŸen mit den Energieeinheiten, die in der Atom- und Kernphysik verwendet werden.
        StromstÃ¤rke (Ampere), Spannung (Volt) und Leistung (Watt) beschreiben, wie viel Ladung pro Zeit flieÃŸt, welche Energie pro Ladung zur VerfÃ¼gung steht
        und wie schnell Energie umgesetzt wird. Ãœber die Formeln P = UÂ·I und E = PÂ·t (bzw. E = UÂ·IÂ·t oder E = UÂ·Q) kannst du Leistungen und Energien in technischen
        oder physikalischen Aufgaben berechnen. Das Elektronenvolt (eV) ist eine sehr praktische Energieeinheit auf atomarer Ebene und lÃ¤sst sich direkt Ã¼ber
        Spannung (E = eÂ·U) bzw. Ã¼ber 1 eV = 1,602 Â· 10^-19 J mit Joule verknÃ¼pfen. In Klausuren tauchen hÃ¤ufig einfache, aber verkettete Rechenaufgaben auf,
        bei denen du sauber mit Einheiten und Dreisatz umgehen musst.
      `,
      keyPoints: [
        "Ladung Q (C), StromstÃ¤rke I (A), Spannung U (V), Leistung P (W) und Energie E (J) sind eng verknÃ¼pfte GrÃ¶ÃŸen.",
        "StromstÃ¤rke: I = Q/t â€“ wie viel Ladung pro Zeit flieÃŸt.",
        "Spannung: U = E/Q â€“ wie viel Energie pro Ladung zur VerfÃ¼gung steht.",
        "Leistung: P = UÂ·I â€“ Ampere mal Volt ist Watt.",
        "Energie: E = PÂ·t = UÂ·IÂ·t oder E = UÂ·Q.",
        "1 eV ist die Energie, die ein Elektron beim Durchlaufen von 1 Volt gewinnt: 1 eV = 1,602 Â· 10^-19 J.",
        "Spannung in Volt direkt in eV: ein Elektron an U Volt gewinnt U eV Energie."
      ],
      formulas: [
        "I = Q / t",
        "U = E / Q",
        "E = U Â· Q",
        "P = U Â· I",
        "E = P Â· t",
        "E = U Â· I Â· t",
        "1 eV = 1,602 Â· 10^-19 J",
        "E_eV = E_J / (1,602 Â· 10^-19)",
        "E_J = E_eV Â· 1,602 Â· 10^-19"
      ],
      visual: `
        <div class="learn-visual">
          <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
            Ãœbersicht Ã¼ber die wichtigsten elektrischen GrÃ¶ÃŸen:
          </div>
          <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
Ladung:           Q [C]          (Coulomb)
StromstÃ¤rke:      I [A]          I = Q / t
Spannung:         U [V]          U = E / Q
Leistung:         P [W]          P = U Â· I
Energie:          E [J]          E = P Â· t = U Â· I Â· t

Elektronenvolt:
  1 eV = 1,602 Â· 10^-19 J
  1 MeV = 10^6 eV

Elektron an Spannung U:
  E = e Â· U    (in Joule)
  â†’ fÃ¼r ein Elektron: U Volt â‰™ U eV
          </pre>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">
            Merkhilfe: <b>Ampere Ã— Volt = Watt</b> und <b>Volt Ã— Coulomb = Joule</b>.
          </div>
        </div>
      `,
      detailBlocks: [
        {
          title: "GrundgrÃ¶ÃŸen: Q, I, U, P und E",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die wichtigsten GrÃ¶ÃŸen in einfachen Elektro- und Energieaufgaben sind:</p>
              <ul>
                <li><b>Ladung Q</b> in Coulomb (C): beschreibt, wie viel elektrische Ladung vorhanden ist.</li>
                <li><b>StromstÃ¤rke I</b> in Ampere (A): wie viel Ladung pro Zeit durch einen Leiter flieÃŸt.</li>
                <li><b>Spannung U</b> in Volt (V): Energie pro Ladungseinheit, die im Stromkreis â€zur VerfÃ¼gungâ€œ steht.</li>
                <li><b>Leistung P</b> in Watt (W): wie viel Energie pro Zeit umgesetzt wird.</li>
                <li><b>Energie E</b> in Joule (J): die gesamte umgesetzte oder Ã¼bertragene Energie.</li>
              </ul>
              <p>Zwischen diesen GrÃ¶ÃŸen gibt es einfache, aber sehr wichtige Beziehungen, die in vielen Aufgaben immer wieder vorkommen.</p>
            </div>
          `
        },
        {
          title: "StromstÃ¤rke & Spannung: I = Q/t, U = E/Q",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>StromstÃ¤rke I</b> beschreibt, wie viel Ladung pro Zeit flieÃŸt:</p>
              <p style="text-align:center; margin:6px 0;"><b>I = Q / t</b></p>
              <ul>
                <li>I in Ampere (A)</li>
                <li>Q in Coulomb (C)</li>
                <li>t in Sekunden (s)</li>
              </ul>
              <p><b>Spannung U</b> ist definiert als Energie pro Ladung:</p>
              <p style="text-align:center; margin:6px 0;"><b>U = E / Q</b></p>
              <p>Umgestellt ergibt das:</p>
              <p style="text-align:center; margin:6px 0;"><b>E = U Â· Q</b></p>
              <p>Damit kannst du aus einer gegebenen Spannung U und einer transportierten Ladung Q direkt die Ã¼bertragene Energie E berechnen.</p>
            </div>
          `
        },
        {
          title: "Leistung: Ampere Ã— Volt ist Watt (P = UÂ·I)",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Die <b>Leistung</b> P gibt an, wie schnell Energie umgesetzt wird (Energie pro Zeit):</p>
              <p style="text-align:center; margin:6px 0;"><b>P = E / t</b></p>
              <p>In elektrischen Systemen kann man P Ã¼ber Spannung und Strom ausdrÃ¼cken:</p>
              <p style="text-align:center; margin:6px 0;"><b>P = U Â· I</b></p>
              <ul>
                <li>P in Watt (W)</li>
                <li>U in Volt (V)</li>
                <li>I in Ampere (A)</li>
              </ul>
              <p>Damit ergibt sich fÃ¼r die Energie:</p>
              <p style="text-align:center; margin:6px 0;"><b>E = P Â· t = U Â· I Â· t</b></p>
              <p>Das ist die mathematische Version von:<br><b>â€Ampere mal Volt ist Wattâ€œ</b> und â€Watt mal Zeit ist Jouleâ€œ.</p>
            </div>
          `
        },
        {
          title: "Elektronenvolt (eV) & Zusammenhang mit Spannung",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Das <b>Elektronenvolt (eV)</b> ist eine Energieeinheit, die vor allem in der Atom- und Kernphysik verwendet wird.</p>
              <p><b>Definition:</b> 1 eV ist die Energie, die ein Elektron gewinnt, wenn es Ã¼ber eine Spannung von 1 V beschleunigt wird.</p>
              <p>Formel dahinter:</p>
              <p style="text-align:center; margin:6px 0;"><b>E = e Â· U</b></p>
              <ul>
                <li>e = 1,602 Â· 10^-19 C (Elementarladung)</li>
                <li>U in Volt</li>
                <li>E in Joule</li>
              </ul>
              <p>FÃ¼r ein Elektron gilt damit ganz einfach:</p>
              <ul>
                <li>1 V â†’ 1 eV</li>
                <li>10 V â†’ 10 eV</li>
                <li>120 V â†’ 120 eV</li>
              </ul>
              <p>Die Umrechnung zu Joule:</p>
              <p style="text-align:center; margin:6px 0;"><b>1 eV = 1,602 Â· 10^-19 J</b></p>
            </div>
          `
        },
        {
          title: "Energieeinheiten: Joule â†” eV (und MeV)",
          content: `
            <div style="font-size:13px; line-height:150%;">

              <p>FÃ¼r viele Rechnungen brauchst du die Umrechnung zwischen Joule und eV:</p>

              <ul>
                <li>1 eV = 1,602 Â· 10^-19 J</li>

                <li>1 MeV = 10^6 eV</li>

              </ul>

              <p>Daraus folgen die Rechenformeln:</p>

              <ul>
                <li><b>eV â†’ Joule:</b> E_J = E_eV Â· 1,602 Â· 10^-19</li>

                <li><b>Joule â†’ eV:</b> E_eV = E_J / (1,602 Â· 10^-19)</li>

              </ul>

              <p>Typische GrÃ¶ÃŸenordnungen:</p>

              <ul>
                <li>Atomare ÃœbergÃ¤nge: einige eV bis wenige 10 eV.</li>

                <li>Kernphysik: MeV-Bereich (Millionen eV).</li>

              </ul>
            </div>
          `
        },
        {
          title: "Klausurbeispiele Schritt fÃ¼r Schritt",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p><b>Beispiel 1: P = UÂ·I â†’ Ampere Ã— Volt = Watt</b></p>
              <p>Gegeben: U = 12 V, I = 0,50 A.</p>
              <ol>
                <li>Leistung: P = UÂ·I = 12 V Â· 0,50 A = 6 W.</li>
                <li>Energie in 3 min (180 s): E = PÂ·t = 6 W Â· 180 s = 1080 J.</li>
              </ol>

              <p><b>Beispiel 2: Energie aus Spannung & Ladung</b></p>
              <p>Gegeben: U = 5,0 V, Q = 10,0 C.</p>
              <ol>
                <li>E = UÂ·Q = 5,0 V Â· 10,0 C = 50 J.</li>
              </ol>

              <p><b>Beispiel 3: Elektron an U = 120 V</b></p>
              <p>Gegeben: Elektron, U = 120 V.</p>
              <ol>
                <li>Energie in eV: E = 120 eV.</li>
                <li>Energie in Joule: E_J = 120 Â· 1,602 Â· 10^-19 J â‰ˆ 1,92 Â· 10^-17 J.</li>
              </ol>

              <p><b>Beispiel 4: StromstÃ¤rke aus Leistung und Spannung</b></p>
              <p>Gegeben: P = 60 W, U = 12 V.</p>
              <ol>
                <li>Aus P = UÂ·I folgt I = P/U = 60 W / 12 V = 5 A.</li>
              </ol>

              <p><b>Beispiel 5: eV â†” Joule</b></p>
              <p>Gegeben: E = 3,0 eV.</p>
              <ol>
                <li>In Joule: E_J = 3,0 Â· 1,602 Â· 10^-19 J â‰ˆ 4,81 Â· 10^-19 J.</li>
              </ol>
              <p>Gegeben: E = 1,0 Â· 10^-18 J.</p>
              <ol>
                <li>In eV: E_eV = (1,0 Â· 10^-18 J) / (1,602 Â· 10^-19 J/eV) â‰ˆ 6,24 eV.</li>
              </ol>

              <p style="margin-top:6px;">
                In all diesen Aufgaben ist das Wichtigste, dass du die richtige Grundformel erkennst (I = Q/t, U = E/Q, P = UÂ·I, E = PÂ·t)
                und konsequent mit den Einheiten arbeitest. Der Rest ist sauberer Dreisatz.
              </p>
            </div>
          `
        }
      ]
    },


{
  id: "em-strahlung-quanten-photonen",
  title: "Elektromagnetische Strahlung, Quanten & Photonen (Î», Î½, E)",
  tags: ["EM-Strahlung", "WellenlÃ¤nge", "Frequenz", "Photon", "Planck", "Energie", "Photoeffekt"],
  goals: [
    "WellenlÃ¤nge Î», Frequenz Î½ und Lichtgeschwindigkeit c sicher unterscheiden und korrekt mit Einheiten verwenden.",
    "Die Beziehung c = Î»Â·Î½ anwenden und nach Î» oder Î½ umstellen kÃ¶nnen.",
    "Die Photonenergie mit E = hÂ·Î½ und E = hÂ·c/Î» berechnen kÃ¶nnen.",
    "Einheiten sicher umrechnen (nm â†’ m, Hz = s^-1, Joule â†” eV).",
    "Typische Klausuraufgaben (Î» â†’ Î½ â†’ E, Vergleich von Strahlungen, Photoeffekt-Grundidee) Schritt fÃ¼r Schritt lÃ¶sen kÃ¶nnen."
  ],
  summary: `
    Elektromagnetische Strahlung kann als Welle (WellenlÃ¤nge Î», Frequenz Î½) und gleichzeitig als Teilchenstrom (Photonen) beschrieben werden.
    Die zentrale Beziehung der Wellenseite ist c = Î»Â·Î½. Damit kannst du aus einer WellenlÃ¤nge die Frequenz berechnen (oder umgekehrt).
    Auf der Quantenseite gilt fÃ¼r die Energie eines Photons E = hÂ·Î½. Kombiniert man beide Formeln, folgt E = hÂ·c/Î».
    In Klausuren sind die Standardaufgaben: Umrechnungen (nm â†” m), Frequenz berechnen, Photonenergie in Joule und eV berechnen,
    sowie qualitative Aussagen: kÃ¼rzere WellenlÃ¤nge â†’ hÃ¶here Frequenz â†’ hÃ¶here Energie. Beim Photoeffekt ist entscheidend: Frequenz bestimmt,
    ob Elektronen austreten kÃ¶nnen (Schwelle), IntensitÃ¤t beeinflusst eher die Anzahl, nicht die Energie pro Elektron.
  `,
  keyPoints: [
    "Î» (Lambda) = WellenlÃ¤nge [m], Î½ (Nu) = Frequenz [Hz], c = Lichtgeschwindigkeit [m/s].",
    "Zentrale Beziehung: c = Î»Â·Î½ (und Î½ = c/Î», Î» = c/Î½).",
    "Photonenergie: E = hÂ·Î½; mit Î½ = c/Î» folgt E = hÂ·c/Î».",
    "Einheiten: 1 Hz = 1/s = s^-1; 1 nm = 10^-9 m.",
    "Je kleiner Î», desto grÃ¶ÃŸer Î½ und desto grÃ¶ÃŸer die Energie E.",
    "Photoeffekt: Elektronen treten nur aus, wenn hÂ·Î½ â‰¥ A (A = Austrittsarbeit)."
  ],
  formulas: [
    "c = Î» Â· Î½",
    "Î½ = c / Î»",
    "Î» = c / Î½",
    "E = h Â· Î½",
    "E = (h Â· c) / Î»",
    "1 Hz = 1/s = s^-1",
    "1 nm = 10^-9 m",
    "h = 6,626 Â· 10^-34 JÂ·s",
    "c â‰ˆ 3,00 Â· 10^8 m/s",
    "1 eV = 1,602 Â· 10^-19 J",
    "E_eV = E_J / (1,602 Â· 10^-19)",
    "E_J = E_eV Â· 1,602 Â· 10^-19",
    "Photoeffekt: E_kin,max = hÂ·Î½ âˆ’ A"
  ],
  visual: `
    <div class="learn-visual">
      <div style="font-size:12px; opacity:0.8; margin-bottom:6px;">
        Merkkette (sehr klausurrelevant):
      </div>
      <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
c = Î» Â· Î½

kleinere Î»  â†’ grÃ¶ÃŸere Î½  â†’ grÃ¶ÃŸere E
(E = hÂ·Î½ = hÂ·c/Î»)

Einheiten:
  Î»: m (oft nm)
  Î½: Hz = s^-1
  E: Joule oder eV
      </pre>
      <div style="font-size:11px; opacity:0.8; margin-top:4px;">
        Typischer Fehler: Î» (Lambda) wird als Âµ gelesen und Î½ (Nu) als v.
      </div>
    </div>
  `,
  detailBlocks: [
    {
      title: "Grundbegriffe: Î», Î½, c (mit Einheiten)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p><b>WellenlÃ¤nge Î» (Lambda)</b>: Abstand zwischen zwei Wellenbergen. Einheit: <b>m</b> (hÃ¤ufig nm).</p>
          <p><b>Frequenz Î½ (Nu)</b>: Schwingungen pro Sekunde. Einheit: <b>Hz</b>.</p>
          <p><b>Lichtgeschwindigkeit c</b>: im Vakuum ca. <b>3,00 Â· 10^8 m/s</b>.</p>

          <p style="margin-top:8px;"><b>Einheiten-Merker:</b></p>
          <ul>
            <li>1 nm = 10^-9 m</li>
            <li>1 Hz = 1/s = s^-1</li>
          </ul>
        </div>
      `
    },
    {
      title: "Wellenformel: c = Î»Â·Î½ (und Umstellungen)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p>Die zentrale Beziehung der EM-Welle ist:</p>
          <p style="text-align:center; margin:6px 0;"><b>c = Î» Â· Î½</b></p>
          <p>Wichtige Umstellungen:</p>
          <ul>
            <li><b>Î½ = c / Î»</b> (wenn Î» gegeben ist)</li>
            <li><b>Î» = c / Î½</b> (wenn Î½ gegeben ist)</li>
          </ul>
          <p><b>Merke:</b> Bei konstantem c gilt: <b>kleinere Î» â†’ grÃ¶ÃŸere Î½</b>.</p>
        </div>
      `
    },
    {
      title: "Quanten: Photonenergie (E = hÂ·Î½) und Kombination (E = hÂ·c/Î»)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p>Planck/Quantenidee: Strahlung Ã¼bertrÃ¤gt Energie in Paketen (Photonen).</p>
          <p style="text-align:center; margin:6px 0;"><b>E = h Â· Î½</b></p>
          <p>Mit Î½ = c/Î» folgt die sehr klausurrelevante Kombiformel:</p>
          <p style="text-align:center; margin:6px 0;"><b>E = (h Â· c) / Î»</b></p>

          <p><b>Konstanten:</b></p>
          <ul>
            <li>h = 6,626 Â· 10^-34 JÂ·s</li>
            <li>c â‰ˆ 3,00 Â· 10^8 m/s</li>
          </ul>
        </div>
      `
    },
    {
      title: "Photoeffekt (Qualitativ + Standardformel)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p>Beim <b>photoelektrischen Effekt</b> kÃ¶nnen Elektronen aus einem Metall austreten, wenn die Photonenenergie groÃŸ genug ist.</p>
          <p><b>Schwelle:</b> hÂ·Î½ muss mindestens die Austrittsarbeit A liefern.</p>
          <p style="text-align:center; margin:6px 0;"><b>E_kin,max = hÂ·Î½ âˆ’ A</b></p>

          <ul>
            <li><b>Frequenz</b> bestimmt, ob Elektronen Ã¼berhaupt austreten (Schwellfrequenz).</li>
            <li><b>IntensitÃ¤t</b> beeinflusst eher die <i>Anzahl</i> der Elektronen (mehr Photonen), nicht deren Energie pro Elektron.</li>
          </ul>
        </div>
      `
    },
    {
      title: "Energie in Joule â†” eV (kurz & klausursicher)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p>Oft rechnest du Photonenergien in Joule aus und wandelst dann in eV um.</p>
          <ul>
            <li><b>1 eV = 1,602 Â· 10^-19 J</b></li>
            <li><b>E_eV = E_J / (1,602 Â· 10^-19)</b></li>
            <li><b>E_J = E_eV Â· 1,602 Â· 10^-19</b></li>
          </ul>
        </div>
      `
    },
    {
      title: "Klausurbeispiele Schritt fÃ¼r Schritt (Î» â†’ Î½ â†’ E)",
      content: `
        <div style="font-size:13px; line-height:1.5;">
          <p><b>Beispiel 1: Frequenz aus WellenlÃ¤nge</b></p>
          <p>Gegeben: Î» = 500 nm. Gesucht: Î½.</p>
          <ol>
            <li>Umrechnen: 500 nm = 500 Â· 10^-9 m.</li>
            <li>Î½ = c/Î» = (3,00 Â· 10^8) / (500 Â· 10^-9) â‰ˆ 6,00 Â· 10^14 Hz.</li>
          </ol>

          <p><b>Beispiel 2: Photonenergie aus WellenlÃ¤nge (J und eV)</b></p>
          <p>Gegeben: Î» = 500 nm. Gesucht: E.</p>
          <ol>
            <li>E = hÂ·c/Î» = (6,626 Â· 10^-34 Â· 3,00 Â· 10^8) / (500 Â· 10^-9)</li>
            <li>E â‰ˆ 3,98 Â· 10^-19 J.</li>
            <li>In eV: E_eV = (3,98 Â· 10^-19) / (1,602 Â· 10^-19) â‰ˆ 2,48 eV.</li>
          </ol>

          <p><b>Beispiel 3: Vergleich â€“ welche Strahlung ist energiereicher?</b></p>
          <p>Vergleiche: Î»1 = 700 nm (rot) und Î»2 = 250 nm (UV).</p>
          <ol>
            <li>Da E = hÂ·c/Î» gilt: kleinere Î» â†’ grÃ¶ÃŸere Energie.</li>
            <li>UV (250 nm) ist energiereicher als rot (700 nm).</li>
          </ol>

          <p style="margin-top:6px;">
            Klausur-Tipp: In fast allen Aufgaben ist der SchlÃ¼ssel die Kette <b>nm â†’ m</b>, dann <b>Î½ = c/Î»</b>, dann <b>E = hÂ·Î½</b> (oder direkt E = hÂ·c/Î»),
            und am Ende ggf. <b>J â†’ eV</b>.
          </p>
        </div>
      `
    }
  ]
}








  ] // schlieÃŸt topics-Array
},    // schlieÃŸt Subject "Allgemeine Chemie"



{
  id: "biochemie",
  name: "Biochemie",
  description:
    "BiomolekÃ¼le, Enzyme, Puffer/pH in biologischen Systemen, Energie (ATP) & Grundlagen des Stoffwechsels â€“ kompakt fÃ¼r Klausuren.",
  topics: [
    {
      id: "bio-ueberblick",
      title: "Biochemie: Ãœberblick & Grundideen",
      tags: ["BiomolekÃ¼le", "Enzyme", "Stoffwechsel", "ATP"],
      goals: [
        "Die vier BiomolekÃ¼lklassen (KH, Lipide, Proteine, NukleinsÃ¤uren) einordnen kÃ¶nnen.",
        "Grundidee von Enzymen (Katalyse, SpezifitÃ¤t) erklÃ¤ren kÃ¶nnen.",
        "ATP als EnergiewÃ¤hrung verstehen (qualitativ)."
      ],
      summary:
        "Biochemie beschreibt die Chemie des Lebens: BiomolekÃ¼le, Enzymreaktionen und Stoffwechselwege. Zentral ist, wie Zellen Energie speichern/Ã¼bertragen (ATP) und wie Enzyme Reaktionen extrem beschleunigen und regulieren.",
      keyPoints: [
        "BiomolekÃ¼le: Kohlenhydrate, Lipide, Proteine, NukleinsÃ¤uren.",
        "Enzyme = Biokatalysatoren (senken Aktivierungsenergie, werden nicht verbraucht).",
        "SpezifitÃ¤t: Substrat passt ins aktive Zentrum.",
        "ATP koppelt Energie-freisetzende und energieverbrauchende Prozesse."
      ],
      formulas: [],
      visual: `
        <div style="font-size:11px;opacity:0.9;">
          Merksatz: <b>Struktur â†’ Funktion</b> (BiomolekÃ¼le) und <b>Enzyme beschleunigen</b> (Katalyse).
        </div>
      `,
      detailBlocks: [
        {
          title: "Die 4 BiomolekÃ¼lklassen",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <ul>
                <li><b>Kohlenhydrate</b>: Energie & Struktur (z. B. Glucose, StÃ¤rke).</li>
                <li><b>Lipide</b>: Membranen & Energiespeicher (z. B. FettsÃ¤uren, Phospholipide).</li>
                <li><b>Proteine</b>: Enzyme, Transport, Struktur (AminosÃ¤uren als Bausteine).</li>
                <li><b>NukleinsÃ¤uren</b>: Information (DNA/RNA), Nukleotide als Bausteine.</li>
              </ul>
            </div>
          `
        }
      ]
    },

    {
      id: "bio-ph-puffer",
      title: "pH & Puffer in biologischen Systemen",
      tags: ["pH", "Puffer", "Henderson-Hasselbalch"],
      goals: [
        "pH sicher berechnen und interpretieren.",
        "Grundprinzip eines Puffers erklÃ¤ren.",
        "Henderson-Hasselbalch anwenden (falls bei euch verlangt)."
      ],
      summary:
        "Puffer halten den pH-Wert stabil, weil sie H+ abfangen oder abgeben kÃ¶nnen (schwache SÃ¤ure/Base + konjugiertes Paar). Biologische Systeme sind stark pH-abhÃ¤ngig (EnzymaktivitÃ¤t!).",
      keyPoints: [
        "pH = âˆ’log10([H+]).",
        "Puffer bestehen aus schwacher SÃ¤ure HA und konjugierter Base Aâˆ’.",
        "Bei Mischung gilt oft: pH = pKs + log10([Aâˆ’]/[HA]) (Henderson-Hasselbalch)."
      ],
      formulas: [
        "pH = âˆ’log10([H+])",
        "pOH = âˆ’log10([OHâˆ’])",
        "pH + pOH = 14 (bei 25 Â°C)",
        "Henderson-Hasselbalch: pH = pKs + log10([Aâˆ’]/[HA])"
      ],
      visual: `
        <pre style="font-size:11px; line-height:1.4; background:rgba(0,0,0,0.15); padding:8px; border-radius:6px;">
Pufferpaar:
  HA  â‡Œ  H+ + Aâˆ’

Wenn [Aâˆ’] = [HA]  â†’  pH = pKs
        </pre>
      `,
      detailBlocks: [
        {
          title: "Klausurbeispiel (kurz): pH aus Henderson-Hasselbalch",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <p>Gegeben: pKs = 4,76, VerhÃ¤ltnis [Aâˆ’]/[HA] = 10.</p>
              <ol>
                <li>pH = pKs + log10([Aâˆ’]/[HA])</li>
                <li>pH = 4,76 + log10(10) = 4,76 + 1 = <b>5,76</b></li>
              </ol>
            </div>
          `
        }
      ]
    },

    {
      id: "bio-enzyme",
      title: "Enzyme: Grundprinzip, SpezifitÃ¤t, Einflussfaktoren",
      tags: ["Enzyme", "Aktivierungsenergie", "Temperatur", "pH"],
      goals: [
        "ErklÃ¤ren kÃ¶nnen, was Enzyme machen (Katalyse) und warum sie so wichtig sind.",
        "Typische Einflussfaktoren (Temperatur, pH, Substrat) nennen kÃ¶nnen.",
        "Klausurtyp: Graphen qualitativ deuten (AktivitÃ¤t vs. Temperatur/pH)."
      ],
      summary:
        "Enzyme sind Proteine (meist), die Reaktionen beschleunigen, indem sie die Aktivierungsenergie senken. Sie sind hochspezifisch und arbeiten nur in bestimmten pH-/Temperaturbereichen optimal.",
      keyPoints: [
        "Enzyme senken die Aktivierungsenergie, verÃ¤ndern aber nicht die Lage des Gleichgewichts.",
        "Aktives Zentrum bindet Substrat â†’ Enzym-Substrat-Komplex.",
        "Temperatur zu hoch â†’ Denaturierung; falscher pH â†’ AktivitÃ¤t sinkt."
      ],
      formulas: [],
      visual: `
        <div style="font-size:11px;opacity:0.9;">
          Klausurklassiker: â€Warum sinkt AktivitÃ¤t bei hohen Temperaturen?â€œ â†’ <b>Denaturierung</b>.
        </div>
      `,
      detailBlocks: [
        {
          title: "Klausurfrage (typisch): Was bewirkt ein Enzym?",
          content: `
            <div style="font-size:13px; line-height:1.5;">
              <ul>
                <li>Senkt <b>Aktivierungsenergie</b> â†’ Reaktion lÃ¤uft schneller.</li>
                <li>Wird nicht verbraucht (kommt am Ende wieder raus).</li>
                <li>VerÃ¤ndert nicht die <b>Gleichgewichtslage</b>, nur die Geschwindigkeit.</li>
              </ul>
            </div>
          `
        }
      ]
    }
  ]
}



] // schlieÃŸt subjects-Array
}; // schlieÃŸt learnData


    // ---------- DATENMODELL ----------
    
let data = {
  theme: "dark",
  syncId: null,
  notebooks: [],
  activeNotebookId: null,
  activePageId: null,
  cards: { decks: [] },
  planner: { exams: [], focusSessions: [] },
  formulas: [],
  tasks: [],
  brain: { entries: [] },
  templateScale: "medium"   // ğŸ‘ˆ NEU: RastergrÃ¶ÃŸe (small / medium / large)
};


    const STORAGE_KEY = "uniHyperNotes_v3";

    // ---------- COMMON DOM ----------
    const tabButtons = document.querySelectorAll(".tab-btn");
    const sections = {
      notes: document.getElementById("notesLayout"),
      cards: document.getElementById("cardsSection"),
      planner: document.getElementById("plannerSection"),
      formulas: document.getElementById("formulasSection"),
      tools: document.getElementById("toolsSection"),
      learn: document.getElementById("learnSection"),
      tasks: document.getElementById("tasksSection"),
      biochem: document.getElementById("biochemSection"),
      brain: document.getElementById("brainSection"),
      stats: document.getElementById("statsSection")
    };

    const darkModeBtn = document.getElementById("darkModeBtn");
    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const importJsonBtn = document.getElementById("importJsonBtn");
    const importJsonInput = document.getElementById("importJsonInput");

    // ---------- NOTIZEN / CANVAS ----------
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const notebookSelect = document.getElementById("notebookSelect");
    const addNotebookBtn = document.getElementById("addNotebookBtn");

// iPad/Safari: eigenes Scroll-/Zoom-Verhalten abschalten
canvas.style.touchAction = "none";


// --- Zoom & Pan ---
let zoom = 1;
let panX = 0;
let panY = 0;
let isPinching = false;
let lastPinchDist = 0;
let lastPinchCenter = null;
let touchMode = "draw"; // "draw" | "scroll"
let panStart = null; // for 1-finger pan in scroll mode

// Wendet CSS-Transform auf Canvas an und aktualisiert Zoom-Label
function updateCanvasTransform() {
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
  const zl = document.getElementById("zoomLabel");
  if (zl) zl.textContent = Math.round(zoom * 100) + "%";
}

function resetZoom() {
  zoom = 1; panX = 0; panY = 0;
  updateCanvasTransform();
}

// Zoom auf einen Bildschirm-Punkt (cx, cy) - korrekte Zoom-zu-Punkt Formel
function zoomToPoint(cx, cy, factor) {
  const rect = canvas.getBoundingClientRect();
  const screenCX = rect.left + rect.width / 2;
  const screenCY = rect.top + rect.height / 2;
  const oldZoom = zoom;
  zoom = Math.max(0.4, Math.min(5, zoom * factor));
  // Pan anpassen, sodass der Punkt unter (cx,cy) bleibt
  panX += (cx - screenCX) * (1 - zoom / oldZoom);
  panY += (cy - screenCY) * (1 - zoom / oldZoom);
  updateCanvasTransform();
}


    const addPageBtn = document.getElementById("addPageBtn");
    const pageList = document.getElementById("pageList");
    const templateSelect = document.getElementById("templateSelect");
    const templateSizeSelect = document.getElementById("templateSizeSelect");
    const sidebarNotes = document.getElementById("sidebarNotes");

// Pencil-Zeichnen Ã¼ber Pointer Events


    const colorPicker = document.getElementById("colorPicker");
    const toolButtons = document.querySelectorAll(".tool-btn");
    const strokeButtons = document.querySelectorAll(".stroke-btn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const clearBtn = document.getElementById("clearBtn");
    const exportPageBtn = document.getElementById("exportPageBtn");

    let currentTool = "pen"; // pen | highlighter | eraser | line | rect | circle
    let currentColor = colorPicker.value;
    let currentWidth = 2;
    let drawing = false;
    let currentStroke = null;
    let lastPos = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let shapeStartPos = null;

    function getActiveNotebook() {
      return data.notebooks.find(nb => nb.id === data.activeNotebookId);
    }

    function getActivePage() {
      const nb = getActiveNotebook();
      if (!nb) return null;
      return nb.pages.find(p => p.id === data.activePageId);
    }

    // ---------- Storage & Theme ----------
    function saveData() {
  // Lokal speichern (wie bisher)
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Versuchen, in die Cloud zu syncen (non-blocking)
  syncToCloud();
}

// ---- Cloud-Sync: Hochladen ----
async function syncToCloud() {
  try {
    const id = askForSyncId();  // sorgt dafÃ¼r, dass wir eine Sync-ID haben
    if (!id) return;

    updateSyncStatus("Synchronisiere mit Cloud â€¦");

    const ref = doc(db, "syncProfiles", id);
    await setDoc(ref, {
      data,
      updatedAt: Date.now()
    });

    updateSyncStatus("Mit Cloud synchronisiert âœ”");
  } catch (err) {
    console.error("Cloud-Sync fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Cloud-Sync (lokal ist alles sicher).");
  }
}


    function loadData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const defaultNotebook = {
          id: "nb-" + Date.now(),
          name: "Standard",
          pages: [
            { id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }
          ]
        };
        data.notebooks = [defaultNotebook];
        data.activeNotebookId = defaultNotebook.id;
        data.activePageId = defaultNotebook.pages[0].id;
        data.theme = "dark";
        data.cards = { decks: [] };
        data.planner = { exams: [], focusSessions: [] };
        data.formulas = [];
        data.tasks = [];
        data.brain = { entries: [] };
        data.templateScale = "medium";
        return;
      }
      try {
        data = JSON.parse(raw);
        if (!data.templateScale) data.templateScale = "medium"; // ğŸ‘ˆ falls altes Backup
      } catch (e) {
        console.error("Fehler beim Laden, initialisiere neu", e);
        localStorage.removeItem(STORAGE_KEY);
        loadData();
      }
    }

// ---- Cloud-Sync: Herunterladen ----
async function syncFromCloud() {
  try {
    const id = askForSyncId();
    if (!id) return;

    updateSyncStatus("Lade Daten aus der Cloud â€¦");

    const ref = doc(db, "syncProfiles", id);
    const snap = await getDoc(ref);

    if (!snap.exists()) {
      updateSyncStatus("Noch keine Cloud-Daten fÃ¼r diese Sync-ID â€“ lokale Daten bleiben.");
      return;
    }

    const cloud = snap.data();
    if (cloud && cloud.data) {
  data = cloud.data;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Alles neu rendern, damit du es siehst
  applyTheme();
  renderNotebookSelect();
  resizeCanvas();
  renderPageList();
  redrawActivePage();

  // renderDecks() removed - replaced by Karteikarten2
  renderExams();
  renderFormulas();
  renderTasks();
  renderBrainHistory();
  renderStats();
  renderToolInputs();
  renderLearnSubjects();
  renderLearnTopics();
  renderLearnContent();

  updateSyncStatus("Cloud-Daten geladen âœ”");
}
 else {
      updateSyncStatus("Cloud-Dokument leer â€“ keine Ã„nderung.");
    }
  } catch (err) {
    console.error("Cloud-Download fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Laden aus der Cloud.");
  }
}

    function applyTheme() {
      if (data.theme === "light") {
        document.body.classList.add("light");
      } else {
        document.body.classList.remove("light");
      }
    }

    function toggleTheme() {
      data.theme = data.theme === "dark" ? "light" : "dark";
      applyTheme();
      saveData();
    }

    darkModeBtn.addEventListener("click", toggleTheme);

    // ---------- Tabs ----------
    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        tabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const tab = btn.getAttribute("data-tab");
        Object.keys(sections).forEach(k => {
          if (k === "notes") {
            sections[k].classList.toggle("active", tab === "notes");
            sections[k].style.display = tab === "notes" ? "flex" : "none";
          } else {
            sections[k].classList.toggle("active", k === tab);
          }
        });
        if (tab === "stats") renderStats();
      });
    });

    // ---------- Notebooks & Seiten ----------
    function renderNotebookSelect() {
      notebookSelect.innerHTML = "";
      data.notebooks.forEach(nb => {
        const opt = document.createElement("option");
        opt.value = nb.id;
        opt.textContent = nb.name;
        if (nb.id === data.activeNotebookId) opt.selected = true;
        notebookSelect.appendChild(opt);
      });
    }

    function switchNotebook(id) {
      if (id === data.activeNotebookId) return;
      data.activeNotebookId = id;
      const nb = getActiveNotebook();
      if (!nb) return;
      data.activePageId = nb.pages[0]?.id || null;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function addNotebook() {
      const name = prompt("Name fÃ¼r das neue Notizbuch:", "Neues Notizbuch");
      if (!name) return;
      const nb = {
        id: "nb-" + Date.now(),
        name,
        pages: [{ id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }]
      };
      data.notebooks.push(nb);
      data.activeNotebookId = nb.id;
      data.activePageId = nb.pages[0].id;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function renderPageList() {
      const nb = getActiveNotebook();
      pageList.innerHTML = "";
      if (!nb) return;

      nb.pages.forEach((page, index) => {
        const div = document.createElement("div");
        div.className = "page-thumb" + (page.id === data.activePageId ? " active" : "");

        // Canvas-Vorschau
        const previewCanvas = document.createElement("canvas");
        previewCanvas.className = "page-thumb-canvas";
        const pw = 174, ph = 95;
        previewCanvas.width = pw;
        previewCanvas.height = ph;
        renderPageThumbnail(page, previewCanvas);
        div.appendChild(previewCanvas);

        // Label-Leiste
        const label = document.createElement("div");
        label.className = "page-thumb-label";
        const nameSpan = document.createElement("span");
        nameSpan.className = "page-thumb-name";
        nameSpan.textContent = page.name;
        const numSpan = document.createElement("span");
        numSpan.className = "page-thumb-num";
        numSpan.textContent = index + 1;
        label.appendChild(nameSpan);
        label.appendChild(numSpan);
        div.appendChild(label);

        // LÃ¶schen-Button
        const delBtn = document.createElement("button");
        delBtn.className = "page-thumb-delete";
        delBtn.innerHTML = "Ã—";
        delBtn.title = "Seite lÃ¶schen";
        delBtn.addEventListener("click", e => { e.stopPropagation(); deletePage(page.id); });
        div.appendChild(delBtn);

        // Seite auswÃ¤hlen
        div.addEventListener("click", () => {
          if (page.id === data.activePageId) return;
          data.activePageId = page.id;
          undoStack = []; redoStack = [];
          renderPageList();
          redrawActivePage();
          saveData();
        });

        // Doppelklick = Umbenennen
        div.addEventListener("dblclick", e => { e.stopPropagation(); renamePage(page.id); });

        // Rechtsklick = KontextmenÃ¼
        div.addEventListener("contextmenu", e => {
          e.preventDefault();
          showPageContextMenu(e, page.id);
        });

        // Long-Press auf Touch = LÃ¶schen-Button anzeigen
        let lpTimer = null;
        div.addEventListener("touchstart", () => {
          lpTimer = setTimeout(() => div.classList.add("show-delete"), 550);
        }, { passive: true });
        div.addEventListener("touchend", () => { clearTimeout(lpTimer); });
        div.addEventListener("touchmove", () => { clearTimeout(lpTimer); });

        pageList.appendChild(div);
      });

      const activePage = getActivePage();
      if (activePage) templateSelect.value = activePage.template || "blank";
    }

    // Rendert eine Seite auf ein kleines Thumbnail-Canvas
    function renderPageThumbnail(page, thumbCanvas) {
      const tctx = thumbCanvas.getContext("2d");
      const tw = thumbCanvas.width;
      const th = thumbCanvas.height;

      // WeiÃŸer Hintergrund
      tctx.fillStyle = "#fbfbff";
      tctx.fillRect(0, 0, tw, th);

      // Template fein zeichnen
      const spacing = 11;
      tctx.save();
      tctx.globalAlpha = 0.13;
      tctx.strokeStyle = "#666";
      tctx.lineWidth = 0.6;
      if (page.template === "lined") {
        for (let y = spacing; y < th; y += spacing) {
          tctx.beginPath(); tctx.moveTo(0, y); tctx.lineTo(tw, y); tctx.stroke();
        }
      } else if (page.template === "grid") {
        for (let y = spacing; y < th; y += spacing) {
          tctx.beginPath(); tctx.moveTo(0, y); tctx.lineTo(tw, y); tctx.stroke();
        }
        for (let x = spacing; x < tw; x += spacing) {
          tctx.beginPath(); tctx.moveTo(x, 0); tctx.lineTo(x, th); tctx.stroke();
        }
      } else if (page.template === "dotted") {
        tctx.fillStyle = "#666";
        for (let y = spacing; y < th; y += spacing)
          for (let x = spacing; x < tw; x += spacing) {
            tctx.beginPath(); tctx.arc(x, y, 0.9, 0, Math.PI * 2); tctx.fill();
          }
      }
      tctx.restore();

      // Strokes zeichnen (skaliert auf Thumbnail-GrÃ¶ÃŸe)
      if (!page.strokes || page.strokes.length === 0) return;
      const mainW = canvas.width || 800;
      const mainH = canvas.height || 600;

      page.strokes.forEach(stroke => {
        if (!stroke.points || stroke.points.length < 2) return;
        tctx.save();
        if (stroke.tool === "eraser") {
          tctx.globalCompositeOperation = "destination-out";
          tctx.strokeStyle = "rgba(0,0,0,1)";
        } else {
          tctx.strokeStyle = stroke.color || "#000";
          if (stroke.tool === "highlighter") tctx.globalAlpha = 0.35;
        }
        tctx.lineWidth = Math.max(0.5, (stroke.width || 2) * (tw / mainW));
        tctx.lineCap = "round";
        tctx.lineJoin = "round";
        tctx.beginPath();
        tctx.moveTo(stroke.points[0].x * tw, stroke.points[0].y * th);
        for (let i = 1; i < stroke.points.length; i++) {
          tctx.lineTo(stroke.points[i].x * tw, stroke.points[i].y * th);
        }
        tctx.stroke();
        tctx.restore();
      });
    }

    // KontextmenÃ¼ fÃ¼r Seiten
    function showPageContextMenu(evt, pageId) {
      let menu = document.getElementById("pageContextMenu");
      if (!menu) {
        menu = document.createElement("div");
        menu.id = "pageContextMenu";
        document.body.appendChild(menu);
      }
      menu.innerHTML = `
        <div class="ctx-menu-item" data-action="rename">âœï¸ Umbenennen</div>
        <div class="ctx-menu-item" data-action="duplicate">ğŸ“‹ Duplizieren</div>
        <div class="ctx-menu-item danger" data-action="delete">ğŸ—‘ï¸ LÃ¶schen</div>
      `;
      menu.style.display = "block";
      menu.style.left = Math.min(evt.clientX, window.innerWidth - 160) + "px";
      menu.style.top = Math.min(evt.clientY, window.innerHeight - 120) + "px";

      menu.querySelectorAll(".ctx-menu-item").forEach(item => {
        item.addEventListener("click", () => {
          const action = item.dataset.action;
          if (action === "rename") renamePage(pageId);
          else if (action === "duplicate") duplicatePage(pageId);
          else if (action === "delete") deletePage(pageId);
          menu.style.display = "none";
        });
      });

      const hide = e => { if (!menu.contains(e.target)) { menu.style.display = "none"; document.removeEventListener("click", hide); } };
      setTimeout(() => document.addEventListener("click", hide), 0);
    }

    function addPage() {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = {
        id: "p-" + Date.now(),
        name: "Seite " + (nb.pages.length + 1),
        template: templateSelect.value || "blank",
        strokes: []
      };
      nb.pages.push(page);
      data.activePageId = page.id;
      undoStack = [];
      redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function setPageTemplate(template) {
      const page = getActivePage();
      if (!page) return;
      page.template = template;
      redrawActivePage();
      saveData();
    }

    function deletePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      if (nb.pages.length <= 1) {
        alert("Du kannst die letzte Seite nicht lÃ¶schen.");
        return;
      }
      if (!confirm("Diese Seite wirklich lÃ¶schen?")) return;
      const idx = nb.pages.findIndex(p => p.id === pageId);
      nb.pages.splice(idx, 1);
      if (data.activePageId === pageId) {
        data.activePageId = nb.pages[Math.max(0, idx - 1)].id;
      }
      undoStack = []; redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function renamePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = nb.pages.find(p => p.id === pageId);
      if (!page) return;
      const name = prompt("Seitenname:", page.name);
      if (!name || name.trim() === page.name) return;
      page.name = name.trim();
      renderPageList();
      saveData();
    }

    function duplicatePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = nb.pages.find(p => p.id === pageId);
      if (!page) return;
      const copy = JSON.parse(JSON.stringify(page));
      copy.id = "p-" + Date.now();
      copy.name = page.name + " (Kopie)";
      const idx = nb.pages.findIndex(p => p.id === pageId);
      nb.pages.splice(idx + 1, 0, copy);
      data.activePageId = copy.id;
      undoStack = []; redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function deleteNotebook() {
      if (data.notebooks.length <= 1) {
        alert("Das letzte Notizbuch kann nicht gelÃ¶scht werden.");
        return;
      }
      const nb = getActiveNotebook();
      if (!nb) return;
      if (!confirm(`Notizbuch "${nb.name}" wirklich lÃ¶schen?\nAlle ${nb.pages.length} Seite(n) gehen verloren.`)) return;
      const idx = data.notebooks.findIndex(n => n.id === nb.id);
      data.notebooks.splice(idx, 1);
      data.activeNotebookId = data.notebooks[Math.max(0, idx - 1)].id;
      const newNb = getActiveNotebook();
      data.activePageId = newNb?.pages[0]?.id || null;
      undoStack = []; redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function renameNotebook() {
      const nb = getActiveNotebook();
      if (!nb) return;
      const name = prompt("Notizbuch umbenennen:", nb.name);
      if (!name || name.trim() === nb.name) return;
      nb.name = name.trim();
      renderNotebookSelect();
      saveData();
    }


    function resizeCanvas() {
  const container = document.getElementById("canvasContainer") || document.getElementById("canvasWrapper");
  const margin = 12;
  const w = container.clientWidth - margin * 2;
  const h = container.clientHeight - margin * 2;

  const aspect = 1 / 1.414; // A4-Querformat
  let cw = w, ch = w / aspect;
  if (ch > h) { ch = h; cw = h * aspect; }
  cw = Math.max(200, Math.round(cw));
  ch = Math.max(200, Math.round(ch));

  const page = getActivePage();
  const oldStrokes = page ? JSON.parse(JSON.stringify(page.strokes)) : null;
  const tmpl = page ? page.template : "blank";

  canvas.width = cw;
  canvas.height = ch;

  // Zoom & Pan beim Resize zurÃ¼cksetzen
  zoom = 1; panX = 0; panY = 0;
  updateCanvasTransform();

  if (page && oldStrokes) {
    page.strokes = oldStrokes;
    page.template = tmpl;
  }
  redrawActivePage();
}


    window.addEventListener("resize", resizeCanvas);

function getTemplateSpacing() {
  const base = 32; // deine bisherige StandardgrÃ¶ÃŸe

  switch (data.templateScale) {
    case "small":
      return base * 0.6;   // ca. 19 px â€“ fein wie GoodNotes
    case "large":
      return base * 1.3;   // ca. 42 px â€“ groÃŸe KÃ¤stchen
    case "medium":
    default:
      return base;         // Standard
  }
}


    function drawTemplate(template) {
  const w = canvas.width, h = canvas.height;
  const spacing = getTemplateSpacing();    // ğŸ‘ˆ NEU

  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = "#7a7a7a";
  ctx.lineWidth = 1;

  if (template === "lined") {
    const lineSpacing = spacing;
    for (let y = lineSpacing; y < h; y += lineSpacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }

  } else if (template === "dotted") {
    for (let y = spacing; y < h; y += spacing) {
      for (let x = spacing; x < w; x += spacing) {
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fillStyle = "#7a7a7a";
        ctx.fill();
      }
    }

  } else if (template === "grid") {
    for (let y = spacing; y < h; y += spacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }
    for (let x = spacing; x < w; x += spacing) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, h);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// Zeichnet das Seitenraster als CSS-Hintergrund des Canvas.
// CSS-HintergrÃ¼nde skalieren vektorbasiert â†’ kein UnschÃ¤rfen beim Zoomen.
function updateTemplateBackground(template) {
  const s = getTemplateSpacing();
  const c = "rgba(122,122,122,0.15)";
  canvas.style.backgroundRepeat = "repeat";
  canvas.style.backgroundSize  = "auto";

  if (template === "lined") {
    canvas.style.backgroundImage =
      `repeating-linear-gradient(to bottom, transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px)`;

  } else if (template === "grid") {
    canvas.style.backgroundImage =
      `repeating-linear-gradient(to bottom, transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px),` +
      `repeating-linear-gradient(to right,  transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px)`;

  } else if (template === "dotted") {
    const half = s / 2;
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${s}' height='${s}'>`
               + `<circle cx='${half}' cy='${half}' r='1.5' fill='rgba(122,122,122,0.6)'/></svg>`;
    canvas.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}")`;
    canvas.style.backgroundSize  = `${s}px ${s}px`;

  } else {
    canvas.style.backgroundImage = "none";
  }
}

function redrawActivePage() {
  const page = getActivePage();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!page) { updateTemplateBackground("blank"); return; }

  // 1. Erst alle Strokes zeichnen (Stift, Marker, Radierer)
  page.strokes.forEach(stroke => {
    ctx.save();

    if (stroke.tool === "eraser") {
      // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    } else if (stroke.tool === "highlighter") {
      // Halbtransparent wie echter Textmarker
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 0.35; // Transparent
    } else {
      // Normaler Stift
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    }

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const pts = stroke.points;
    if (pts.length > 1) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x * canvas.width, pts[0].y * canvas.height);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x * canvas.width, pts[i].y * canvas.height);
      }
      ctx.stroke();
    }

    ctx.restore();
  });

  // Reset
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  // 2. Template als scharfes CSS-Hintergrundmuster (bleibt beim Zoomen scharf)
  updateTemplateBackground(page.template || "blank");
}

function previewShape(endPos) {
  // Wenn wir keine Startposition haben, kÃ¶nnen wir nichts anzeigen
  if (!shapeStartPos) return;

  const start = shapeStartPos;
  const end = endPos;

  // Erst die Seite normal zeichnen
  redrawActivePage();

  ctx.save();

  // Zeichenstil fÃ¼r die Vorschau
  ctx.globalCompositeOperation = "source-over";
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentWidth;
  ctx.globalAlpha = 1;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  // Optional: gestrichelt, damit man sieht: das ist nur Vorschau
  ctx.setLineDash([6, 4]);

  const sx = start.x * canvas.width;
  const sy = start.y * canvas.height;
  const ex = end.x * canvas.width;
  const ey = end.y * canvas.height;

  if (currentTool === "line") {
    // Gerade Linie
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

  } else if (currentTool === "rect") {
    // Rechteck aus zwei Eckpunkten
    const x = Math.min(sx, ex);
    const y = Math.min(sy, ey);
    const w = Math.abs(ex - sx);
    const h = Math.abs(ey - sy);

    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.stroke();

  } else if (currentTool === "circle") {
    // Ellipse/Kreis
    const cx = (sx + ex) / 2;
    const cy = (sy + ey) / 2;
    const rx = Math.abs(ex - sx) / 2;
    const ry = Math.abs(ey - sy) / 2;

    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
    ctx.stroke();
  }

  ctx.restore();
}


   function normPos(evt) {
         const rect = canvas.getBoundingClientRect();
         let clientX, clientY;

  if (evt.touches && evt.touches.length > 0) {
          clientX = evt.touches[0].clientX;
          clientY = evt.touches[0].clientY;
  } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
  }

  const x = (clientX - rect.left) / rect.width;
  const y = (clientY - rect.top) / rect.height;
  return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
}

// Abstand zwischen zwei Fingern
// Abstand zwischen zwei Fingern
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.hypot(dx, dy);
}

// Mittelpunkt der zwei Finger
function getTouchCenter(touches) {
  return {
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  };
}

// Gibt true zurÃ¼ck wenn der Touch ein Apple Pencil (Stylus) ist.
// Nutzt Safari-spezifisches Touch.touchType â€“ auf anderen Browsern immer false.
function isStylusTouch(touch) {
  return typeof touch.touchType !== "undefined" && touch.touchType === "stylus";
}

// Entscheidet: Zeichnen oder Scrollen fÃ¼r einen einzelnen Touch.
// Auf Safari: Stylus â†’ zeichnen, Finger â†’ scrollen (unabhÃ¤ngig von touchMode-Button).
// Auf anderen Browsern: Fallback auf touchMode-Variable.
function shouldDrawTouch(touch) {
  if (typeof touch.touchType !== "undefined") {
    return touch.touchType === "stylus";
  }
  return touchMode === "draw";
}

function handleTouchStart(e) {
  if (!e.touches || e.touches.length === 0) return;
  e.preventDefault();

  if (e.touches.length === 1) {
    isPinching = false;
    if (shouldDrawTouch(e.touches[0])) {
      startDrawing(e);
    } else {
      // Finger-Touch â†’ Canvas verschieben
      panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  } else if (e.touches.length === 2) {
    // 2 Finger = Pinch-Zoom & Pan
    isPinching = true;
    if (drawing) { drawing = false; currentStroke = null; } // Zeichnen abbrechen
    lastPinchDist = getTouchDistance(e.touches);
    lastPinchCenter = getTouchCenter(e.touches);
  }
}

function handleTouchMove(e) {
  if (!e.touches || e.touches.length === 0) return;

  if (isPinching && e.touches.length === 2) {
    e.preventDefault();
    const newDist = getTouchDistance(e.touches);
    const newCenter = getTouchCenter(e.touches);

    if (lastPinchDist > 0 && lastPinchCenter) {
      const scaleChange = newDist / lastPinchDist;
      const oldZoom = zoom;
      zoom = Math.max(0.4, Math.min(5, zoom * scaleChange));

      // Canvas-Mittelpunkt in Bildschirmkoordinaten
      const rect = canvas.getBoundingClientRect();
      const screenCX = rect.left + rect.width / 2;
      const screenCY = rect.top + rect.height / 2;

      // Pan so anpassen, dass der Pinch-Punkt bleibt
      panX += (lastPinchCenter.x - screenCX) * (1 - zoom / oldZoom);
      panY += (lastPinchCenter.y - screenCY) * (1 - zoom / oldZoom);

      // Finger-Bewegung als Pan Ã¼bernehmen
      panX += newCenter.x - lastPinchCenter.x;
      panY += newCenter.y - lastPinchCenter.y;
    }

    lastPinchDist = newDist;
    lastPinchCenter = newCenter;
    updateCanvasTransform();

  } else if (!isPinching && e.touches.length === 1) {
    if (shouldDrawTouch(e.touches[0])) {
      moveDrawing(e);
    } else {
      // Finger-Touch Pan
      e.preventDefault();
      if (panStart) {
        panX += e.touches[0].clientX - panStart.x;
        panY += e.touches[0].clientY - panStart.y;
        panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        updateCanvasTransform();
      }
    }
  }
}

function handleTouchEnd(e) {
  if (isPinching && (!e.touches || e.touches.length < 2)) {
    isPinching = false;
    lastPinchDist = 0;
    lastPinchCenter = null;
  }
  if (!e.touches || e.touches.length === 0) {
    panStart = null;
    stopDrawing(e);
  }
}

    function startDrawing(evt) {
  evt.preventDefault();
  const page = getActivePage();
  if (!page) return;

  drawing = true;
  redoStack = [];

  const p = normPos(evt);
  lastPos = p;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // Formen: Startpunkt merken, Stroke nur als â€Platzhalterâ€œ
    shapeStartPos = p;
    currentStroke = {
      tool: "pen",
      color: currentColor,
      width: currentWidth,
      alpha: 1,
      points: [p]
    };
  } else {
    // Freihand-Stift / Marker / Radierer
    const stroke = {
      tool: currentTool,
      color: currentColor,
      // Marker bewusst dicker, wirkt mehr wie echter Textmarker
      width: currentTool === "highlighter" ? currentWidth * 4 : currentWidth,
      alpha: 1,
      points: [p]
    };

    if (currentTool === "eraser") {
      stroke.color = "#000000";
    }

    currentStroke = stroke;
    drawStrokeSegment(lastPos, p, stroke);
  }
}

function drawStrokeSegment(from, to, stroke) {
  ctx.save();

  if (stroke.tool === "eraser") {
    // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  } else if (stroke.tool === "highlighter") {
    // Halbtransparent wie echter Textmarker
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 0.35; // Transparent
  } else {
    // Normaler Stift
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  }

  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  ctx.beginPath();
  ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
  ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
  ctx.stroke();

  ctx.restore();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}


function moveDrawing(evt) {
  if (!drawing || !currentStroke) return;
  evt.preventDefault();

  const raw = normPos(evt);

  // FÃ¼r Linien/Rechteck/Kreis keine GlÃ¤ttung, nur Vorschau
  if (["line", "rect", "circle"].includes(currentTool)) {
    previewShape(raw);
    lastPos = raw;
    return;
  }

  // GlÃ¤ttung: Mischung aus alter und neuer Position (fÃ¼hlt sich noch direkt an)
  const p = {
    x: lastPos.x * 0.35 + raw.x * 0.65,
    y: lastPos.y * 0.35 + raw.y * 0.65
  };

  // Winzige Bewegungen ignorieren â†’ weniger Zittern
  const dx = p.x - lastPos.x;
  const dy = p.y - lastPos.y;
  const dist2 = dx * dx + dy * dy;
  if (dist2 < 0.000004) {
    return;
  }

  drawStrokeSegment(lastPos, p, currentStroke);
  currentStroke.points.push(p);
  lastPos = p;
}

function stopDrawing(evt) {
  if (!drawing) return;
  drawing = false;

  const page = getActivePage();
  if (!page || !currentStroke) return;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // finale Form als Punkte approximieren
    const start = shapeStartPos;
    const end = lastPos;
    let points = [];

    if (currentTool === "line") {
      points = [start, end];
    } else if (currentTool === "rect") {
      const xs = [start.x, end.x].sort((a, b) => a - b);
      const ys = [start.y, end.y].sort((a, b) => a - b);
      const xL = xs[0], xR = xs[1], yT = ys[0], yB = ys[1];
      points = [
        { x: xL, y: yT },
        { x: xR, y: yT },
        { x: xR, y: yB },
        { x: xL, y: yB },
        { x: xL, y: yT }
      ];
    } else if (currentTool === "circle") {
      const steps = 40;
      const cx = (start.x + end.x) / 2;
      const cy = (start.y + end.y) / 2;
      const rx = Math.abs(end.x - start.x) / 2;
      const ry = Math.abs(end.y - start.y) / 2;
      points = [];
      for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * 2 * Math.PI;
        points.push({
          x: cx + rx * Math.cos(t),
          y: cy + ry * Math.sin(t)
        });
      }
    }

    currentStroke.points = points;
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    shapeStartPos = null;
    redrawActivePage();
  } else {
    // Freihand-Stift / Marker / Radierer
    if (currentStroke.points.length < 2) {
      currentStroke.points.push({ ...currentStroke.points[0] });
    }
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    // Nach jedem Freihand-Strich alles neu zeichnen
    redrawActivePage();
  }

  currentStroke = null;
  saveData();
}



    function doUndo() {
      const page = getActivePage();
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      redoStack.push(stroke);
      undoStack.pop();
      redrawActivePage();
      saveData();
    }

    function doRedo() {
      const page = getActivePage();
      if (!page || redoStack.length === 0) return;
      const stroke = redoStack.pop();
      page.strokes.push(stroke);
      undoStack.push(stroke);
      redrawActivePage();
      saveData();
    }

    function clearPage() {
      const page = getActivePage();
      if (!page) return;
      if (!confirm("Diese Seite wirklich komplett leeren?")) return;
      page.strokes = [];
      undoStack = [];
      redoStack = [];
      redrawActivePage();
      saveData();
    }

    function exportPageAsPNG() {
      const page = getActivePage();
      if (!page) return;
      const link = document.createElement("a");
      link.href = canvas.toDataURL("image/png");
      link.download = (page.name || "Seite") + ".png";
      link.click();
    }

    // Canvas Events (Maus)
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", moveDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseleave", stopDrawing);


// Canvas Events (Touch â€“ 1 Finger = zeichnen, 2 Finger = Pinch-Zoom)
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove",  handleTouchMove,  { passive: false });
canvas.addEventListener("touchend",   handleTouchEnd,   { passive: false });
canvas.addEventListener("touchcancel",handleTouchEnd,   { passive: false });




    toolButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        toolButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentTool = btn.getAttribute("data-tool");
      });
    });

    colorPicker.addEventListener("input", () => {
      currentColor = colorPicker.value;
    });

    strokeButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        strokeButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentWidth = parseInt(btn.getAttribute("data-width"), 10);
      });
    });

    undoBtn.addEventListener("click", doUndo);
    redoBtn.addEventListener("click", doRedo);
    clearBtn.addEventListener("click", clearPage);
    addNotebookBtn.addEventListener("click", addNotebook);
    notebookSelect.addEventListener("change", e => switchNotebook(e.target.value));
    addPageBtn.addEventListener("click", addPage);
    templateSelect.addEventListener("change", e => setPageTemplate(e.target.value));
    exportPageBtn.addEventListener("click", exportPageAsPNG);

    // Notebook lÃ¶schen
    const deleteNotebookBtn = document.getElementById("deleteNotebookBtn");
    if (deleteNotebookBtn) deleteNotebookBtn.addEventListener("click", deleteNotebook);

    // Sidebar Toggle
    const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
    if (sidebarToggleBtn) {
      sidebarToggleBtn.addEventListener("click", () => {
        const collapsed = sidebarNotes.classList.toggle("collapsed");
        sidebarToggleBtn.textContent = collapsed ? "â–¶" : "â—€";
        sidebarToggleBtn.style.left = collapsed ? "0" : "0";
        setTimeout(resizeCanvas, 250); // Canvas nach Animation neu berechnen
      });
    }

    // Zoom-Buttons
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const zoomResetBtn = document.getElementById("zoomResetBtn");
    if (zoomInBtn) zoomInBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomToPoint(rect.left + rect.width/2, rect.top + rect.height/2, 1.3);
    });
    if (zoomOutBtn) zoomOutBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomToPoint(rect.left + rect.width/2, rect.top + rect.height/2, 1/1.3);
    });
    if (zoomResetBtn) zoomResetBtn.addEventListener("click", resetZoom);

    // Touch-Modus Toggle (Zeichnen â†” Scrollen)
    const touchModeBtn = document.getElementById("touchModeBtn");
    if (touchModeBtn) {
      touchModeBtn.addEventListener("click", () => {
        touchMode = touchMode === "draw" ? "scroll" : "draw";
        touchModeBtn.textContent = touchMode === "draw" ? "âœï¸" : "ğŸ‘†";
        touchModeBtn.classList.toggle("scroll-mode", touchMode === "scroll");
        touchModeBtn.title = touchMode === "draw" ? "Touch-Modus: Zeichnen (klicken fÃ¼r Scrollen)" : "Touch-Modus: Scrollen (klicken fÃ¼r Zeichnen)";
      });
    }

    // Scroll-Zoom mit Mausrad (Desktop/Magic Trackpad)
    const canvasContainer = document.getElementById("canvasContainer");
    if (canvasContainer) {
      canvasContainer.addEventListener("wheel", e => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
        zoomToPoint(e.clientX, e.clientY, factor);
      }, { passive: false });
    }

    // TastaturkÃ¼rzel
    document.addEventListener("keydown", e => {
      if (e.target !== document.body && e.target.tagName !== "CANVAS") return;
      if ((e.ctrlKey || e.metaKey) && e.key === "z") { e.preventDefault(); doUndo(); }
      if ((e.ctrlKey || e.metaKey) && (e.key === "y" || (e.shiftKey && e.key === "z"))) { e.preventDefault(); doRedo(); }
      if ((e.ctrlKey || e.metaKey) && e.key === "0") { e.preventDefault(); resetZoom(); }
      if ((e.ctrlKey || e.metaKey) && e.key === "=") { e.preventDefault(); zoomToPoint(window.innerWidth/2, window.innerHeight/2, 1.3); }
      if ((e.ctrlKey || e.metaKey) && e.key === "-") { e.preventDefault(); zoomToPoint(window.innerWidth/2, window.innerHeight/2, 1/1.3); }
    });

    // RastergrÃ¶ÃŸe Ã¤ndern
if (templateSizeSelect) {
  // Beim Start auf gespeicherten Wert setzen
  templateSizeSelect.value = data.templateScale || "medium";

  templateSizeSelect.addEventListener("change", (e) => {
    data.templateScale = e.target.value;  // "small" | "medium" | "large"
    saveData();
    redrawActivePage();                   // Canvas neu zeichnen mit neuer GrÃ¶ÃŸe
  });
}


    // Backup
    exportJsonBtn.addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "uni-hyper-notes-backup.json";
      a.click();
      URL.revokeObjectURL(url);
    });
// Backup laden (Import)
importJsonBtn.addEventListener("click", () => {
  importJsonInput.value = "";      // evtl. alte Auswahl zurÃ¼cksetzen
  importJsonInput.click();         // Datei-Dialog Ã¶ffnen
});

importJsonInput.addEventListener("change", () => {
  const file = importJsonInput.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);

      // Ganz grobe PlausibilitÃ¤tsprÃ¼fung
      if (!imported || !Array.isArray(imported.notebooks)) {
        alert("Diese Datei sieht nicht wie ein Uni-Hyper-Notes-Backup aus.");
        return;
      }

      // Unsere globale data ersetzen
      data = imported;

      // Sicherheitshalber: falls alte Backups ein paar Felder nicht hatten
      if (!data.cards) data.cards = { decks: [] };
      if (!data.planner) data.planner = { exams: [], focusSessions: [] };
      if (!data.formulas) data.formulas = [];
      if (!data.tasks) data.tasks = [];
      if (!data.brain) data.brain = { entries: [] };
      if (!data.theme) data.theme = "dark";

      // Aktive IDs setzen, falls fehlen
      if (!data.activeNotebookId && data.notebooks[0]) {
        data.activeNotebookId = data.notebooks[0].id;
      }
      const nb = data.notebooks.find(nb => nb.id === data.activeNotebookId) || data.notebooks[0];
      if (nb && !data.activePageId && nb.pages[0]) {
        data.activePageId = nb.pages[0].id;
      }

      // In localStorage speichern
      saveData();

      // UI komplett neu aufbauen
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      // renderDecks() - handled by Karteikarten2 separately
      // renderExams() â€“ moved to Planner.html iframe
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();
      renderLearnSubjects();
      renderLearnTopics();
      renderLearnContent();

      alert("Backup wurde erfolgreich geladen âœ…");

    } catch (err) {
      console.error(err);
      alert("Fehler beim Laden des Backups. Bist du sicher, dass es die richtige Datei ist?");
    }
  };

  reader.readAsText(file, "utf-8");
});

    // ---------- KARTEIKARTEN (old - replaced by Karteikarten2) ----------
    /* OLD CARDS CODE REMOVED */

    // ---------- PLANER ----------
    // Planner is now a separate Planner.html loaded via iframe â€“ no JS needed here.

    // ---------- FORMELN ----------
    const formulaName = document.getElementById("formulaName");
    const formulaExpression = document.getElementById("formulaExpression");
    const formulaTopic = document.getElementById("formulaTopic");
    const formulaVariables = document.getElementById("formulaVariables");
    const formulaNotes = document.getElementById("formulaNotes");
    const addFormulaBtn = document.getElementById("addFormulaBtn");
    const loadBiotechFormulasBtn = document.getElementById("loadBiotechFormulasBtn");
    const formulaFilter = document.getElementById("formulaFilter");
    const formulaListDiv = document.getElementById("formulaList");

    function renderFormulas() {
      const q = formulaFilter.value.toLowerCase();
      formulaListDiv.innerHTML = "";
      data.formulas
        .filter(f =>
          !q ||
          f.name.toLowerCase().includes(q) ||
          (f.topic || "").toLowerCase().includes(q)
        )
        .forEach(f => {
          const div = document.createElement("div");
          div.className = "card";
          div.innerHTML = `
            <div style="font-weight:600;">${f.name}</div>
            <div style="margin-top:4px;">${f.expression}</div>
            <div style="margin-top:4px; font-size:12px;">
              Thema: <span class="pill">${f.topic || "-"}</span>
            </div>
            <div style="margin-top:4px; font-size:12px; opacity:0.8;">
              Variablen: ${f.variables || "-"}
            </div>
            <div style="margin-top:4px; font-size:12px;">${f.notes || ""}</div>`;
          formulaListDiv.appendChild(div);
        });
    }

    function addFormula() {
      const name = formulaName.value.trim();
      const expr = formulaExpression.value.trim();
      if (!name || !expr) return;
      data.formulas.push({
        id: "formula-" + Date.now(),
        name,
        expression: expr,
        topic: formulaTopic.value.trim(),
        variables: formulaVariables.value.trim(),
        notes: formulaNotes.value.trim()
      });
      formulaName.value = "";
      formulaExpression.value = "";
      formulaTopic.value = "";
      formulaVariables.value = "";
      formulaNotes.value = "";
      saveData();
      renderFormulas();
    }

    function loadBiotechFormulas() {
      const presets = [
        {
          name: "Ideale Gasgleichung",
          expression: "p Â· V = n Â· R Â· T",
          topic: "Allgemeine Chemie / Gase",
          variables: "p [Pa], V [mÂ³], n [mol], R = 8,314 JÂ·molâ»Â¹Â·Kâ»Â¹, T [K]",
          notes: "Grundformel fÃ¼r ideale Gase. In PC/Allg. Chemie oft umstellen nach p, V, n oder T."
        },
        {
          name: "Arrhenius-Gleichung",
          expression: "k = A Â· e^(âˆ’Eâ‚ / (R Â· T))",
          topic: "Allgemeine Chemie / Kinetik",
          variables: "k [1/s], A: Frequenzfaktor, Eâ‚ [J/mol], R, T [K]",
          notes: "Beschreibt TemperaturabhÃ¤ngigkeit der Reaktionsgeschwindigkeit."
        },
        {
          name: "Lambert-Beer-Gesetz",
          expression: "A = Îµ Â· c Â· l",
          topic: "Analytik / Spektroskopie",
          variables: "A: Absorption, Îµ [LÂ·molâ»Â¹Â·cmâ»Â¹], c [mol/L], l [cm]",
          notes: "Standard zur Konzentrationsbestimmung mit Photometer."
        },
        {
          name: "Henderson-Hasselbalch",
          expression: "pH = pKâ‚ + log10([Aâ»]/[HA])",
          topic: "Allgemeine Chemie / SÃ¤ure-Base",
          variables: "[Aâ»]: konjugierte Base, [HA]: SÃ¤ure",
          notes: "Wichtig zur Berechnung von PufferlÃ¶sungen."
        },
        {
          name: "VerdÃ¼nnungsgleichung",
          expression: "câ‚ Â· Vâ‚ = câ‚‚ Â· Vâ‚‚",
          topic: "Allgemeine Chemie / LÃ¶sungen",
          variables: "c in [mol/L], V in [L]",
          notes: "Basis beim Ansetzen und VerdÃ¼nnen von LÃ¶sungen."
        },
        {
          name: "Stoffmenge",
          expression: "n = m / M",
          topic: "Allgemeine Chemie / Grundlagen",
          variables: "n [mol], m [g], M [g/mol]",
          notes: "Elementare Umrechnung zwischen Masse und Stoffmenge."
        }
      ];

      presets.forEach(f => {
        const exists = data.formulas.some(ex => ex.name === f.name);
        if (!exists) {
          data.formulas.push({
            id: "formula-" + Date.now() + "-" + Math.random().toString(36).slice(2),
            name: f.name,
            expression: f.expression,
            topic: f.topic,
            variables: f.variables,
            notes: f.notes
          });
        }
      });

      saveData();
      renderFormulas();
      alert("Biotech/Allg.-Chemie-Basisformeln wurden hinzugefÃ¼gt (wo sie noch gefehlt haben).");
    }

    addFormulaBtn.addEventListener("click", addFormula);
    formulaFilter.addEventListener("input", renderFormulas);
    loadBiotechFormulasBtn.addEventListener("click", loadBiotechFormulas);

    // ---------- TOOLS / RECHENTOOL ----------
    const toolFormulaSelect = document.getElementById("toolFormulaSelect");
    const toolInputs = document.getElementById("toolInputs");
    const toolCalcBtn = document.getElementById("toolCalcBtn");
    const toolResult = document.getElementById("toolResult");

    function renderToolInputs() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="dil_c1" placeholder="câ‚ (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="dil_v1" placeholder="Vâ‚"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="dil_c2" placeholder="câ‚‚"></div>
            <div><input type="number" step="any" id="dil_v2" placeholder="Vâ‚‚"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Hinweis: Eine der GrÃ¶ÃŸen (câ‚, Vâ‚, câ‚‚ oder Vâ‚‚) leer lassen, dann wird sie berechnet. Einheiten mÃ¼ssen zueinander passen.</div>
        `;
      } else if (mode === "lambert") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="lam_A" placeholder="A (Absorption)"></div>
            <div><input type="number" step="any" id="lam_eps" placeholder="Îµ (z.B. LÂ·molâ»Â¹Â·cmâ»Â¹)"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="lam_c" placeholder="c [mol/L] (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="lam_l" placeholder="l [cm]"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Lambert-Beer: A = Îµ Â· c Â· l. Eine der GrÃ¶ÃŸen (meist c) leer lassen, dann wird sie berechnet.</div>
        `;
      }
    }

    function calcTool() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        const c1 = parseFloat(document.getElementById("dil_c1").value);
        const v1 = parseFloat(document.getElementById("dil_v1").value);
        const c2 = parseFloat(document.getElementById("dil_c2").value);
        const v2 = parseFloat(document.getElementById("dil_v2").value);

        const vals = { c1, v1, c2, v2 };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE GrÃ¶ÃŸe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "c1") result = c2 * v2 / v1;
          else if (missing === "v1") result = c2 * v2 / c1;
          else if (missing === "c2") result = c1 * v1 / v2;
          else if (missing === "v2") result = c1 * v1 / c2;
        } catch {
          toolResult.textContent = "Rechenfehler â€“ bitte Eingaben prÃ¼fen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      } else if (mode === "lambert") {
        const A = parseFloat(document.getElementById("lam_A").value);
        const eps = parseFloat(document.getElementById("lam_eps").value);
        const c = parseFloat(document.getElementById("lam_c").value);
        const l = parseFloat(document.getElementById("lam_l").value);

        const vals = { A, eps, c, l };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE GrÃ¶ÃŸe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "A") result = eps * c * l;
          else if (missing === "eps") result = A / (c * l);
          else if (missing === "c") result = A / (eps * l);
          else if (missing === "l") result = A / (eps * c);
        } catch {
          toolResult.textContent = "Rechenfehler â€“ bitte Eingaben prÃ¼fen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      }
    }

    toolFormulaSelect.addEventListener("change", renderToolInputs);
    toolCalcBtn.addEventListener("click", calcTool);

    // ---------- AUFGABEN ----------
    const taskTitle = document.getElementById("taskTitle");
    const taskTopic = document.getElementById("taskTopic");
    const taskText = document.getElementById("taskText");
    const taskNotes = document.getElementById("taskNotes");
    const addTaskBtn = document.getElementById("addTaskBtn");
    const taskListDiv = document.getElementById("taskList");

    function renderTasks() {
      taskListDiv.innerHTML = "";
      data.tasks.forEach(t => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div><strong>${t.title}</strong></div>
            <div>
              <span class="pill">${t.topic || "-"}</span>
              <select data-id="${t.id}" class="taskStatusSel">
                <option value="open" ${t.status === "open" ? "selected" : ""}>unsicher</option>
                <option value="ok" ${t.status === "ok" ? "selected" : ""}>geht so</option>
                <option value="done" ${t.status === "done" ? "selected" : ""}>sicher</option>
              </select>
            </div>
          </div>
          <div style="margin-top:4px; font-size:13px; white-space:pre-wrap;">${t.text}</div>
          <div style="margin-top:4px; font-size:12px; opacity:0.8; white-space:pre-wrap;">${t.notes || ""}</div>`;
        taskListDiv.appendChild(div);
      });
      document.querySelectorAll(".taskStatusSel").forEach(sel => {
        sel.addEventListener("change", evt => {
          const id = evt.target.getAttribute("data-id");
          const task = data.tasks.find(tt => tt.id === id);
          if (!task) return;
          task.status = evt.target.value;
          saveData();
        });
      });
    }

    function addTask() {
      const title = taskTitle.value.trim();
      const text = taskText.value.trim();
      if (!title || !text) return;
      data.tasks.push({
        id: "task-" + Date.now(),
        title,
        topic: taskTopic.value.trim(),
        text,
        notes: taskNotes.value.trim(),
        status: "open"
      });
      taskTitle.value = "";
      taskTopic.value = "";
      taskText.value = "";
      taskNotes.value = "";
      saveData();
      renderTasks();
    }

    addTaskBtn.addEventListener("click", addTask);

    // ---------- BRAIN-DUMP ----------
    const brainText = document.getElementById("brainText");
    const saveBrainBtn = document.getElementById("saveBrainBtn");
    const brainStatus = document.getElementById("brainStatus");
    const brainHistory = document.getElementById("brainHistory");

    function renderBrainHistory() {
      brainHistory.innerHTML = "";
      const entries = data.brain.entries.slice().sort((a, b) => b.date - a.date);
      entries.forEach(e => {
        const div = document.createElement("div");
        div.className = "card";
        const d = new Date(e.date);
        div.innerHTML = `
          <div style="font-size:12px; opacity:0.7;">${d.toLocaleString()}</div>
          <div style="margin-top:4px; white-space:pre-wrap;">${e.text}</div>`;
        brainHistory.appendChild(div);
      });
    }

    function saveBrainEntry() {
      const text = brainText.value.trim();
      if (!text) return;
      data.brain.entries.push({ id: "brain-" + Date.now(), text, date: Date.now() });
      brainText.value = "";
      brainStatus.textContent = "Gespeichert.";
      setTimeout(() => (brainStatus.textContent = ""), 2000);
      saveData();
      renderBrainHistory();
    }

    saveBrainBtn.addEventListener("click", saveBrainEntry);

    // ---------- STATS ----------
    const statsContent = document.getElementById("statsContent");

    function renderStats() {
      const sessions = (data.planner && data.planner.focusSessions) ? data.planner.focusSessions : [];
      if (sessions.length === 0) {
        statsContent.textContent = "Fokus-Sessions werden jetzt im Planner-Tab erfasst.";
        return;
      }
      const totalMinutes = sessions.reduce((sum, s) => sum + (s.minutes || 0), 0);
      const byTopic = {};
      sessions.forEach(s => {
        const t = s.topic || "Sonstiges";
        byTopic[t] = (byTopic[t] || 0) + (s.minutes || 0);
      });
      let html = `<div>Gesamt-Lernzeit (nur Fokus-BlÃ¶cke): <strong>${totalMinutes} Minuten</strong></div>`;
      html += `<div style="margin-top:6px;">Verteilung nach Themen:</div>`;
      html += `<ul style="padding-left:16px; margin-top:4px;">`;
      Object.keys(byTopic).forEach(t => {
        html += `<li>${t}: ${byTopic[t]} Min</li>`;
      });
      html += `</ul>`;
      statsContent.innerHTML = html;
    }

    // ---------- LERNEN ----------
    const learnSubjectsUl = document.getElementById("learnSubjects");
    const learnTopicsUl = document.getElementById("learnTopics");
    const learnContentDiv = document.getElementById("learnContent");
    let currentSubjectId = "allg-chem";
    let currentTopicId = "aufbau-materie";

    function renderLearnSubjects() {
      learnSubjectsUl.innerHTML = "";
      learnData.subjects.forEach(sub => {
        const li = document.createElement("li");
        li.className = "learn-item" + (sub.id === currentSubjectId ? " active" : "");
        li.textContent = sub.name;
        li.addEventListener("click", () => {
          currentSubjectId = sub.id;
          const firstTopic = sub.topics[0];
          if (firstTopic) currentTopicId = firstTopic.id;
          renderLearnSubjects();
          renderLearnTopics();
          renderLearnContent();
        });
        learnSubjectsUl.appendChild(li);
      });
    }

    function renderLearnTopics() {
      learnTopicsUl.innerHTML = "";
      const subject = learnData.subjects.find(s => s.id === currentSubjectId);
      if (!subject) return;
      subject.topics.forEach(t => {
        const li = document.createElement("li");
        li.className = "learn-item" + (t.id === currentTopicId ? " active" : "");
        li.textContent = t.title;
        li.addEventListener("click", () => {
          currentTopicId = t.id;
          renderLearnTopics();
          renderLearnContent();
        });
        learnTopicsUl.appendChild(li);
      });
    }

 function renderLearnContent() {
  const subject = learnData.subjects.find(s => s.id === currentSubjectId);
  if (!subject) {
    learnContentDiv.innerHTML = "";
    return;
  }

  const topic = subject.topics.find(t => t.id === currentTopicId) || subject.topics[0];
  if (!topic) {
    learnContentDiv.innerHTML = "";
    return;
  }

  const tagsHtml = (topic.tags || [])
    .map(tag => `<span class="learn-chip">${tag}</span>`)
    .join("");

  const goalsHtml = (topic.goals || [])
    .map(g => `<li>${g}</li>`)
    .join("");

  const keyHtml = (topic.keyPoints || [])
    .map(k => `<li>${k}</li>`)
    .join("");

  const formulasHtml = (topic.formulas || [])
    .map(f => `<li><code>${f}</code></li>`)
    .join("");

  const visualHtml = topic.visual
    ? `<div class="learn-section-title">Visuelle Hilfe</div>
       <div class="learn-visual">${topic.visual}</div>`
    : "";

  const detailBlocksHtml = (topic.detailBlocks || [])
    .map(block => `
      <div class="learn-section-title">${block.title}</div>
      <div style="font-size:12px; line-height:1.5; margin-bottom:6px;">
        ${block.content}
      </div>
    `)
    .join("");

  learnContentDiv.innerHTML = `
    <div class="card learn-card">
      <div class="learn-card-header">
        <div>
          <div class="learn-heading">${topic.title}</div>
          <div class="learn-subheading">${subject.name}</div>
        </div>
        <div class="learn-tagcount">
          ${(topic.tags || []).length} Stichworte
        </div>
      </div>

      <div class="learn-chiprow">${tagsHtml}</div>

      <div class="learn-section-title">Lernziele</div>
      <ul class="learn-list">${goalsHtml}</ul>

      <div class="learn-section-title">Zusammenfassung</div>
      <p style="font-size:13px; line-height:1.5; margin-top:4px;">
        ${topic.summary}
      </p>

      <div class="learn-section-title">Wichtige Punkte</div>
      <ul class="learn-list">${keyHtml}</ul>

      ${formulasHtml
        ? `<div class="learn-section-title">Wichtige Formeln (Ãœberblick)</div>
           <ul class="learn-list">${formulasHtml}</ul>`
        : ""}

      ${visualHtml}

      ${detailBlocksHtml}
    </div>
  `;
}


    // ---------- INIT ----------
    window.addEventListener("load", () => {
      loadData();
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      // renderDecks() - handled by Karteikarten2
      // renderExams() â€“ moved to Planner.html iframe
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();
      renderLearnSubjects();
      renderLearnTopics();
      renderLearnContent();
      syncFromCloud();
     });

       // --- Sync-Button: Sync-ID speichern + aus Cloud laden ---
if (syncSaveBtn && syncIdInput) {
     syncSaveBtn.addEventListener("click", () => {
      const entered = syncIdInput.value.trim();
    if (!entered) {
      alert("Bitte eine Sync-ID eingeben.");
      return;
    }

        syncId = entered;
    localStorage.setItem("uniHyperNotes_syncId", syncId);
    updateSyncStatus("Sync-ID gespeichert: " + syncId);

    // Beim Klick auch gleich aus der Cloud laden
    syncFromCloud();
  });
}
</script>   <!-- Ende des groÃŸen Haupt-Scripts -->

<script id="notebook-system">
           // HIER BAUT CODEX die Notebook- und FÃ¤cherlogik ein
</script>



<script id="flashcards-system">
// ---------- AminosÃ¤ure-Karteikarten â€“ Grundsystem ----------

// 1. Daten zu den AminosÃ¤uren
const aminoCards = [
  {
    id: "gly",
    name: "Glycin",
    three: "Gly",
    one: "G",
    category: "klein, unpolar",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” H
  |
 COOH`
  },
  {
    id: "ala",
    name: "Alanin",
    three: "Ala",
    one: "A",
    category: "klein, unpolar (CHâ‚ƒ-Seitenkette)",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” CHâ‚ƒ
  |
 COOH`
  },
  {
    id: "ser",
    name: "Serin",
    three: "Ser",
    one: "S",
    category: "polar, ungeladen (CHâ‚‚OH-Seitenkette)",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” CHâ‚‚OH
  |
 COOH`
  },
  // ğŸ‘‰ hier spÃ¤ter die restlichen 17 eintragen

{
  id: "val",
  name: "Valin",
  three: "Val",
  one: "V",
  category: "unpolar, verzweigte Seitenkette",
  structure: `
  H
  |
       Hâ‚‚N â€” C â€” CH(CHâ‚ƒ)â‚‚
  |
 COOH`
},

{
  id: "thr",
  name: "Threonin",
  three: "Thr",
  one: "T",
  category: "polar, ungeladen (CH(OH)CHâ‚ƒ-Seitenkette)",
  structure: `
 OH
 |
   H â€” C â€” CHâ‚ƒ
 |
 âºHâ‚ƒN â€” C â€” COOâ»
 |
 H
`
},

{
  id: "cys",
  name: "Cystein",
  three: "Cys",
  one: "C",
  category: "polar, ungeladen (CHâ‚‚SH-Seitenkette)",
  structure: `
H
|
    âºHâ‚ƒN â€” C â€” CHâ‚‚ â€” SH
|
COOH`
},

{
  id: "met",
  name: "Methionin",
  three: "Met",
  one: "M",
  category: "unpolar (SCHâ‚ƒ-Seitenkette)",
  structure: `
H
|
               âºHâ‚ƒN â€” C â€” CHâ‚‚ â€” CHâ‚‚ â€” S â€” CHâ‚ƒ
|
COO`
},

{
  id: "pro",
  name: "Prolin",
  three: "Pro",
  one: "P",
  category: "unpolar (pyrrolidin-Ring)",
  structure: `

          CH2
        /     \\
       H2C        CH2
         \\        /
                H2N+ â€” C â€” COO-
                |
                H

`
},

{
  id: "phe",
  name: "Phenylalanin",
  three: "Phe",
  one: "F",
  category: "aromatisch, unpolar (Câ‚†Hâ‚…-Seitenkette)",
  structure: `

        H
        |
  H3N+ â€” C â€” H
        |
       CH2
        |
      /  \\
      /    \\
      \\     /
      \\ _ /
  `
},

{
  id: "tyr",
  name: "Tyrosin",
  three: "Tyr",
  one: "Y",
  category: "aromatisch, polar (Câ‚†Hâ‚„OH-Seitenkette)",
  structure: `
        H
        |
  H3N+ â€” C â€” H
        |
       CH2
        |
       / \\
       |   |
       |   |
       \\  /
        |
       HO
  `
},

{
  id: "trp",
  name: "Tryptophan",
  three: "Trp",
  one: "W",
  category: "aromatisch, unpolar (Indol-Ring)",
  structure: `
           H
           |
H3N+ â€” C â€” C â€” COO-
           |
          CH2
           |
        / \\ / \\ 
         |       |HN
       |       |
        \\ / \\ /
  `
},

{
  id: "asn",
  name: "Asparagin",
  three: "Asn",
  one: "N",
  category: "polar, ungeladen (CONHâ‚‚-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
          // \\
            O   NH2
  `
},

{
  id: "gln",
  name: "Glutamin",
  three: "Gln",
  one: "Q",
  category: "polar, ungeladen (CHâ‚‚CHâ‚‚CONHâ‚‚-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
           C
          // \\
            O   NH2
  `
},



{
  id: "lys",
  name: "Lysin",
  three: "Lys",
  one: "K",
  category: "basisch, positiv geladen (CHâ‚‚)â‚„NHâ‚ƒâº-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
          CH2
           |
          CH2
           |
          NH3+
`
},

{
  id: "arg",
  name: "Arginin",
  three: "Arg",
  one: "R",
  category: "basisch, positiv geladen (Guanidinium-Gruppe)",
  structure: `

           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
          CH2
           |
          NH
           |
           C
           /   \\

            H2N  +   NH2

`
},

{
  id: "his",
  name: "Histidin",
  three: "His",
  one: "H",
  category: "basisch, positiv geladen (Imidazol-Seitenkette)",
  structure: `

           H
           |
         H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
         /        \\
         N        CH
         \\        /
        HC â€” HN
  `

},

{
  id: "ile",
  name: "Isoleucin",
  three: "Ile",
  one: "I",
  category: "unpolar, verzweigt (CH(CHâ‚ƒ)CHâ‚‚CHâ‚ƒ-Seitenkette)",
  structure: `
 H   H
 |   |
   âºHâ‚ƒN â€” C â€” Câ€”CHâ‚‚â€” CHâ‚ƒ
 |   |
 COOH  CHâ‚ƒ

`
},

{
  id: "leu",
  name: "Leucin",
  three: "Leu",
  one: "L",
  category: "unpolar, verzweigt (CHâ‚‚CH(CHâ‚ƒ)â‚‚-Seitenkette)",
  structure: `
  H        H
  |        |
 âºHâ‚ƒN â€” C â€” CHâ‚‚â€” C â€” CHâ‚ƒ
  |        |
  COOâ»      CHâ‚ƒ
    `

},

{
    id: "glu",
    name: "Glutamat",
    three: "Glu",
    one: "E",
    category: "sauer, negativ geladen (COOâ»-Seitenkette)",
    structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
           C
           /   \\

            O  -   O

`
},

{
  id: "asp",
  name: "AsparaginsÃ¤ure",
  three: "Asp",
  one: "D",
  category: "negativ geladen (sauer, Carboxylat-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
           /   \\

            O  -   O
  `
},


];


// 2. Zustand (welche Karte + Vorder-/RÃ¼ckseite)
let currentAminoIndex = 0;
let showBack = false;

// 3. Karte rendern
function renderAminoCard() {
  const container = document.getElementById("flashcardPreview");
  if (!container || aminoCards.length === 0) return;

  const card = aminoCards[currentAminoIndex];

  let content;
  if (!showBack) {
    // Vorderseite: Infos & Aufgabe
    content =
`Name: ${card.name} (${card.three}, ${card.one})
Eigenschaft: ${card.category}

âœï¸ Aufgabe: Zeichne die vollstÃ¤ndige Strukturformel.`;
  } else {
    // RÃ¼ckseite: Struktur in voller Schreibweise
    content = card.structure;
  }

  container.innerHTML = `
    <div class="amino-pretty">
${content}
    </div>
  `;
}

// 4. Buttons verdrahten
function initAminoFlashcards() {
  const flipBtn = document.getElementById("aminoFlipBtn");
  const nextBtn = document.getElementById("aminoNextBtn");
  const randomBtn = document.getElementById("aminoRandomBtn");

  if (flipBtn) {
    flipBtn.addEventListener("click", () => {
      showBack = !showBack;
      renderAminoCard();
    });
  }

  if (nextBtn) {
    nextBtn.addEventListener("click", () => {
      currentAminoIndex = (currentAminoIndex + 1) % aminoCards.length;
      showBack = false; // immer wieder mit Frage anfangen
      renderAminoCard();
    });
  }

  if (randomBtn) {
    randomBtn.addEventListener("click", () => {
      currentAminoIndex = Math.floor(Math.random() * aminoCards.length);
      showBack = false;
      renderAminoCard();
    });
  }

  // erste Karte anzeigen
  renderAminoCard();
}

// 5. Starten, sobald das Skript geladen ist
initAminoFlashcards();


/* ===== Wachstums-Simulation Tool ===== */

(function () {
document.addEventListener("DOMContentLoaded", () => {

  const $ = (id) => document.getElementById(id);

  const els = {
    N0: $("bioN0"), R0: $("bioR0"), K0: $("bioK0"),
    nutr: $("bioNutr"), temp: $("bioTemp"), ph: $("bioPH"),
    tmax: $("bioTmax"), dt: $("bioDt"),
    N0Val: $("bioN0Val"), R0Val: $("bioR0Val"), K0Val: $("bioK0Val"),
    nutrVal: $("bioNutrVal"), tempVal: $("bioTempVal"), phVal: $("bioPHVal"),
    tmaxVal: $("bioTmaxVal"), dtVal: $("bioDtVal"),
    runBtn: $("bioRunBtn"), addBtn: $("bioAddBtn"), clearBtn: $("bioClearBtn"), exportPlotBtn: $("bioExportPlotBtn"),exportCsvBtn: $("bioExportCsvBtn"),
    exportJsonBtn: $("bioExportJsonBtn"),

    info: $("bioInfo"),
    canvas: $("bioCanvas"),

    stressThr: $("bioStressThr"),
    deathMax: $("bioDeathMax"),
    stressThrVal: $("bioStressThrVal"),
    deathMaxVal: $("bioDeathMaxVal"),

    presetOptimal: $("bioPresetOptimal"),
    presetCold: $("bioPresetCold"),
    presetPHStress: $("bioPresetPHStress"),
    presetLowNutr: $("bioPresetLowNutr"),

    axisLockBtn: $("bioAxisLockBtn"),
    axisAutoBtn: $("bioAxisAutoBtn"),
    axisStatus: $("bioAxisStatus"),

  advancedToggle: $("bioAdvancedToggle"),
  integrator: $("bioIntegrator"),
  integratorWrap: $("bioIntegratorWrap")



  };

  if (!els.canvas) return; // falls Card nicht drin ist

  const ctx = els.canvas.getContext("2d");
  const runs = [];

  function formatK(n) {
    if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
    if (n >= 1e3) return (n/1e3).toFixed(2) + "k";
    return String(Math.round(n));
  }

const axisLock = {
  locked: false,
  maxT: null,
  maxN: null
};


function updateAdvancedUI() {
  const on = !!els.advancedToggle?.checked;
  if (els.integratorWrap) els.integratorWrap.style.display = on ? "inline-block" : "none";
  if (els.integrator) els.integrator.disabled = !on;
}

if (els.advancedToggle) {
  els.advancedToggle.addEventListener("change", () => {
    updateAdvancedUI();
    runSingle(); // optional: direkt neu rechnen
  });
}

if (els.integrator) {
  els.integrator.addEventListener("change", () => runSingle());
}

updateAdvancedUI();



function setVals() {
  if (els.N0Val && els.N0) els.N0Val.textContent = Number(els.N0.value).toLocaleString("de-DE");
  if (els.R0Val && els.R0) els.R0Val.textContent = Number(els.R0.value).toFixed(2);
  if (els.K0Val && els.K0) els.K0Val.textContent = Number(els.K0.value).toLocaleString("de-DE");

  if (els.nutrVal && els.nutr) els.nutrVal.textContent = els.nutr.value + "%";
  if (els.tempVal && els.temp) els.tempVal.textContent = Number(els.temp.value).toFixed(1);
  if (els.phVal && els.ph) els.phVal.textContent = Number(els.ph.value).toFixed(1);

  if (els.tmaxVal && els.tmax) els.tmaxVal.textContent = els.tmax.value + "h";
  if (els.dtVal && els.dt) els.dtVal.textContent = Number(els.dt.value).toFixed(2) + "h";

  // âœ… HIER ganz unten rein:
  if (els.stressThrVal && els.stressThr) els.stressThrVal.textContent = Number(els.stressThr.value).toFixed(2);
  if (els.deathMaxVal && els.deathMax) els.deathMaxVal.textContent = Number(els.deathMax.value).toFixed(2);
}

  // Umweltfaktoren (vereinfacht, aber plausibel):
  // Temp- und pH-Faktor als "Glocke" um Optimum, NÃ¤hrstoffe skalieren K
  function gaussianFactor(x, opt, sigma) {
    const z = (x - opt) / sigma;
    return Math.exp(-0.5 * z * z);
  }

 function computeEffectiveParams() {
  const r0 = Number(els.R0.value);
  const K0 = Number(els.K0.value);

  const nutr = els.nutr ? Number(els.nutr.value) : 70;
  const T = els.temp ? Number(els.temp.value) : 37;
  const pH = els.ph ? Number(els.ph.value) : 7.0;

  // Optima
  const Topt = 37, sigmaT = 7;
  const pHopt = 7.0, sigmapH = 1.2;

  const fT = gaussianFactor(T, Topt, sigmaT);
  const fpH = gaussianFactor(pH, pHopt, sigmapH);

  // Fitness (0..1)
  const fitnessRaw = fT * fpH;
  const fitness = Math.max(0.0, Math.min(1.0, fitnessRaw));

  // Wachstumsrate: bei Stress wird r kleiner, aber nicht negativ
  const r = r0 * Math.max(0.0, fitness);

  // NÃ¤hrstoffe beeinflussen K stark
  const fN = 0.20 + 0.80 * (nutr / 100);
  const K = K0 * fN;

  // NEU: Sterberate d bei Stress
  const thr = els.stressThr ? Number(els.stressThr.value) : 0.30;     // Fitness-Schwelle
  const dMax = els.deathMax ? Number(els.deathMax.value) : 0.25;      // max. Sterberate

  // Wenn Fitness >= thr => d=0
  // Wenn Fitness < thr => d steigt bis dMax, je weiter drunter
  const stress = thr <= 0 ? 0 : Math.max(0, (thr - fitness) / thr);   // 0..1
  const d = dMax * stress;

  return { r, K, fitness, fT, fpH, fN, d, thr, dMax };
}


 function simulate() {
  const N0 = Number(els.N0.value);
  const tmax = Number(els.tmax.value);
  const dt = Number(els.dt.value);

  const { r, K, fitness, fT, fpH, fN, d, thr } = computeEffectiveParams();

  const points = [];
  let n = N0;

  const Ksafe = Math.max(K, 1);

  // âœ… Integrator-Wahl
  const advancedOn = !!els.advancedToggle?.checked;
  const method = advancedOn ? (els.integrator?.value || "euler") : "euler";

  // Ableitung dN/dt als Funktion (praktisch fÃ¼r RK2)
  const deriv = (nVal) => {
    const growth = r * nVal * (1 - nVal / Ksafe);
    const death = d * nVal;
    return growth - death;
  };

  for (let time = 0; time <= tmax + 1e-12; time += dt) {
    points.push({ t: time, N: n });

    if (method === "heun") {
      // RK2 / Heun
      const k1 = deriv(n);
      const nPred = n + dt * k1;
      const k2 = deriv(nPred);
      n = n + dt * 0.5 * (k1 + k2);
    } else {
      // Euler
      n = n + dt * deriv(n);
    }

    if (!Number.isFinite(n) || n < 0) n = 0;
  }

  const maxN = points.reduce((m, p) => Math.max(m, p.N), 0);


// Kennzahlen
const N_end = points.length ? points[points.length - 1].N : 0;

// t_half: Zeitpunkt, wo N >= 0.5*K (nur sinnvoll, wenn K>0)
let tHalf = null;
if (K > 0) {
  const target = 0.5 * K;
  const hit = points.find(p => p.N >= target);
  tHalf = hit ? hit.t : null;
}


  const methodLabel = (method === "heun") ? "RK2/Heun" : "Euler";

const warn = (advancedOn && dt > 0.2)
  ? (method === "euler" ? "âš ï¸ dt groÃŸ â†’ Euler kann ungenau/instabil werden" : "âš ï¸ dt groÃŸ â†’ Genauigkeit sinkt")
  : "";

const tHalfLabel = (tHalf == null)
  ? (N_end < 0.5 * K ? "â€” (nicht erreicht)" : "â€”")
  : `${tHalf.toFixed(2)}h`;

  if (els.info) {
  els.info.innerHTML =
    `Effektiv: r = <b>${r.toFixed(3)}</b> | K = <b>${formatK(K)}</b> | Fitness = <b>${fitness.toFixed(2)}</b>` +
    ` | d = <b>${d.toFixed(3)}</b> | Numerik: <b>${methodLabel}</b>` +
    `<br><span style="opacity:.85;">N_end=${formatK(N_end)} Â· N_max=${formatK(maxN)} Â· tÂ½=${tHalfLabel}</span>` +
    `<br><span style="opacity:.75;">Faktoren: Temp=${fT.toFixed(2)} Â· pH=${fpH.toFixed(2)} Â· Nutr(K)=${fN.toFixed(2)} Â· StressThr=${thr.toFixed(2)}</span>` +

    (warn ? `<br><span style="opacity:.7;">${warn}</span>` : "");


}


  return {
  points,
  maxT: tmax,
  maxN,
  r,
  K,
  meta: { r, K, dt, tmax, fitness, d, method }
};
}



  function clearCanvas() {
    ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
  }

function drawAxes(minT, maxT, minN, maxN) {
  const w = els.canvas.width, h = els.canvas.height;
  const pad = 42;
  
  const rangeT = maxT - minT;
  const rangeN = maxN - minN;

  // grid setup (wie vorher)
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 1;

  const yTicks = 4;  // 0..4 => 5 Labels
  const xTicks = 6;  // 0..6 => 7 Labels

  // horizontale Grid-Linien
  for (let i = 0; i <= yTicks; i++) {
    const frac = i / yTicks;
    const y = h - pad - frac * (h - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(w - pad, y);
    ctx.stroke();
  }

  // vertikale Grid-Linien
  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const x = pad + frac * (w - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(x, pad);
    ctx.lineTo(x, h - pad);
    ctx.stroke();
  }
  ctx.restore();

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, h - pad);
  ctx.lineTo(w - pad, h - pad);
  ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("N", 18, pad + 4);
  ctx.fillText("t (h)", w - pad - 30, h - pad + 28);

  // âœ… Tick-Labels (statt nur min/max)
  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";

  // Y: links (minN..maxN)
  for (let i = 0; i <= yTicks; i++) {
    const frac = i / yTicks;
    const val = minN + frac * rangeN;
    const y = h - pad - frac * (h - 2 * pad);
    const text = formatK(val);
    ctx.fillText(text, 8, y + 4);
  }

  // X: unten (minT..maxT)
  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const val = minT + frac * rangeT;
    const x = pad + frac * (w - 2 * pad);
    const text = (val % 1 === 0) ? String(val) : val.toFixed(1);
    ctx.fillText(text, x - 8, h - pad + 14);
  }
}

  const palette = [
    "rgba(0,255,200,0.95)",
    "rgba(255,200,0,0.95)",
    "rgba(255,90,120,0.95)",
    "rgba(120,170,255,0.95)",
    "rgba(200,120,255,0.95)"
  ];

function plotRuns() {
  const w = els.canvas.width, h = els.canvas.height;
  const pad = 42;

  // Wenn keine Runs da sind: nur Achsen "default" zeichnen
  if (!runs.length) {
    const fallbackT = Number(els.tmax?.value ?? 24);
    const fallbackN = Number(els.K0?.value ?? 200000);
    clearCanvas();
    drawAxes(0, fallbackT, 0, fallbackN);
    if (els.axisStatus) els.axisStatus.textContent = `ğŸŸ¢ auto: tâ‰¤${fallbackT}h | Nâ‰¤${formatK(fallbackN)}`;
    return;
  }

  // Autoscale aus Runs (maxT/maxN) + Fallback aus Points
  const autoMaxT = Math.max(...runs.map(r => r.maxT ?? 0), 0);
  const autoMaxN = Math.max(...runs.map(r => r.maxN ?? 0), 0);

  const fallbackMaxT = Math.max(
    ...runs.map(r => (r.points?.length ? r.points[r.points.length - 1].t : 0)),
    0
  );
  const fallbackMaxN = Math.max(
    ...runs.flatMap(r => (r.points?.length ? r.points.map(p => p.N) : [0])),
    0
  );

  let maxT = Math.max(autoMaxT, fallbackMaxT, 1);
  let maxN = Math.max(autoMaxN, fallbackMaxN, 1);
  let minT = 0;
  let minN = 0;

  // Lock anwenden (fixe Achsen)
  if (axisLock.locked) {
    if (axisLock.maxT != null) maxT = axisLock.maxT;
    if (axisLock.maxN != null) maxN = axisLock.maxN;
    if (axisLock.minT != null) minT = axisLock.minT;
    if (axisLock.minN != null) minN = axisLock.minN;
  }

  // kleiner Puffer fÃ¼rs Zeichnen
  const shownMaxT = maxT;
  const shownMaxN = maxN;
  maxT *= 1.02;
  maxN *= 1.10;

  // Statusanzeige
  if (els.axisStatus) {
    els.axisStatus.textContent = axisLock.locked
      ? `ğŸ”’ fix: tâˆˆ[${minT},${shownMaxT.toFixed(1)}]h | Nâˆˆ[${formatK(minN)},${formatK(shownMaxN)}]`
      : `ğŸŸ¢ auto: tâ‰¤${shownMaxT.toFixed(1)}h | Nâ‰¤${formatK(shownMaxN)}`;
  }

  clearCanvas();
  drawAxes(minT, maxT, minN, maxN);

  const rangeT = maxT - minT;
  const rangeN = maxN - minN;

  // Kurven plotten
  runs.forEach((run, idx) => {
    const pts = run.points || [];
    if (!pts.length) return;

    ctx.save();
    ctx.strokeStyle = palette[idx % palette.length];
    ctx.lineWidth = (idx === runs.length - 1) ? 3 : 2;
    ctx.globalAlpha = (idx === runs.length - 1) ? 1 : 0.65;

    ctx.beginPath();
    pts.forEach((pt, i) => {
      const x = pad + ((pt.t - minT) / rangeT) * (w - 2 * pad);
      const y = h - pad - ((pt.N - minN) / rangeN) * (h - 2 * pad);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.restore();
  });

  // kleine Anzeige
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(`Runs: ${runs.length}`, 52, 22);
}

function downloadText(filename, text, mime = "text/plain;charset=utf-8") {
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function exportLatestRunCSV() {
  if (!runs.length) return;

  const run = runs[runs.length - 1];
  const pts = run.points || [];

  // Parameter (falls du sie im run speicherst; sonst hier aus simulate()/compute holen)
  const meta = run.meta || {}; 
  const sep = ";";

  // Kopfzeile
  let csv = [
    "t_h","N",
    "r_eff","K_eff","dt_h","tmax_h",
    "fitness","death_d","method"
  ].join(sep) + "\n";

  // Zeilen
  csv += pts.map(p => ([
    p.t,
    p.N,
    meta.r ?? "",
    meta.K ?? "",
    meta.dt ?? "",
    meta.tmax ?? "",
    meta.fitness ?? "",
    meta.d ?? "",
    meta.method ?? ""
  ].join(sep))).join("\n");

  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  downloadText(`wachstum_points_${stamp}.csv`, csv, "text/csv;charset=utf-8");
}


function exportAllRunsJSON() {
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  downloadText(`wachstum_runs_${stamp}.json`, JSON.stringify(runs, null, 2), "application/json");
}



  function runSingle() {
    runs.length = 0;
    runs.push(simulate());
    plotRuns();
  }

  function addRun() {
    runs.push(simulate());
    plotRuns();
  }

  function resetAll() {
    runs.length = 0;
    els.info.textContent = "";
    clearCanvas();
  }


function applyPreset(name) {
  const presets = {
    optimal: { nutr: 100, temp: 37, ph: 7.0 },
    cold: { nutr: 70, temp: 12, ph: 7.0 },
    phStress: { nutr: 70, temp: 37, ph: 5.2 },
    lowNutr: { nutr: 10, temp: 37, ph: 7.0 },
  };

  const p = presets[name];
  if (!p) return;

  if (els.nutr) els.nutr.value = p.nutr;
  if (els.temp) els.temp.value = p.temp;
  if (els.ph) els.ph.value = p.ph;

  setVals();
  // optional: direkt neu simulieren
  // runSingle();
}


  // init
setVals();

// alle Slider updaten nur setVals()
const allInputs = [
  els.N0, els.R0, els.K0,
  els.nutr, els.temp, els.ph,
  els.tmax, els.dt,
  els.stressThr, els.deathMax
].filter(Boolean);

["input", "change"].forEach(evt => {
  allInputs.forEach(el => el.addEventListener(evt, () => setVals()));
});

// ===== Bio-Simulation Tab Switching =====
document.querySelectorAll('.bio-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const targetTab = tab.dataset.bioTab;
    
    // Switch tab buttons
    document.querySelectorAll('.bio-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    // Switch tab content
    document.querySelectorAll('.bio-tab-content').forEach(content => {
      content.classList.remove('active');
    });
    document.querySelector(`[data-bio-content="${targetTab}"]`).classList.add('active');
  });
});

// preset buttons
if (els.presetOptimal) els.presetOptimal.addEventListener("click", () => applyPreset("optimal"));
if (els.presetCold) els.presetCold.addEventListener("click", () => applyPreset("cold"));
if (els.presetPHStress) els.presetPHStress.addEventListener("click", () => applyPreset("phStress"));
if (els.presetLowNutr) els.presetLowNutr.addEventListener("click", () => applyPreset("lowNutr"));

// tool buttons

if (els.exportCsvBtn) els.exportCsvBtn.addEventListener("click", exportLatestRunCSV);
if (els.exportJsonBtn) els.exportJsonBtn.addEventListener("click", exportAllRunsJSON);

// ===== pH-Rechner =====
const phCalcBtn = document.getElementById("phCalcBtn");
const phH = document.getElementById("phH");
const phResult = document.getElementById("phResult");

if (phCalcBtn) {
  phCalcBtn.addEventListener("click", () => {
    const h = parseFloat(phH.value);
    if (h > 0) {
      const ph = -Math.log10(h);
      phResult.textContent = `pH = ${ph.toFixed(2)}`;
      phResult.style.color = ph < 7 ? "#ff6b81" : (ph > 7 ? "#7b8cff" : "#4ecdc4");
    } else {
      phResult.textContent = "Bitte positive Zahl eingeben!";
      phResult.style.color = "#ff6b81";
    }
  });
}

// ===== Molmasse-Rechner =====
const molCalcBtn = document.getElementById("molCalcBtn");
const molFormula = document.getElementById("molFormula");
const molResult = document.getElementById("molResult");

// Atommassen (gerundet)
const atomicMass = {
  H: 1, C: 12, N: 14, O: 16, P: 31, S: 32, 
  Cl: 35.5, Br: 80, I: 127, F: 19, Na: 23, 
  K: 39, Ca: 40, Mg: 24, Fe: 56, Zn: 65,
  Cu: 64, Ag: 108, Au: 197, Al: 27, Si: 28
};

if (molCalcBtn) {
  molCalcBtn.addEventListener("click", () => {
    const formula = molFormula.value.trim();
    if (!formula) {
      molResult.textContent = "Bitte Formel eingeben!";
      return;
    }
    
    let totalMass = 0;
    const regex = /([A-Z][a-z]?)(\d*)/g;
    let match;
    let valid = true;
    
    while ((match = regex.exec(formula)) !== null) {
      const element = match[1];
      const count = match[2] ? parseInt(match[2]) : 1;
      
      if (atomicMass[element]) {
        totalMass += atomicMass[element] * count;
      } else {
        molResult.textContent = `Element ${element} nicht gefunden!`;
        molResult.style.color = "#ff6b81";
        valid = false;
        break;
      }
    }
    
    if (valid) {
      molResult.textContent = `Molmasse = ${totalMass.toFixed(2)} g/mol`;
      molResult.style.color = "#7b8cff";
    }
  });
}

// ===== ERWEITERTER Graphen-Plotter =====
const graphCanvas = document.getElementById("graphCanvas");
const graphCtx = graphCanvas ? graphCanvas.getContext("2d") : null;
const graphPlotBtn = document.getElementById("graphPlotBtn");
const graphClearBtn = document.getElementById("graphClearBtn");
const graphAddBtn = document.getElementById("graphAddBtn");
const graphFunc = document.getElementById("graphFunc");
const graphXmin = document.getElementById("graphXmin");
const graphXmax = document.getElementById("graphXmax");
const graphInfo = document.getElementById("graphInfo");

let graphFunctions = [];
let graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
let graphDragStart = null;
let graphShowDerivative = false;
let graphShowIntegral = false;
let graphShowZeros = false;
let graphShowExtrema = false;
let graphShowTangent = null;
let graphPlotMode = 'cartesian'; // cartesian, polar, parametric
let graphAnimationParam = 0;
let graphAnimationRunning = false;

// Erweiterte mathematische Funktionen
const mathFunctions = {
  // Trigonometrische Funktionen
  sin: Math.sin, cos: Math.cos, tan: Math.tan,
  asin: Math.asin, acos: Math.acos, atan: Math.atan,
  sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh,
  asinh: Math.asinh, acosh: Math.acosh, atanh: Math.atanh,
  sec: (x) => 1 / Math.cos(x),
  csc: (x) => 1 / Math.sin(x),
  cot: (x) => 1 / Math.tan(x),
  
  // Exponential und Logarithmus
  exp: Math.exp, ln: Math.log, log: Math.log10, log2: Math.log2,
  
  // Wurzeln und Potenzen
  sqrt: Math.sqrt, cbrt: Math.cbrt, pow: Math.pow,
  
  // Runden
  abs: Math.abs, floor: Math.floor, ceil: Math.ceil, round: Math.round,
  sign: Math.sign, trunc: Math.trunc,
  
  // Min/Max
  min: Math.min, max: Math.max,
  
  // Konstanten
  pi: Math.PI, e: Math.E,
  
  // Spezielle Funktionen
  fact: (n) => {
    if (n < 0) return NaN;
    if (n === 0 || n === 1) return 1;
    let result = 1;
    for (let i = 2; i <= n; i++) result *= i;
    return result;
  },
  
  // Heaviside-Funktion
  heaviside: (x) => x < 0 ? 0 : (x === 0 ? 0.5 : 1),
  step: (x) => x < 0 ? 0 : 1,
  
  // Signum
  sgn: Math.sign,
  
  // Modulo
  mod: (a, b) => ((a % b) + b) % b,
  
  // Gamma-Funktion (Approximation)
  gamma: (z) => {
    // Stirling-Approximation fÃ¼r groÃŸe z
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * mathFunctions.gamma(1 - z));
    z -= 1;
    const g = 7;
    const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
               771.32342877765313, -176.61502916214059, 12.507343278686905,
               -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    let x = p[0];
    for (let i = 1; i < g + 2; i++) {
      x += p[i] / (z + i);
    }
    const t = z + g + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
};

function evaluateFunction(funcStr, x, t = 0) {
  try {
    // Ersetze mathematische Notation
    let expr = funcStr
      .replace(/\^/g, '**')
      .replace(/Ï€/g, 'Math.PI')
      .replace(/Ã·/g, '/')
      .replace(/Ã—/g, '*')
      .replace(/Â²/g, '**2')
      .replace(/Â³/g, '**3');
    
    // Implizite Multiplikation: 2x -> 2*x, 3sin(x) -> 3*sin(x)
    expr = expr.replace(/(\d)([a-z])/gi, '$1*$2');
    expr = expr.replace(/\)([a-z0-9])/gi, ')*$1');
    expr = expr.replace(/(\d)\(/g, '$1*(');
    expr = expr.replace(/\)\(/g, ')*(');
    
    // Ersetze alle mathematischen Funktionen
    Object.keys(mathFunctions).forEach(fname => {
      const regex = new RegExp(`\\b${fname}\\b`, 'gi');
      expr = expr.replace(regex, `mathFunctions.${fname}`);
    });
    
    // Evaluiere
    const func = new Function('x', 't', 'mathFunctions', 'Math', `
      "use strict";
      return (${expr});
    `);
    
    return func(x, t, mathFunctions, Math);
  } catch (e) {
    return NaN;
  }
}

// Numerische Ableitung
function derivative(funcStr, x, h = 0.0001) {
  const f1 = evaluateFunction(funcStr, x + h);
  const f2 = evaluateFunction(funcStr, x - h);
  return (f1 - f2) / (2 * h);
}

// Zweite Ableitung
function secondDerivative(funcStr, x, h = 0.0001) {
  const f0 = evaluateFunction(funcStr, x);
  const f1 = evaluateFunction(funcStr, x + h);
  const f2 = evaluateFunction(funcStr, x - h);
  return (f1 - 2 * f0 + f2) / (h * h);
}

// Numerische Integration (Trapezregel)
function integrate(funcStr, a, b, n = 1000) {
  const h = (b - a) / n;
  let sum = (evaluateFunction(funcStr, a) + evaluateFunction(funcStr, b)) / 2;
  
  for (let i = 1; i < n; i++) {
    sum += evaluateFunction(funcStr, a + i * h);
  }
  
  return sum * h;
}

// Nullstellenfinder (Newton-Verfahren + Bisection)
function findZeros(funcStr, xMin, xMax, steps = 100) {
  const zeros = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 0; i < steps; i++) {
    const x0 = xMin + i * stepSize;
    const y0 = evaluateFunction(funcStr, x0);
    const x1 = xMin + (i + 1) * stepSize;
    const y1 = evaluateFunction(funcStr, x1);
    
    // Vorzeichenwechsel?
    if (isFinite(y0) && isFinite(y1) && y0 * y1 < 0) {
      // Newton-Raphson mit Bisection Fallback
      let x = (x0 + x1) / 2;
      let left = x0, right = x1;
      
      for (let iter = 0; iter < 30; iter++) {
        const fx = evaluateFunction(funcStr, x);
        const dfx = derivative(funcStr, x);
        
        if (Math.abs(fx) < 1e-10) {
          zeros.push(x);
          break;
        }
        
        if (Math.abs(dfx) > 1e-10) {
          // Newton-Schritt
          const newX = x - fx / dfx;
          if (newX >= left && newX <= right) {
            x = newX;
          } else {
            // Bisection Fallback
            x = (left + right) / 2;
          }
        } else {
          // Bisection
          x = (left + right) / 2;
        }
        
        const fNew = evaluateFunction(funcStr, x);
        if (fNew * evaluateFunction(funcStr, left) < 0) {
          right = x;
        } else {
          left = x;
        }
      }
    }
  }
  
  // Entferne Duplikate
  return zeros.filter((val, idx, arr) => 
    idx === 0 || Math.abs(val - arr[idx - 1]) > 0.001
  );
}

// Extrema finden (Maxima und Minima)
function findExtrema(funcStr, xMin, xMax, steps = 200) {
  const extrema = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 1; i < steps - 1; i++) {
    const x = xMin + i * stepSize;
    const dy = derivative(funcStr, x);
    const d2y = secondDerivative(funcStr, x);
    
    // Kritischer Punkt (erste Ableitung â‰ˆ 0)?
    if (Math.abs(dy) < 0.01) {
      const y = evaluateFunction(funcStr, x);
      if (isFinite(y)) {
        // Zweite Ableitung testen
        let type = 'saddle';
        if (d2y > 0.01) {
          type = 'min';
        } else if (d2y < -0.01) {
          type = 'max';
        }
        
        extrema.push({ x, y, type });
      }
    }
  }
  
  return extrema;
}

// Wendepunkte finden
function findInflectionPoints(funcStr, xMin, xMax, steps = 200) {
  const inflection = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 1; i < steps - 1; i++) {
    const x = xMin + i * stepSize;
    const d2y = secondDerivative(funcStr, x);
    const xPrev = xMin + (i - 1) * stepSize;
    const d2yPrev = secondDerivative(funcStr, xPrev);
    
    // Vorzeichenwechsel der zweiten Ableitung?
    if (isFinite(d2y) && isFinite(d2yPrev) && d2y * d2yPrev < 0) {
      const y = evaluateFunction(funcStr, x);
      if (isFinite(y)) {
        inflection.push({ x, y });
      }
    }
  }
  
  return inflection;
}

// ===== High-DPI Canvas Setup for Sharp Rendering =====
function setupCanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  
  return { width: rect.width, height: rect.height, ctx, dpr };
}

// Hilfsfunktion um Zoom-Level anzuzeigen
function updateZoomDisplay() {
  const graphZoomLevel = document.getElementById('graphZoomLevel');
  if (graphZoomLevel) {
    graphZoomLevel.textContent = graphZoom.scale.toFixed(1) + 'x';
  }
}

// Hilfsfunktion um Button-Zustand zu aktualisieren
function updateButtonState(button, active) {
  if (button) {
    button.style.background = active ? 'var(--accent)' : '';
    button.style.color = active ? '#fff' : '';
  }
}

function plotGraph() {
  if (!graphCtx || !graphCanvas || graphFunctions.length === 0) return;
  
  const { width: w, height: h, ctx } = setupCanvas(graphCanvas);
  const pad = 60;
  
  let xMin = parseFloat(graphXmin.value);
  let xMax = parseFloat(graphXmax.value);
  
  // Zoom anwenden
  const xRange = (xMax - xMin) / graphZoom.scale;
  const xCenter = (xMax + xMin) / 2 + graphZoom.offsetX;
  xMin = xCenter - xRange / 2;
  xMax = xCenter + xRange / 2;
  
  // Hintergrund
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg').trim();
  ctx.fillRect(0, 0, w, h);
  
  // Y-Bereich berechnen
  let yMin = Infinity;
  let yMax = -Infinity;
  
  graphFunctions.forEach(func => {
    if (graphPlotMode === 'parametric') {
      // FÃ¼r parametrische Plots
      for (let tVal = 0; tVal <= 1; tVal += 0.001) {
        try {
          const tScaled = tVal * 2 * Math.PI;
          const xVal = evaluateFunction(func.x, 0, tScaled);
          const yVal = evaluateFunction(func.y, 0, tScaled);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    } else if (graphPlotMode === 'polar') {
      // FÃ¼r Polar-Plots
      for (let theta = 0; theta < 2 * Math.PI; theta += 0.01) {
        try {
          const r = evaluateFunction(func, theta);
          const xVal = r * Math.cos(theta);
          const yVal = r * Math.sin(theta);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    } else {
      // FÃ¼r kartesische Plots
      for (let px = 0; px < w; px++) {
        const xVal = xMin + (px / w) * (xMax - xMin);
        try {
          const yVal = evaluateFunction(func, xVal, graphAnimationParam);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    }
  });
  
  if (!isFinite(yMin) || !isFinite(yMax)) {
    yMin = -10;
    yMax = 10;
  }
  
  // Manuelle Y-Achse
  if (manualYAxis.enabled && manualYAxis.yMin != null && manualYAxis.yMax != null) {
    yMin = manualYAxis.yMin;
    yMax = manualYAxis.yMax;
  } else {
    const yRange = yMax - yMin;
    yMin -= yRange * 0.1;
    yMax += yRange * 0.1;
  }
  
  // Zoom fÃ¼r Y auch anwenden
  const yRange = (yMax - yMin) / graphZoom.scale;
  const yCenter = (yMax + yMin) / 2 + graphZoom.offsetY;
  yMin = yCenter - yRange / 2;
  yMax = yCenter + yRange / 2;
  
  // Hilfsfunktion fÃ¼r Koordinaten-Transformation
  const toScreen = (xVal, yVal) => ({
    x: pad + ((xVal - xMin) / (xMax - xMin)) * (w - 2 * pad),
    y: h - pad - ((yVal - yMin) / (yMax - yMin)) * (h - 2 * pad)
  });
  
  // Gitter zeichnen
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  
  const gridStepsX = 20;
  const gridStepsY = 20;
  
  for (let i = 0; i <= gridStepsX; i++) {
    const xVal = pad + (i / gridStepsX) * (w - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(xVal, pad);
    ctx.lineTo(xVal, h - pad);
    ctx.stroke();
  }
  
  for (let i = 0; i <= gridStepsY; i++) {
    const yVal = pad + (i / gridStepsY) * (h - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(pad, yVal);
    ctx.lineTo(w - pad, yVal);
    ctx.stroke();
  }
  
  // Achsen zeichnen
  ctx.strokeStyle = "rgba(255,255,255,0.4)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  // Y-Achse
  const x0Screen = toScreen(0, 0).x;
  if (x0Screen >= pad && x0Screen <= w - pad) {
    ctx.moveTo(x0Screen, pad);
    ctx.lineTo(x0Screen, h - pad);
  }
  
  // X-Achse
  const y0Screen = toScreen(0, 0).y;
  if (y0Screen >= pad && y0Screen <= h - pad) {
    ctx.moveTo(pad, y0Screen);
    ctx.lineTo(w - pad, y0Screen);
  }
  
  ctx.stroke();
  
  // Achsenbeschriftung
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.font = "12px system-ui";
  ctx.textAlign = "center";
  
  // X-Achse Beschriftung
  for (let i = 0; i <= 10; i++) {
    const xVal = xMin + (i / 10) * (xMax - xMin);
    const screen = toScreen(xVal, 0);
    if (screen.x >= pad && screen.x <= w - pad) {
      ctx.fillText(xVal.toFixed(1), screen.x, h - pad + 20);
    }
  }
  
  ctx.textAlign = "right";
  // Y-Achse Beschriftung
  for (let i = 0; i <= 10; i++) {
    const yVal = yMin + (i / 10) * (yMax - yMin);
    const screen = toScreen(0, yVal);
    if (screen.y >= pad && screen.y <= h - pad) {
      ctx.fillText(yVal.toFixed(1), pad - 10, screen.y + 4);
    }
  }
  
  // Funktionen plotten
  const colors = ["#7b8cff", "#ff6b81", "#4ecdc4", "#ffd93d", "#a78bfa", "#ff9ff3", "#54a0ff"];
  
  graphFunctions.forEach((func, idx) => {
    const color = colors[idx % colors.length];
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    
    if (graphPlotMode === 'polar') {
      // Polar-Plot
      ctx.beginPath();
      let started = false;
      
      for (let theta = 0; theta <= 2 * Math.PI; theta += 0.005) {
        try {
          const r = evaluateFunction(func, theta);
          const xVal = r * Math.cos(theta);
          const yVal = r * Math.sin(theta);
          
          if (isFinite(xVal) && isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
          } else {
            started = false;
          }
        } catch (e) {
          started = false;
        }
      }
      ctx.stroke();
      
    } else if (graphPlotMode === 'parametric') {
      // Parametrischer Plot
      ctx.beginPath();
      let started = false;
      
      for (let tVal = 0; tVal <= 1; tVal += 0.0005) {
        try {
          const tScaled = tVal * 2 * Math.PI;
          const xVal = evaluateFunction(func.x, 0, tScaled);
          const yVal = evaluateFunction(func.y, 0, tScaled);
          
          if (isFinite(xVal) && isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
          } else {
            started = false;
          }
        } catch (e) {
          started = false;
        }
      }
      ctx.stroke();
      
    } else {
      // Kartesischer Plot
      ctx.beginPath();
      let started = false;
      let lastY = null;
      
      for (let px = 0; px < w - 2 * pad; px++) {
        const xVal = xMin + (px / (w - 2 * pad)) * (xMax - xMin);
        try {
          const yVal = evaluateFunction(func, xVal, graphAnimationParam);
          
          if (isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            
            // DiskontinuitÃ¤ts-Check
            if (lastY !== null && Math.abs(yVal - lastY) > (yMax - yMin) * 0.5) {
              started = false;
            }
            
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
            lastY = yVal;
          } else {
            started = false;
            lastY = null;
          }
        } catch (e) {
          started = false;
          lastY = null;
        }
      }
      ctx.stroke();
      
      // Ableitung zeigen
      if (graphShowDerivative && graphPlotMode === 'cartesian') {
        ctx.strokeStyle = color.replace(')', ', 0.5)').replace('rgb', 'rgba').replace('#', 'rgba(');
        if (!ctx.strokeStyle.includes('rgba')) {
          ctx.strokeStyle = color + '80'; // Hex Alpha
        }
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        started = false;
        
        for (let px = 0; px < w - 2 * pad; px++) {
          const xVal = xMin + (px / (w - 2 * pad)) * (xMax - xMin);
          try {
            const dy = derivative(func, xVal);
            if (isFinite(dy)) {
              const screen = toScreen(xVal, dy);
              if (!started) {
                ctx.moveTo(screen.x, screen.y);
                started = true;
              } else {
                ctx.lineTo(screen.x, screen.y);
              }
            } else {
              started = false;
            }
          } catch (e) {
            started = false;
          }
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Nullstellen zeigen
      if (graphShowZeros && graphPlotMode === 'cartesian') {
        const zeros = findZeros(func, xMin, xMax);
        ctx.fillStyle = color;
        zeros.forEach(xVal => {
          const screen = toScreen(xVal, 0);
          if (screen.x >= pad && screen.x <= w - pad && screen.y >= pad && screen.y <= h - pad) {
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.strokeStyle = color;
          }
        });
      }
      
      // Extrema zeigen
      if (graphShowExtrema && graphPlotMode === 'cartesian') {
        const extrema = findExtrema(func, xMin, xMax);
        extrema.forEach(ext => {
          const screen = toScreen(ext.x, ext.y);
          if (screen.x >= pad && screen.x <= w - pad && screen.y >= pad && screen.y <= h - pad) {
            ctx.fillStyle = ext.type === 'max' ? '#ff6b81' : (ext.type === 'min' ? '#4ecdc4' : '#ffd93d');
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            const label = ext.type === 'max' ? 'MAX' : (ext.type === 'min' ? 'MIN' : 'SP');
            ctx.fillText(label, screen.x, screen.y - 12);
            ctx.strokeStyle = color;
          }
        });
      }
      
      // Tangente zeigen
      if (graphShowTangent !== null && graphPlotMode === 'cartesian') {
        const xVal = graphShowTangent;
        const yVal = evaluateFunction(func, xVal);
        const slope = derivative(func, xVal);
        
        if (isFinite(yVal) && isFinite(slope)) {
          ctx.strokeStyle = '#ffd93d';
          ctx.lineWidth = 2.5;
          ctx.setLineDash([10, 5]);
          ctx.beginPath();
          
          const x1 = xMin;
          const y1 = yVal + slope * (x1 - xVal);
          const x2 = xMax;
          const y2 = yVal + slope * (x2 - xVal);
          
          const screen1 = toScreen(x1, y1);
          const screen2 = toScreen(x2, y2);
          
          ctx.moveTo(screen1.x, screen1.y);
          ctx.lineTo(screen2.x, screen2.y);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Punkt markieren
          const screenPt = toScreen(xVal, yVal);
          ctx.fillStyle = '#ffd93d';
          ctx.beginPath();
          ctx.arc(screenPt.x, screenPt.y, 6, 0, 2 * Math.PI);
          ctx.fill();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Info-Text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 11px system-ui';
          ctx.textAlign = 'left';
          ctx.fillText(`m = ${slope.toFixed(3)}`, screenPt.x + 10, screenPt.y - 10);
        }
      }
    }
  });
  
  // Info-Text
  const funcCount = graphFunctions.length;
  const modeText = graphPlotMode === 'polar' ? 'Polar' : (graphPlotMode === 'parametric' ? 'Parametrisch' : 'Kartesisch');
  graphInfo.textContent = `${funcCount} Funktion(en) | ${modeText} | x: [${xMin.toFixed(2)}, ${xMax.toFixed(2)}] | y: [${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`;
  
  // Update Zoom-Anzeige
  updateZoomDisplay();
}

// Event-Listener
if (graphPlotBtn) {
  graphPlotBtn.addEventListener("click", () => {
    const input = graphFunc.value.trim();
    if (!input) return;
    
    // Parametrische Funktion? (Format: x(t); y(t))
    if (input.includes(';')) {
      const [xFunc, yFunc] = input.split(';').map(s => s.trim());
      graphFunctions = [{ x: xFunc, y: yFunc }];
      graphPlotMode = 'parametric';
    } else {
      graphFunctions = [input];
      graphPlotMode = 'cartesian';
    }
    
    plotGraph();
  });
}

if (graphClearBtn) {
  graphClearBtn.addEventListener("click", () => {
    graphFunctions = [];
    graphFunc.value = "x^2";
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    graphShowDerivative = false;
    graphShowZeros = false;
    graphShowExtrema = false;
    graphShowTangent = null;
    graphPlotMode = 'cartesian';
    
    if (graphCtx) {
      const w = graphCanvas.width;
      const h = graphCanvas.height;
      graphCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg').trim();
      graphCtx.fillRect(0, 0, w, h);
    }
    graphInfo.textContent = "";
  });
}

if (graphAddBtn) {
  graphAddBtn.addEventListener("click", () => {
    const input = graphFunc.value.trim();
    if (!input) return;
    
    // Check ob schon vorhanden
    const exists = graphFunctions.some(f => 
      typeof f === 'string' ? f === input : false
    );
    
    if (!exists) {
      if (input.includes(';')) {
        const [xFunc, yFunc] = input.split(';').map(s => s.trim());
        graphFunctions.push({ x: xFunc, y: yFunc });
        graphPlotMode = 'parametric';
      } else {
        graphFunctions.push(input);
      }
      plotGraph();
    }
  });
}

// Zoom und Pan mit Maus
if (graphCanvas) {
  // Zoom mit Mausrad
  graphCanvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.85 : 1.15;
    graphZoom.scale = Math.max(0.1, Math.min(100, graphZoom.scale * zoomFactor));
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  }, { passive: false });
  
  // Pan mit Drag
  graphCanvas.addEventListener('mousedown', (e) => {
    if (!e.shiftKey) {
      graphDragStart = { x: e.offsetX, y: e.offsetY };
      graphCanvas.style.cursor = 'grabbing';
    }
  });
  
  graphCanvas.addEventListener('mousemove', (e) => {
    if (graphDragStart && graphFunctions.length > 0) {
      const dx = e.offsetX - graphDragStart.x;
      const dy = e.offsetY - graphDragStart.y;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const xRange = (xMax - xMin) / graphZoom.scale;
      
      // Verbesserte Pan-SensitivitÃ¤t
      const sensitivity = 1.5;
      graphZoom.offsetX -= (dx / graphCanvas.offsetWidth) * xRange * sensitivity;
      graphZoom.offsetY += (dy / graphCanvas.offsetHeight) * xRange * sensitivity;
      
      graphDragStart = { x: e.offsetX, y: e.offsetY };
      plotGraph();
    }
  });
  
  graphCanvas.addEventListener('mouseup', () => {
    graphDragStart = null;
    graphCanvas.style.cursor = 'grab';
  });
  
  graphCanvas.addEventListener('mouseleave', () => {
    graphDragStart = null;
    graphCanvas.style.cursor = 'grab';
  });
  
  // Klick fÃ¼r Tangente (Shift + Click)
  graphCanvas.addEventListener('click', (e) => {
    if (e.shiftKey && graphFunctions.length > 0 && graphPlotMode === 'cartesian') {
      const rect = graphCanvas.getBoundingClientRect();
      const xClick = e.clientX - rect.left;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const pad = 60;
      
      const xRange = (xMax - xMin) / graphZoom.scale;
      const xCenter = (xMax + xMin) / 2 + graphZoom.offsetX;
      const adjXMin = xCenter - xRange / 2;
      const adjXMax = xCenter + xRange / 2;
      
      const xVal = adjXMin + ((xClick - pad) / (graphCanvas.offsetWidth - 2 * pad)) * (adjXMax - adjXMin);
      graphShowTangent = xVal;
      plotGraph();
    }
  });
  
  // Doppelklick zum ZurÃ¼cksetzen von Zoom und Pan
  graphCanvas.addEventListener('dblclick', (e) => {
    if (!e.shiftKey) {
      graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
      graphShowTangent = null;
      updateZoomDisplay();
      if (graphFunctions.length > 0) plotGraph();
    }
  });
  
  // Touch-Support fÃ¼r iPad/Tablet
  let touchStartDistance = 0;
  let touchStartZoom = 1;
  
  graphCanvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      // Pinch-to-Zoom
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      touchStartDistance = Math.sqrt(dx * dx + dy * dy);
      touchStartZoom = graphZoom.scale;
      e.preventDefault();
    } else if (e.touches.length === 1) {
      // Pan
      const rect = graphCanvas.getBoundingClientRect();
      graphDragStart = { 
        x: e.touches[0].clientX - rect.left, 
        y: e.touches[0].clientY - rect.top 
      };
    }
  }, { passive: false });
  
  graphCanvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      // Pinch-to-Zoom
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const zoomFactor = distance / touchStartDistance;
      graphZoom.scale = Math.max(0.1, Math.min(100, touchStartZoom * zoomFactor));
      updateZoomDisplay();
      if (graphFunctions.length > 0) plotGraph();
      e.preventDefault();
    } else if (e.touches.length === 1 && graphDragStart) {
      // Pan
      const rect = graphCanvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      const dx = x - graphDragStart.x;
      const dy = y - graphDragStart.y;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const xRange = (xMax - xMin) / graphZoom.scale;
      
      const sensitivity = 1.5;
      graphZoom.offsetX -= (dx / graphCanvas.offsetWidth) * xRange * sensitivity;
      graphZoom.offsetY += (dy / graphCanvas.offsetHeight) * xRange * sensitivity;
      
      graphDragStart = { x, y };
      if (graphFunctions.length > 0) plotGraph();
      e.preventDefault();
    }
  }, { passive: false });
  
  graphCanvas.addEventListener('touchend', () => {
    graphDragStart = null;
    touchStartDistance = 0;
  });
}

// Tastatur-Shortcuts fÃ¼r Graph-Plotter
document.addEventListener('keydown', (e) => {
  // Nur wenn der Graph-Bereich aktiv ist
  if (!document.querySelector('#toolsSection.section.active')) return;
  
  // D-Taste: Toggle Ableitung
  if (e.key === 'd' || e.key === 'D') {
    graphShowDerivative = !graphShowDerivative;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // Z-Taste: Toggle Nullstellen
  if (e.key === 'z' || e.key === 'Z') {
    graphShowZeros = !graphShowZeros;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // E-Taste: Toggle Extrema
  if (e.key === 'e' || e.key === 'E') {
    graphShowExtrema = !graphShowExtrema;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // T-Taste: Toggle Tangente
  if (e.key === 't' || e.key === 'T') {
    if (graphShowTangent !== null) {
      graphShowTangent = null;
    }
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // P-Taste: Toggle Polar-Modus
  if (e.key === 'p' || e.key === 'P') {
    graphPlotMode = graphPlotMode === 'polar' ? 'cartesian' : 'polar';
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // R-Taste: Reset Zoom
  if (e.key === 'r' || e.key === 'R') {
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
});

// Button Event-Listener fÃ¼r neue Features
const graphDerivBtn = document.getElementById('graphDerivBtn');
const graphZerosBtn = document.getElementById('graphZerosBtn');
const graphExtremaBtn = document.getElementById('graphExtremaBtn');
const graphPolarBtn = document.getElementById('graphPolarBtn');
const graphZoomInBtn = document.getElementById('graphZoomInBtn');
const graphZoomOutBtn = document.getElementById('graphZoomOutBtn');
const graphResetZoomBtn = document.getElementById('graphResetZoomBtn');
const graphPanUpBtn = document.getElementById('graphPanUpBtn');
const graphPanDownBtn = document.getElementById('graphPanDownBtn');
const graphPanLeftBtn = document.getElementById('graphPanLeftBtn');
const graphPanRightBtn = document.getElementById('graphPanRightBtn');
const graphCenterBtn = document.getElementById('graphCenterBtn');

if (graphDerivBtn) {
  graphDerivBtn.addEventListener('click', () => {
    graphShowDerivative = !graphShowDerivative;
    updateButtonState(graphDerivBtn, graphShowDerivative);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphZerosBtn) {
  graphZerosBtn.addEventListener('click', () => {
    graphShowZeros = !graphShowZeros;
    updateButtonState(graphZerosBtn, graphShowZeros);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphExtremaBtn) {
  graphExtremaBtn.addEventListener('click', () => {
    graphShowExtrema = !graphShowExtrema;
    updateButtonState(graphExtremaBtn, graphShowExtrema);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPolarBtn) {
  graphPolarBtn.addEventListener('click', () => {
    graphPlotMode = graphPlotMode === 'polar' ? 'cartesian' : 'polar';
    updateButtonState(graphPolarBtn, graphPlotMode === 'polar');
    if (graphFunctions.length > 0) plotGraph();
  });
}

// Zoom Buttons
if (graphZoomInBtn) {
  graphZoomInBtn.addEventListener('click', () => {
    graphZoom.scale = Math.min(100, graphZoom.scale * 1.3);
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphZoomOutBtn) {
  graphZoomOutBtn.addEventListener('click', () => {
    graphZoom.scale = Math.max(0.1, graphZoom.scale / 1.3);
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphResetZoomBtn) {
  graphResetZoomBtn.addEventListener('click', () => {
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    graphShowTangent = null;
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

// Pan Buttons
const panAmount = 0.2; // 20% des sichtbaren Bereichs

if (graphPanUpBtn) {
  graphPanUpBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetY += xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanDownBtn) {
  graphPanDownBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetY -= xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanLeftBtn) {
  graphPanLeftBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetX -= xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanRightBtn) {
  graphPanRightBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetX += xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphCenterBtn) {
  graphCenterBtn.addEventListener('click', () => {
    graphZoom.offsetX = 0;
    graphZoom.offsetY = 0;
    if (graphFunctions.length > 0) plotGraph();
  });
}


if (els.runBtn) els.runBtn.addEventListener("click", runSingle);
if (els.addBtn) els.addBtn.addEventListener("click", addRun);
if (els.clearBtn) els.clearBtn.addEventListener("click", resetAll);

if (els.exportPlotBtn) els.exportPlotBtn.addEventListener("click", () => {
  const url = els.canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = `wachstum_plot_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.png`;
  document.body.appendChild(a);
  a.click();
  a.remove();
});



if (els.axisLockBtn) els.axisLockBtn.addEventListener("click", () => {
  axisLock.locked = true;

  // fixiere X auf aktuelle Simulationsdauer
  axisLock.maxT = Number(els.tmax?.value ?? 24);

  // fixiere Y auf aktuell sichtbare Daten (max aus Runs) ODER K0
  const maxFromRuns = runs.length
    ? Math.max(...runs.flatMap(r => (r.points?.length ? r.points.map(p => p.N) : [0])))
    : 0;

  const k0 = Number(els.K0?.value ?? 200000);
  axisLock.maxN = Math.max(maxFromRuns, k0, 1);

  plotRuns();
});

if (els.axisAutoBtn) els.axisAutoBtn.addEventListener("click", () => {
  axisLock.locked = false;
  axisLock.maxT = null;
  axisLock.maxN = null;
  plotRuns();
});

// ===== Manuelle Achsen-Steuerung Bio-Simulation =====
const bioManualAxisDiv = document.getElementById('bioManualAxisDiv');
const bioToggleManualAxisBtns = document.querySelectorAll('#bioToggleManualAxis');
const bioApplyAxisBtn = document.getElementById('bioApplyAxisBtn');
const bioAxisTmin = document.getElementById('bioAxisTmin');
const bioAxisTmax = document.getElementById('bioAxisTmax');
const bioAxisNmin = document.getElementById('bioAxisNmin');
const bioAxisNmax = document.getElementById('bioAxisNmax');

bioToggleManualAxisBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    bioManualAxisDiv.style.display = bioManualAxisDiv.style.display === 'none' ? 'block' : 'none';
  });
});

if (bioApplyAxisBtn) {
  bioApplyAxisBtn.addEventListener('click', () => {
    axisLock.locked = true;
    axisLock.minT = Number(bioAxisTmin.value) || 0;
    axisLock.maxT = Number(bioAxisTmax.value) || 24;
    axisLock.minN = Number(bioAxisNmin.value) || 0;
    axisLock.maxN = Number(bioAxisNmax.value) || 200000;
    plotRuns();
  });
}

// ===== Manuelle Y-Achsen-Steuerung Graph-Plotter =====
const graphToggleYAxis = document.getElementById('graphToggleYAxis');
const graphManualYAxisDiv = document.getElementById('graphManualYAxisDiv');
const graphApplyYAxis = document.getElementById('graphApplyYAxis');
const graphResetYAxis = document.getElementById('graphResetYAxis');
const graphYmin = document.getElementById('graphYmin');
const graphYmax = document.getElementById('graphYmax');

let manualYAxis = { enabled: false, yMin: null, yMax: null };

if (graphToggleYAxis) {
  graphToggleYAxis.addEventListener('click', () => {
    graphManualYAxisDiv.style.display = graphManualYAxisDiv.style.display === 'none' ? 'block' : 'none';
  });
}

if (graphApplyYAxis) {
  graphApplyYAxis.addEventListener('click', () => {
    const yMin = graphYmin.value;
    const yMax = graphYmax.value;
    if (yMin !== '' && yMax !== '') {
      manualYAxis.enabled = true;
      manualYAxis.yMin = Number(yMin);
      manualYAxis.yMax = Number(yMax);
      plotGraph();
    }
  });
}

if (graphResetYAxis) {
  graphResetYAxis.addEventListener('click', () => {
    manualYAxis.enabled = false;
    manualYAxis.yMin = null;
    manualYAxis.yMax = null;
    graphYmin.value = '';
    graphYmax.value = '';
    plotGraph();
  });
}


// Startbild
runSingle();
  });
})();

</script>








</html
>

</body>
</html>
