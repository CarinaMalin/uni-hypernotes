<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Uni Hyper Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    :root {
      --bg: #161821;
      --bg-gradient: radial-gradient(circle at top, #2a3245 0, #10121a 45%, #05060a 100%);
      --bg-elevated: #1f2230;
      --bg-sidebar: #181b27;
      --border: #2f3445;
      --text: #f7f7ff;
      --muted: #a4aac5;
      --accent: #7b8cff;
      --accent-soft: rgba(123, 140, 255, 0.16);
      --danger: #ff6b81;
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.55);
      --radius-card: 18px;
    }

    .light {
      --bg: #f5f5fb;
      --bg-gradient: radial-gradient(circle at top, #ffffff 0, #eceefd 40%, #dde2ff 100%);
      --bg-elevated: #ffffff;
      --bg-sidebar: #f1f3ff;
      --border: #d3d7f0;
      --text: #1a1c2c;
      --muted: #6f7593;
      --accent: #4a5cff;
      --accent-soft: rgba(74, 92, 255, 0.18);
      --danger: #ff4d6a;
      --shadow-soft: 0 16px 40px rgba(32, 36, 90, 0.18);
      --radius-card: 18px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    /* ---------- Topbar ---------- */

    #topbar {
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
      background: rgba(5, 7, 15, 0.9);
      backdrop-filter: blur(18px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      z-index: 20;
    }

    body.light #topbar {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 12px 30px rgba(39, 46, 120, 0.25);
    }

    #topbar-left,
    #topbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #appTitle {
      font-weight: 800;
      font-size: 17px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #appTitle::before {
      content: "üìö";
      font-size: 16px;
    }

    button,
    select,
    input,
    textarea {
      font-family: inherit;
      font-size: 13px;
    }

    button,
    select {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 6px 11px;
      background: rgba(9, 11, 25, 0.9);
      color: var(--text);
      cursor: pointer;
      outline: none;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.15s ease transform, 0.15s ease box-shadow, 0.15s ease background-color, 0.15s ease border-color;
    }

    body.light button,
    body.light select {
      background: rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 0, 0, 0.05);
    }

    button:hover {
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0px) scale(0.97);
      box-shadow: none;
    }

    #darkModeBtn {
      font-size: 14px;
      padding-inline: 10px;
    }

    /* ---------- Tabbar ---------- */

    #tabbar {
      display: flex;
      align-items: center;
      padding: 5px 10px;
      background: radial-gradient(circle at top left, rgba(123, 140, 255, 0.2), transparent 40%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      gap: 4px;
      flex-wrap: wrap;
    }

    .tab-btn {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 4px 11px 5px;
      font-size: 12px;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.16s ease background-color, 0.16s ease color, 0.16s ease transform;
    }

    .tab-btn::before {
      font-size: 13px;
    }

    .tab-btn[data-tab="notes"]::before { content: "‚úèÔ∏è"; }
    .tab-btn[data-tab="cards"]::before { content: "üé¥"; }
    .tab-btn[data-tab="planner"]::before { content: "üóìÔ∏è"; }
    .tab-btn[data-tab="formulas"]::before { content: "‚àë"; }
    .tab-btn[data-tab="tools"]::before { content: "üßÆ"; }
    .tab-btn[data-tab="learn"]::before { content: "üìñ"; }
    .tab-btn[data-tab="tasks"]::before { content: "üìå"; }
    .tab-btn[data-tab="brain"]::before { content: "üí≠"; }
    .tab-btn[data-tab="stats"]::before { content: "üìä"; }

    .tab-btn.active {
      background: var(--accent-soft);
      border-color: rgba(255, 255, 255, 0.16);
      color: var(--text);
      transform: translateY(-1px);
    }

    /* ---------- Main Layout ---------- */

    #main {
      flex: 1;
      display: flex;
      min-height: 0;
      padding: 10px 10px 12px 10px;
      gap: 10px;
    }

    /* ---------- Notizen-Bereich ---------- */

    #notesLayout.section {
      flex: 1;
      display: none;
      min-height: 0;
      background: transparent;
    }

    #notesLayout.section.active {
      display: flex;
    }

    #sidebarNotes {
      width: 130px;
      background: linear-gradient(180deg, rgba(15, 18, 32, 0.98), rgba(12, 14, 26, 0.98));
      border-radius: var(--radius-card);
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow: var(--shadow-soft);
      padding: 10px 8px 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #sidebar-section-title {
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.72;
    }

    #sidebarNotes button {
      font-size: 11px;
      padding: 3px 8px;
    }

    #templateSelect {
      width: 100%;
      margin-top: 4px;
      font-size: 11px;
      padding-block: 4px;
    }

    #pageList {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
      margin-top: 4px;
    }

    .page-thumb {
      position: relative;
      background: rgba(10, 12, 24, 0.96);
      border-radius: 12px;
      border: 1.5px solid transparent;
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.5);
      margin-bottom: 7px;
      cursor: pointer;
      padding: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      text-align: center;
      color: var(--muted);
      transition: 0.15s ease border-color, 0.15s ease transform, 0.15s ease background-color;
    }

    .page-thumb.active {
      border-color: var(--accent);
      background: rgba(123, 140, 255, 0.18);
      color: var(--text);
      transform: translateY(-1px);
    }

    .page-thumb span.index {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 9px;
      opacity: 0.7;
    }

    #canvasWrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6px;
      min-width: 0;
      gap: 8px;
    }

    #toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      background: radial-gradient(circle at top left, rgba(123, 140, 255, 0.3), rgba(15, 16, 32, 0.98));
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: var(--shadow-soft);
      flex-wrap: wrap;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    body.light #toolbar {
      background: radial-gradient(circle at top left, rgba(123, 140, 255, 0.16), #ffffff);
    }

    #canvas {
      background: #fbfbff;
      border-radius: 22px;
      box-shadow: 0 22px 55px rgba(5, 6, 17, 0.85);
      touch-action: none;
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    body.light #canvas {
      background: #ffffff;
    }

    input[type="color"] {
      border: none;
      background: transparent;
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 999px;
      overflow: hidden;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);
    }

    .tool-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 4px 10px;
      font-size: 12px;
      background: rgba(6, 8, 20, 0.9);
      cursor: pointer;
      color: var(--muted);
    }

    .tool-btn.active {
      border-color: var(--accent);
      background: rgba(123, 140, 255, 0.28);
      color: var(--text);
    }

    .stroke-btn {
      padding: 3px 8px;
      font-size: 11px;
      opacity: 0.85;
    }

    .stroke-btn.active {
      border-color: var(--accent);
      background: rgba(123, 140, 255, 0.18);
      color: var(--text);
    }

    label {
      font-size: 11px;
      opacity: 0.8;
    }

    /* ---------- Generische Sektionen (andere Tabs) ---------- */

    .section {
      flex: 1;
      padding: 0;
      display: none;
      overflow: auto;
    }

    .section.active {
      display: block;
    }

    .card {
      background: var(--bg-elevated);
      border-radius: var(--radius-card);
      padding: 11px 12px;
      margin-bottom: 10px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .card h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card h3::before {
      content: "‚Ä¢";
      font-size: 18px;
      color: var(--accent);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .row > * {
      flex: 1;
      min-width: 150px;
    }

    input[type="text"],
    input[type="date"],
    input[type="number"],
    textarea,
    select#notebookSelect,
    select#templateSelect,
    select#studyDeckSelect {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 7px 11px;
      background: rgba(7, 9, 20, 0.9);
      color: var(--text);
      width: 100%;
      box-sizing: border-box;
    }

    body.light input[type="text"],
    body.light input[type="date"],
    body.light input[type="number"],
    body.light textarea,
    body.light select {
      background: rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 0, 0, 0.06);
    }

    textarea {
      min-height: 70px;
      border-radius: 14px;
      line-height: 1.4;
      resize: vertical;
    }

    .pill {
      border-radius: 999px;
      padding: 2px 9px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: inline-block;
      margin-right: 4px;
      margin-bottom: 4px;
      background: rgba(15, 18, 40, 0.9);
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      font-size: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
    }

    /* ---------- Lernen-Layout ---------- */
    #learnLayout {
      display: flex;
      gap: 10px;
      height: 100%;
    }

    #learnSidebar {
      width: 210px;
      background: var(--bg-sidebar);
      border-radius: var(--radius-card);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: var(--shadow-soft);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #learnSubjects,
    #learnTopics {
      margin-top: 4px;
      padding: 0;
      list-style: none;
      max-height: 40%;
      overflow-y: auto;
    }

    .learn-item {
      padding: 5px 9px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      margin-bottom: 4px;
      background: rgba(0,0,0,0.08);
      color: var(--muted);
      transition: 0.15s;
    }

    .learn-item.active {
      background: var(--accent-soft);
      color: var(--text);
    }

    #learnContent {
      flex: 1;
      overflow-y: auto;
    }

    .learn-heading {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .learn-subheading {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 8px;
    }

    .learn-section-title {
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      margin-bottom: 4px;
    }

    .learn-list {
      margin-top: 0;
      padding-left: 18px;
      font-size: 13px;
    }

    .learn-chiprow {
      margin-top: 4px;
      margin-bottom: 6px;
    }

    .learn-chip {
      display: inline-block;
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
      margin-right: 4px;
      margin-bottom: 4px;
    }

    @media (max-width: 860px) {
      #sidebarNotes { width: 105px; }
      button, select { font-size: 11px; padding: 4px 9px; }
      #toolbar { font-size: 11px; padding-inline: 10px; }
      #learnLayout { flex-direction: column; }
      #learnSidebar { width: 100%; flex-direction: row; overflow-x: auto; }
    }
  </style>

<style>
  /* Pinch-to-Zoom: verhindert Browser-eigenes Zoomen/Scrollen */
  #canvasWrapper, #canvas {
    touch-action: none;
  }
</style>

</head>
<body>
  <!-- TOPBAR -->
  <div id="topbar">
    <div id="topbar-left">
      <div id="appTitle">Uni Hyper Notes</div>
      <select id="notebookSelect"></select>
      <button id="addNotebookBtn">Ôºã Notizbuch</button>
    </div>
    <div id="topbar-right">
      <button id="darkModeBtn">üåô / ‚òÄÔ∏è</button>
      <button id="exportPageBtn">üñºÔ∏è Seite als PNG</button>
      <button id="exportJsonBtn">üíæ Backup</button>
              <button id="importJsonBtn">üìÇ Backup laden</button>
              <input type="file" id="importJsonInput" accept="application/json" style="display:none;">
    </div>
  </div>

  <!-- TABBAR -->
  <div id="tabbar">
    <button class="tab-btn active" data-tab="notes">Notizen</button>
    <button class="tab-btn" data-tab="cards">Karteikarten</button>
    <button class="tab-btn" data-tab="planner">Planer</button>
    <button class="tab-btn" data-tab="formulas">Formeln</button>
    <button class="tab-btn" data-tab="tools">Tools</button>
    <button class="tab-btn" data-tab="learn">Lernen</button>
    <button class="tab-btn" data-tab="tasks">Aufgaben</button>
    <button class="tab-btn" data-tab="brain">Brain-Dump</button>
    <button class="tab-btn" data-tab="stats">Stats</button>
  </div>

  <div id="main">
    <!-- NOTIZEN-TAB -->
    <div id="notesLayout" class="section active">
      <div id="sidebarNotes">
        <div id="sidebar-header">
          <div><div id="sidebar-section-title">Seiten</div></div>
          <button id="addPageBtn" title="Neue Seite">Ôºã</button>
        </div>
        <div>
          <label for="templateSelect">Template:</label><br>
          <select id="templateSelect">
            <option value="blank">Blanko</option>
            <option value="lined">Liniert</option>
            <option value="dotted">Dotted</option>
            <option value="grid">Kariert</option>
          </select>
        </div>

<div style="margin-top:6px;">
  <label for="templateSizeSelect">Rastergr√∂√üe:</label><br>
  <select id="templateSizeSelect">
    <option value="small">Fein</option>
    <option value="medium" selected>Mittel</option>
    <option value="large">Gro√ü</option>
  </select>
</div>


        <div id="pageList"></div>
      </div>

      <div id="canvasWrapper">
        <div id="toolbar">
          <label>Tool:</label>
          <button class="tool-btn active" data-tool="pen">Stift</button>
          <button class="tool-btn" data-tool="highlighter">Marker</button>
          <button class="tool-btn" data-tool="eraser">Radierer</button>
          <button class="tool-btn" data-tool="line">Linie</button>
          <button class="tool-btn" data-tool="rect">Rechteck</button>
          <button class="tool-btn" data-tool="circle">Kreis</button>

          <label>Farbe:</label>
          <input type="color" id="colorPicker" value="#000000">

          <label>St√§rke:</label>
          <button class="stroke-btn active" data-width="2">D√ºnn</button>
          <button class="stroke-btn" data-width="5">Mittel</button>
          <button class="stroke-btn" data-width="9">Dick</button>

          <button id="undoBtn">‚Ü∂ Undo</button>
          <button id="redoBtn">‚Ü∑ Redo</button>

          <button id="clearBtn">üßπ Seite leeren</button>
        </div>

        <canvas id="canvas"></canvas>
      </div>
    </div>

    <!-- KARTEIKARTEN-TAB -->
    <div id="cardsSection" class="section">
      <div class="card">
        <h3>Karteikarten-Decks</h3>
        <div class="row">
          <div>
            <input type="text" id="cardDeckName" placeholder="Neues Deck (z.B. Allgemeine Chemie)">
          </div>
          <div style="flex:0 0 auto;">
            <button id="addDeckBtn">Ôºã Deck</button>
          </div>
        </div>
        <div id="deckList"></div>
      </div>

      <div class="card">
        <h3>Karteikarten in Deck</h3>
        <div class="row">
          <div><textarea id="cardQuestion" placeholder="Frage / Vorderseite"></textarea></div>
          <div><textarea id="cardAnswer" placeholder="Antwort / R√ºckseite"></textarea></div>
        </div>
        <div class="row">
          <div><input type="text" id="cardTags" placeholder="Tags (z.B. S√§ure-Base, wichtig)"></div>
          <div style="flex:0 0 auto;"><button id="addCardBtn">Ôºã Karte speichern</button></div>
        </div>
        <div id="cardList"></div>
      </div>

      <div class="card">
        <h3>Lernmodus (Spaced-Repetition light)</h3>
        <div class="row">
          <div><select id="studyDeckSelect"></select></div>
          <div style="flex:0 0 auto;"><button id="startStudyBtn">Lernen starten</button></div>
        </div>
        <div id="studyArea" style="margin-top:8px; display:none;">
          <div id="studyQuestion" style="margin-bottom:6px; font-weight:600;"></div>
          <div id="studyAnswer" style="margin-bottom:6px; display:none;"></div>
          <button id="revealAnswerBtn">Antwort anzeigen</button>
          <div style="margin-top:6px; display:none;" id="studyFeedback">
            <span style="font-size:12px;">Wie gut wusstest du es?</span><br>
            <button class="studyGradeBtn" data-grade="0">Keine Ahnung</button>
            <button class="studyGradeBtn" data-grade="1">Schwer</button>
            <button class="studyGradeBtn" data-grade="2">Okay</button>
            <button class="studyGradeBtn" data-grade="3">Super</button>
          </div>
        </div>
      </div>
    </div>

    <!-- PLANER-TAB -->
    <div id="plannerSection" class="section">
      <div class="card">
        <h3>Deine n√§chsten Pr√ºfungen</h3>
        <div class="row">
          <div><input type="text" id="examName" placeholder="Modul / Pr√ºfung"></div>
          <div><input type="date" id="examDate"></div>
          <div><input type="number" id="examWeight" placeholder="ECTS / Wichtigkeit" min="1"></div>
          <div style="flex:0 0 auto;"><button id="addExamBtn">Ôºã Pr√ºfung speichern</button></div>
        </div>
        <div id="examList"></div>
      </div>

      <div class="card">
        <h3>Fokus heute</h3>
        <div class="row">
          <div><input type="text" id="blockTopic" placeholder="Thema (z.B. Allg. Chemie ‚Äì S√§ure-Base)"></div>
          <div><input type="number" id="blockMinutes" placeholder="Minuten (z.B. 45)" min="5"></div>
          <div style="flex:0 0 auto;"><button id="startBlockBtn">‚è±Ô∏è Fokus starten</button></div>
        </div>
        <div id="focusStatus" style="margin-top:6px; font-size:13px;"></div>
      </div>
    </div>

    <!-- FORMELN-TAB -->
    <div id="formulasSection" class="section">
      <div class="card">
        <h3>Formel hinzuf√ºgen</h3>
        <div class="row">
          <div><input type="text" id="formulaName" placeholder="Name (z.B. ideale Gasgleichung)"></div>
          <div><input type="text" id="formulaExpression" placeholder="Formel (z.B. p¬∑V = n¬∑R¬∑T)"></div>
        </div>
        <div class="row">
          <div><input type="text" id="formulaTopic" placeholder="Thema (z.B. Allgemeine Chemie / Thermodynamik)"></div>
          <div><input type="text" id="formulaVariables" placeholder="Variablen & Einheiten (p=..., V=..., ...)"></div>
        </div>
        <div class="row">
          <div><textarea id="formulaNotes" placeholder="Hinweise, typische Fehler, etc."></textarea></div>
          <div style="flex:0 0 auto; align-self:flex-end; display:flex; flex-direction:column; gap:6px;">
            <button id="addFormulaBtn">Ôºã Formel speichern</button>
            <button id="loadBiotechFormulasBtn" type="button">üì• Biotech-Basisformeln laden</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Formelsammlung</h3>
        <input type="text" id="formulaFilter" placeholder="Suche nach Name / Thema..." style="margin-bottom:6px;">
        <div id="formulaList"></div>
      </div>
    </div>

    <!-- TOOLS-TAB (Rechentool) -->
    <div id="toolsSection" class="section">
      <div class="card">
        <h3>Chemie-Rechentool</h3>
        <div class="row">
          <div>
            <select id="toolFormulaSelect">
              <option value="dilution">Verd√ºnnung (c‚ÇÅ¬∑V‚ÇÅ = c‚ÇÇ¬∑V‚ÇÇ)</option>
              <option value="lambert">Lambert-Beer-Gesetz (A = Œµ¬∑c¬∑l)</option>
            </select>
          </div>
        </div>
        <div id="toolInputs" style="margin-top:8px;"></div>
        <div style="margin-top:6px;">
          <button id="toolCalcBtn">Berechnen</button>
          <span id="toolResult" style="font-size:13px; margin-left:8px;"></span>
        </div>
      </div>
    </div>

    <!-- LERNEN-TAB -->
    <div id="learnSection" class="section">
      <div id="learnLayout">
        <div id="learnSidebar">
          <div>
            <div style="font-size:11px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.7;">F√§cher</div>
            <ul id="learnSubjects"></ul>
          </div>
          <div>
            <div style="font-size:11px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.7; margin-top:6px;">Themen</div>
            <ul id="learnTopics"></ul>
          </div>
        </div>
        <div id="learnContent">
          <!-- wird per JS gef√ºllt -->
        </div>
      </div>
    </div>

    <!-- AUFGABEN-TAB -->
    <div id="tasksSection" class="section">
      <div class="card">
        <h3>Rechenaufgabe / Verst√§ndnisaufgabe hinzuf√ºgen</h3>
        <div class="row">
          <div><input type="text" id="taskTitle" placeholder="Kurzbeschreibung (z.B. pV=nRT umstellen)"></div>
          <div><input type="text" id="taskTopic" placeholder="Thema / Modul (z.B. Allg. Chemie)"></div>
        </div>
        <div class="row">
          <div><textarea id="taskText" placeholder="Aufgabe (Text oder kopierter Inhalt)"></textarea></div>
          <div><textarea id="taskNotes" placeholder="Dein L√∂sungsweg / Notizen (optional)"></textarea></div>
        </div>
        <div class="row">
          <div style="flex:0 0 auto;"><button id="addTaskBtn">Ôºã Aufgabe speichern</button></div>
        </div>
      </div>

      <div class="card">
        <h3>Aufgaben-Liste</h3>
        <div id="taskList"></div>
      </div>
    </div>

    <!-- BRAIN-DUMP-TAB -->
    <div id="brainSection" class="section">
      <div class="card">
        <h3>Brain-Dump (Gedanken, Sorgen, Ideen)</h3>
        <textarea id="brainText" placeholder="Alles, was im Kopf rumschwirrt..."></textarea>
        <div style="margin-top:6px;">
          <button id="saveBrainBtn">Speichern</button>
          <span id="brainStatus" style="font-size:11px; opacity:0.7; margin-left:6px;"></span>
        </div>
      </div>

      <div class="card">
        <h3>Vergangene Eintr√§ge</h3>
        <div id="brainHistory"></div>
      </div>
    </div>

    <!-- STATS-TAB -->
    <!-- STATS-TAB -->
<div id="statsSection" class="section">
  	<div class="card">
   	 <h3>Lern-Stats (einfach)</h3>
   	 <div id="statsContent"></div>
  	</div>

  <div class="card">
    	<h3>Sync-Einstellungen</h3>
   	 <div class="row">
     		 <div>
        <input type="text" id="syncIdInput" placeholder="z.B. CARINA-UNI-01">
      </div>
      <div style="flex:0 0 auto;">
        <button id="syncSaveIdBtn">Sync-ID speichern</button>
      </div>
    </div>
    <div style="margin-top:6px; font-size:12px; opacity:0.8;">
      Ger√§te mit der gleichen Sync-ID greifen auf dieselben Cloud-Daten zu.
      Wenn du keine Sync-ID setzt, bleibt alles nur lokal auf diesem Ger√§t.
    </div>
    <div id="syncStatus" style="margin-top:4px; font-size:11px; opacity:0.7;"></div>
  </div>
</div>


<script type="module">

// ---------- Firebase Setup ----------
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC0gBG9LNOOjWib7u5a5Ztq2bd9MGg7k",
  authDomain: "uni-hyper-notes.firebaseapp.com",
  projectId: "uni-hyper-notes",
  storageBucket: "uni-hyper-notes.firebasestorage.app",
  messagingSenderId: "1430311668000",
  appId: "1:1430311668000:web:802d30dea4e71fabfa77f45",
  measurementId: "G-2QN7W0W73K"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Sync-ID
let syncId = localStorage.getItem("uniHyperNotes_syncId") || null;

function askForSyncId() {
  if (!syncId) {
    const defaultId = "user-" + Math.random().toString(36).slice(2, 8);
    const entered = prompt("Sync-ID eingeben oder neue anlegen:", defaultId);
    syncId = (entered || defaultId).trim();
    localStorage.setItem("uniHyperNotes_syncId", syncId);
  }
  return syncId;
}

// --- Elemente f√ºr die Sync-UI ---
const syncIdInput  = document.getElementById("syncIdInput");
const syncSaveBtn  = document.getElementById("syncSaveIdBtn");
const syncStatusEl = document.getElementById("syncStatus");

// Sync-ID ins Eingabefeld schreiben (falls schon vorhanden)
if (syncIdInput && syncId) {
  syncIdInput.value = syncId;
}

// Statusanzeige bequem setzen
function updateSyncStatus(msg) {
  if (syncStatusEl) {
    syncStatusEl.textContent = msg;
  }
  console.log("[SYNC]", msg);
}

// ---------- LERN-DATEN (Allgemeine Chemie, erweitert) ----------
const learnData = {
  subjects: [
    {
      id: "allg-chem",
      name: "Allgemeine Chemie",
      description:
        "Grundlagen des Aufbaus der Materie, chemische Bindungen, St√∂chiometrie, S√§ure-Base, Redox, Titrationen & Laborsicherheit ‚Äì auf Klausur-Niveau.",
      topics: [
        {
          id: "aufbau-materie",
          title: "Aufbau der Materie & Atome",
          tags: ["Atome", "Elektronenh√ºlle", "Kern"],
          goals: [
            "Aufbau von Atomen (Protonen, Neutronen, Elektronen) sicher erkl√§ren.",
            "Ordnungszahl, Massenzahl und Isotope unterscheiden und Beispiele angeben.",
            "Elektronenkonfiguration f√ºr einfache Elemente schreiben (z. B. H, He, C, O, Na, Cl)."
          ],
          summary:
            "Materie besteht aus Atomen. Ein Atom besitzt einen positiv geladenen Kern (Protonen und Neutronen) und eine negativ geladene Elektronenh√ºlle. Die Ordnungszahl Z entspricht der Protonenzahl und definiert das Element. Isotope haben dieselbe Protonenzahl, aber unterschiedliche Neutronenzahlen. F√ºr die Chemie sind vor allem die Valenzelektronen (Au√üenelektronen) entscheidend, da sie an Bindungen beteiligt sind.",
          keyPoints: [
            "Ordnungszahl Z = Anzahl der Protonen = Anzahl der Elektronen im neutralen Atom.",
            "Massenzahl A ‚âà Protonen + Neutronen; Neutronenzahl N = A ‚àí Z.",
            "Isotope: z. B. ¬π¬≤C, ¬π¬≥C, ¬π‚Å¥C ‚Äì alle Kohlenstoff, aber mit unterschiedlicher Massenzahl.",
            "Elektronenkonfiguration zeigt Verteilung in Schalen/Unterschalen (z. B. 1s¬≤ 2s¬≤ 2p¬≤).",
            "Valenzelektronen bestimmen Reaktivit√§t (z. B. Edelgase: volle Schale ‚Üí sehr reaktionstr√§ge)."
          ],
          formulas: ["A = Z + N"],
          visual: `
            <div>Atommodell (vereinfachtes Kugelmodell):</div>
            <svg viewBox="0 0 140 80" width="140" height="80">
              <circle cx="45" cy="40" r="18" fill="rgba(123,140,255,0.35)" stroke="currentColor"/>
              <circle cx="95" cy="40" r="26" fill="none" stroke="currentColor" stroke-dasharray="4 3"/>
              <circle cx="95" cy="16" r="3" fill="currentColor"/>
              <circle cx="116" cy="40" r="3" fill="currentColor"/>
              <circle cx="74" cy="40" r="3" fill="currentColor"/>
            </svg>
            <div style="font-size:11px;opacity:0.8;margin-top:4px;">Innen: Kern (p‚Å∫, n‚Å∞) ‚Äì au√üen: Elektronen auf Schale.</div>
          `
        },
        {
          id: "periodensystem",
          title: "Periodensystem der Elemente (PSE)",
          tags: ["PSE", "Trends", "Gruppen"],
          goals: [
            "Perioden und Gruppen im PSE sicher benennen.",
            "Hauptgruppen (Alkalimetalle, Erdalkalimetalle, Halogene, Edelgase) zuordnen.",
            "Trends von Atomradius und Elektronegativit√§t qualitativ beschreiben."
          ],
          summary:
            "Das Periodensystem ordnet alle bekannten Elemente nach steigender Ordnungszahl. In einer Gruppe (Spalte) stehen Elemente mit √§hnlicher Valenzelektronenkonfiguration und √§hnlichen chemischen Eigenschaften. In einer Periode (Zeile) nimmt die Ordnungszahl von links nach rechts zu. Wichtige Trends: der Atomradius nimmt innerhalb einer Periode von links nach rechts ab, innerhalb einer Gruppe von oben nach unten zu. Die Elektronegativit√§t zeigt das umgekehrte Verhalten.",
          keyPoints: [
            "Gruppen: z. B. 1. Hauptgruppe = Alkalimetalle (Li, Na, K, ...); 17. Hauptgruppe = Halogene; 18. Hauptgruppe = Edelgase.",
            "Perioden: horizontale Zeilen ‚Äì geben an, wie viele Schalen im Atom besetzt sind.",
            "Atomradius ‚Üì nach rechts kleiner, ‚Üë nach unten gr√∂√üer.",
            "Elektronegativit√§t ‚Üë nach rechts gr√∂√üer (bis F), ‚Üë nach oben gr√∂√üer.",
            "Metalle stehen √ºberwiegend links unten, Nichtmetalle rechts oben."
          ],
          formulas: [],
          visual: `
            <div style="font-size:11px;margin-bottom:4px;">Sehr vereinfachtes Mini-PSE (nur Hauptgruppen):</div>
            <pre style="font-size:10px;line-height:1.2;">
H                                                   He
Li Be                                      B  C  N  O  F  Ne
Na Mg                                      Al Si P  S  Cl Ar
K  Ca                                      Ga Ge As Se Br Kr
            </pre>
          `
        },
        {
          id: "orbitale",
          title: "Atomorbitale: s- und p-Orbitale",
          tags: ["Orbitale", "s-Orbital", "p-Orbital"],
          goals: [
            "Begriff Orbital (Wahrscheinlichkeitswolke) formulieren.",
            "s-Orbitale als kugelf√∂rmig und p-Orbitale als hantelf√∂rmig skizzieren.",
            "F√ºr p-Orbitale die drei Raumrichtungen (p‚Çì, p·µß, p_z) angeben."
          ],
          summary:
            "Ein Orbital ist kein 'Planet auf einer Kreisbahn', sondern ein Bereich im Raum, in dem sich ein Elektron mit hoher Wahrscheinlichkeit aufh√§lt. s-Orbitale sind kugelf√∂rmig um den Kern verteilt. p-Orbitale sind hantelf√∂rmig mit zwei Lobes und besitzen drei r√§umliche Ausrichtungen (p‚Çì, p·µß, p_z). In der Klausur wird oft verlangt, ein 1s-Orbital und drei p-Orbitale zu skizzieren und sinnvoll zu beschriften.",
          keyPoints: [
            "s-Orbitale: kugelf√∂rmig, 1s liegt am niedrigsten, dann 2s, 3s ...",
            "p-Orbitale: hantelf√∂rmig, jeweils zwei 'Lappen' (Lobes) ‚Äì drei Ausrichtungen: x-, y- und z-Achse.",
            "Maximal 2 Elektronen pro Orbital (mit entgegengesetztem Spin).",
            "Skizze: s-Orbital = Kreis/Kugel; p-Orbital = zwei Kreise/Ellipsen gegen√ºberliegend mit Kern in der Mitte."
          ],
          formulas: [],
          visual: `
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <div>
                <div style="font-size:11px;margin-bottom:2px;">s-Orbital (1s)</div>
                <svg viewBox="0 0 70 70" width="70" height="70">
                  <circle cx="35" cy="35" r="22"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="35" cy="35" r="3" fill="currentColor"/>
                </svg>
              </div>
              <div>
                <div style="font-size:11px;margin-bottom:2px;">p-Orbital (z. B. p<sub>z</sub>)</div>
                <svg viewBox="0 0 90 70" width="90" height="70">
                  <circle cx="45" cy="20" r="14"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="45" cy="50" r="14"
                          fill="rgba(123,140,255,0.30)" stroke="currentColor"/>
                  <circle cx="45" cy="35" r="3" fill="currentColor"/>
                </svg>
              </div>
            </div>
            <div style="font-size:11px;opacity:0.8;margin-top:4px;">F√ºr die Klausur: Kugel f√ºr s, Hantel f√ºr p ‚Äì sauber beschriften reicht v√∂llig.</div>
          `
        },
        {
          id: "mo-n2",
          title: "Molek√ºlorbitale (MO) ‚Äì Beispiel N‚ÇÇ",
          tags: ["MO-Theorie", "N‚ÇÇ", "Bindungsordnung"],
          goals: [
            "Grundidee der MO-Theorie wiedergeben (Orbitale kombinieren zu bindenden/antibindenden MOs).",
            "Ein einfaches MO-Schema f√ºr homonukleare zweiatomige Molek√ºle skizzieren (z. B. N‚ÇÇ).",
            "Bindungsordnung f√ºr N‚ÇÇ berechnen und deuten k√∂nnen."
          ],
          summary:
            "In der MO-Theorie werden Atomorbitale zu Molek√ºlorbitalen kombiniert: bindende (energetisch niedriger) und antibindende (energetisch h√∂her). F√ºr N‚ÇÇ kombinierst du 2s- und 2p-Orbitale der beiden N-Atome. Wichtig in der Klausur: MO-Schema zeichnen, Energieniveaus sortieren und Elektronen mit Pfeilen eintragen. Danach kannst du die Bindungsordnung bestimmen.",
          keyPoints: [
            "Bindende MOs (œÉ, œÄ) liegen energetisch tiefer, antibindende (œÉ*, œÄ*) h√∂her.",
            "F√ºr N‚ÇÇ (14 e‚Åª pro Molek√ºl, also 7 pro Atom): Bindungsordnung = (Bindende e‚Åª ‚àí Antibindende e‚Åª)/2.",
            "Typisch f√ºr N‚ÇÇ: Bindungsordnung 3 ‚Üí Dreifachbindung.",
            "MO-Schema sauber mit Pfeilen (‚Üë‚Üì) f√ºllen ‚Äì Hundsche Regel & Pauli-Prinzip beachten."
          ],
          formulas: [
            "Bindungsordnung = (N<sub>bindend</sub> ‚àí N<sub>antibindend</sub>) / 2"
          ],
          visual: `
            <div style="font-size:11px;margin-bottom:4px;">Sehr vereinfachtes MO-Schema (nur qualitativ):</div>
            <pre style="font-size:10px;line-height:1.2;">
           œÉ*2p   (antibindend)
      œÄ2p  œÄ2p
           œÉ2p   (bindend)
           œÉ*2s
           œÉ2s

    Pfeile von unten nach oben eintragen (Energie ‚Üë).
            </pre>
          `
        },
        {
          id: "stoechiometrie",
          title: "St√∂chiometrie & chemisches Rechnen",
          tags: ["Molare Masse", "Stoffmenge", "Gleichungen"],
          goals: [
            "Stoffmenge aus Masse und molarer Masse berechnen.",
            "Reaktionsgleichungen korrekt nach Atomanzahl ausgleichen.",
            "Grobe √úberschlagsrechnungen beherrschen (z. B. mg ‚Üí mmol)."
          ],
          summary:
            "St√∂chiometrie beantwortet die Frage: Wie viel von welcher Substanz reagiert miteinander? Grundlage ist die Stoffmenge n in mol. √úber die molare Masse M verkn√ºpfst du Masse und Stoffmenge. In Klausuraufgaben geht es oft darum, Reaktionsgleichungen zu formulieren, auszubalancieren und aus einer gegebenen Masse oder Konzentration die gesuchte Menge zu bestimmen.",
          keyPoints: [
            "Stoffmenge: n = m / M (mit m in g, M in g/mol ‚Üí n in mol).",
            "Konzentration: c = n / V (mit V in L, c in mol/L).",
            "Reaktionsgleichung zuerst verbal verstehen, dann nach Atomen ausgleichen.",
            "Im Zweifel: zuerst Metalle, dann Nichtmetalle, dann H und O ausgleichen ‚Äì oder deine bevorzugte Reihenfolge.",
            "Immer Einheiten mitf√ºhren (mg ‚Üí g ‚Üí mol)."
          ],
          formulas: [
            "n = m / M",
            "c = n / V"
          ]
        },
        {
  id: "saeure-base-ph",
  title: "S√§ure-Base & pH-Wert (inkl. NaOH)",
  tags: ["Br√∏nsted", "pH", "starke Basen"],
  goals: [
    "S√§uren und Basen nach Br√∏nsted definieren.",
    "pH starker S√§uren und pH starker Basen (z. B. NaOH) sicher berechnen.",
    "Zusammenhang zwischen pH, pOH und [H‚Å∫]/[OH‚Åª] sowie dem Ionenprodukt des Wassers (K<sub>w</sub>) nutzen.",
    "Zwischen starken und schwachen S√§uren/Basen unterscheiden und die passenden Rechenwege kennen."
  ],
  summary:
    "Nach Br√∏nsted ist eine S√§ure ein Protonendonator und eine Base ein Protonenakzeptor. Starke S√§uren/Basen dissoziieren im betrachteten Konzentrationsbereich praktisch vollst√§ndig, schwache nur teilweise. F√ºr starke S√§uren/Basen kannst du die Konzentration direkt mit [H‚Å∫] oder [OH‚Åª] gleichsetzen. √úber pH, pOH und das Ionenprodukt des Wassers (Kw) l√§sst sich die jeweils andere Gr√∂√üe berechnen. In Klausuren geht es h√§ufig um das sichere Anwenden weniger Standardrezepte.",
  keyPoints: [
    "Br√∏nsted-S√§ure: Protonendonator; Br√∏nsted-Base: Protonenakzeptor.",
    "Starke S√§ure/Base: nahezu vollst√§ndige Dissoziation ‚Üí [H‚Å∫] ‚âà c(S√§ure), [OH‚Åª] ‚âà c(Base).",
    "Wasserautoionisation: H‚ÇÇO ‚áå H‚Å∫ + OH‚Åª; K<sub>w</sub> = [H‚Å∫]¬∑[OH‚Åª] ‚âà 1,0¬∑10‚Åª¬π‚Å¥ (25 ¬∞C).",
    "pH = ‚àílog‚ÇÅ‚ÇÄ([H‚Å∫]); pOH = ‚àílog‚ÇÅ‚ÇÄ([OH‚Åª]); pH + pOH = 14 (bei 25 ¬∞C).",
    "F√ºr NaOH: [OH‚Åª] = c(NaOH) (starke Base, 1:1-St√∂chiometrie).",
    "F√ºr starke S√§uren/Basen reicht meist das einfache Rezept ‚Äì schwache S√§uren/Basen brauchen Gleichgewichtsbetrachtung (K<sub>a</sub> oder K<sub>b</sub>) oder N√§herungen."
  ],
  formulas: [
    "pH = ‚àílog‚ÇÅ‚ÇÄ([H‚Å∫])",
    "pOH = ‚àílog‚ÇÅ‚ÇÄ([OH‚Åª])",
    "pH + pOH = 14 (bei 25 ¬∞C)",
    "K<sub>w</sub> = [H‚Å∫]¬∑[OH‚Åª] ‚âà 1,0¬∑10‚Åª¬π‚Å¥"
  ],
  visual: `
    <div style="font-size:11px;margin-bottom:4px;">Rechenwege auf einen Blick:</div>
    <pre style="font-size:10px;line-height:1.3;">
Starke S√§ure (z. B. HCl):
    c(HCl) = 0,010 mol/L
    ‚Üí [H‚Å∫] ‚âà 0,010 mol/L
    ‚Üí pH = ‚àílog(0,010) = 2

Starke Base (z. B. NaOH):
    c(NaOH) = 0,010 mol/L
    ‚Üí [OH‚Åª] ‚âà 0,010 mol/L
    ‚Üí pOH = 2
    ‚Üí pH = 14 ‚àí 2 = 12
    </pre>
  `,
  detailBlocks: [
    {
      title: "Definitionen & Grundbegriffe",
      content: `
        <ul style="padding-left:18px; margin:0;">
          <li><b>Br√∏nsted-S√§ure:</b> Teilchen, das ein Proton (H‚Å∫) abgeben kann. Beispiel: HCl, HNO‚ÇÉ, CH‚ÇÉCOOH.</li>
          <li><b>Br√∏nsted-Base:</b> Teilchen, das ein Proton aufnehmen kann. Beispiel: OH‚Åª, NH‚ÇÉ, CH‚ÇÉCOO‚Åª.</li>
          <li><b>Konjugiertes S√§ure-Base-Paar:</b> S√§ure und Base, die sich nur um ein Proton unterscheiden (z. B. HCl/Cl‚Åª).</li>
          <li><b>Starke S√§ure/Base:</b> Dissoziiert in Wasser praktisch vollst√§ndig (im betrachteten Konzentrationsbereich).</li>
          <li><b>Schwache S√§ure/Base:</b> Nur teilweise dissoziiert; es stellt sich ein Gleichgewicht ein (K<sub>a</sub> oder K<sub>b</sub> beschreibt die St√§rke).</li>
          <li><b>pH-Skala:</b> Ma√ü f√ºr die Wasserstoffionenkonzentration; pH &lt; 7 sauer, pH = 7 neutral, pH &gt; 7 basisch (bei 25 ¬∞C).</li>
        </ul>
      `
    },
    {
      title: "Rezept: pH starker S√§uren",
      content: `
        <ol style="padding-left:18px; margin:0;">
          <li><b>Pr√ºfen:</b> Ist es eine starke S√§ure? (z. B. HCl, HBr, HI, HNO‚ÇÉ, H‚ÇÇSO‚ÇÑ (1. Proton), HClO‚ÇÑ)</li>
          <li><b>Spezies bestimmen:</b> Wie viele H‚Å∫ pro Molek√ºl? (z. B. HCl ‚Üí 1 H‚Å∫, H‚ÇÇSO‚ÇÑ ‚Üí 2 H‚Å∫)</li>
          <li><b>[H‚Å∫] berechnen:</b> [H‚Å∫] ‚âà <i>n<sub>H‚Å∫</sub></i> ¬∑ c(S√§ure).</li>
          <li><b>pH berechnen:</b> pH = ‚àílog‚ÇÅ‚ÇÄ([H‚Å∫]).</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          Beispiel: c(HCl) = 0,050 mol/L ‚Üí starke einprotonige S√§ure ‚áí [H‚Å∫] ‚âà 0,050 mol/L ‚áí pH = ‚àílog(0,050) ‚âà 1,30.
        </div>
      `
    },
    {
      title: "Rezept: pH starker Basen (z. B. NaOH)",
      content: `
        <ol style="padding-left:18px; margin:0;">
          <li><b>Pr√ºfen:</b> Ist es eine starke Base? (z. B. NaOH, KOH, Ba(OH)‚ÇÇ).</li>
          <li><b>Spezies bestimmen:</b> Wie viele OH‚Åª pro Formeleinheit? (NaOH ‚Üí 1, Ba(OH)‚ÇÇ ‚Üí 2).</li>
          <li><b>[OH‚Åª] berechnen:</b> [OH‚Åª] ‚âà <i>n<sub>OH‚Åª</sub></i> ¬∑ c(Base).</li>
          <li><b>pOH berechnen:</b> pOH = ‚àílog‚ÇÅ‚ÇÄ([OH‚Åª]).</li>
          <li><b>pH berechnen:</b> pH = 14 ‚àí pOH (bei 25 ¬∞C).</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          Beispiel: c(NaOH) = 0,020 mol/L ‚Üí [OH‚Åª] ‚âà 0,020 mol/L ‚Üí pOH = ‚àílog(0,020) ‚âà 1,70 ‚Üí pH ‚âà 12,30.
        </div>
      `
    },
    {
      title: "Beispielaufgabe (klassischer Klausurstil)",
      content: `
        <div style="font-size:12px; margin-bottom:4px;">
          <b>Aufgabe:</b> Berechne den pH-Wert einer 0,010 mol/L Natronlauge (NaOH). Gehe von vollst√§ndiger Dissoziation aus.
        </div>
        <ol style="padding-left:18px; margin:0;">
          <li><b>Schritt 1:</b> NaOH ist eine starke Base, 1:1-St√∂chiometrie: NaOH ‚Üí Na‚Å∫ + OH‚Åª.</li>
          <li><b>Schritt 2:</b> [OH‚Åª] ‚âà c(NaOH) = 0,010 mol/L.</li>
          <li><b>Schritt 3:</b> pOH = ‚àílog(0,010) = 2.</li>
          <li><b>Schritt 4:</b> pH = 14 ‚àí pOH = 14 ‚àí 2 = 12.</li>
        </ol>
        <div style="margin-top:6px; font-size:11px;">
          <b>Antwort:</b> pH ‚âà 12, die L√∂sung ist deutlich basisch.
        </div>
      `
    },
    {
      title: "Typische Klausurfallen & Merks√§tze",
      content: `
        <ul style="padding-left:18px; margin:0;">
          <li><b>Falle 1:</b> pH direkt aus c(Base) berechnen (statt √ºber pOH) ‚áí immer erst [OH‚Åª] ‚Üí pOH ‚Üí pH.</li>
          <li><b>Falle 2:</b> Mehrprotonige S√§uren/Basen ignorieren:
              z. B. H‚ÇÇSO‚ÇÑ ‚Äì im ersten Schritt gibt es 2 H‚Å∫ pro Molek√ºl ‚Üí [H‚Å∫] ‚âà 2¬∑c(H‚ÇÇSO‚ÇÑ).</li>
          <li><b>Falle 3:</b> Falsche Einheiten: Konzentrationen m√ºssen in mol/L eingesetzt werden, nicht in g/L.</li>
          <li><b>Falle 4:</b> K<sub>w</sub> vergessen: Bei sehr verd√ºnnten L√∂sungen oder wenn nur [OH‚Åª] gegeben ist, hilft K<sub>w</sub> = [H‚Å∫][OH‚Åª].</li>
          <li><b>Merksatz:</b> "Stark" hei√üt: ich darf [H‚Å∫] bzw. [OH‚Åª] (fast) gleich der Anfangskonzentration setzen.</li>
        </ul>
      `
    }
  ]
}
,
{
  id: "titrationen",
  title: "Titrationen (S√§ure-Base, F√§llung, Komplexometrie, Redox)",
  tags: ["Titration", "√Ñquivalenzpunkt", "Titrationskurve", "Gehaltsbestimmung"],
  goals: [
    "Das Grundprinzip einer Titration erkl√§ren k√∂nnen.",
    "√Ñquivalenzpunkt, Umschlagpunkt und Endpunkt sicher unterscheiden.",
    "Gehaltsbestimmung aus c‚ÇÅ¬∑V‚ÇÅ = c‚ÇÇ¬∑V‚ÇÇ in einfachen F√§llen durchf√ºhren.",
    "Den Unterschied zwischen S√§ure-Base-, F√§llungs-, komplexometrischen und Redoxtitrationen kennen."
  ],
  summary:
    "Bei einer Titration wird eine Ma√ül√∂sung definierter Konzentration zu einer Probe gegeben, bis die st√∂chiometrische Menge erreicht ist (√Ñquivalenzpunkt). √úber das verbrauchte Volumen und die bekannte Konzentration der Ma√ül√∂sung kann man die Konzentration der Probe berechnen. In der Klausur sind typische Themen: S√§ure-Base-Titrationen, √Ñquivalenzpunkt-Bestimmung, Indikatorwahl, einfache Gehaltsberechnung.",
  keyPoints: [
    "Ma√ül√∂sung: L√∂sung bekannter Konzentration (c bekannt).",
    "Probel√∂sung: zu untersuchende L√∂sung (c gesucht).",
    "√Ñquivalenzpunkt: st√∂chiometrisch genaues Mengenverh√§ltnis erreicht.",
    "Umschlagpunkt/Endpunkt: der tats√§chlich beobachtete Farbumschlag des Indikators (liegt nahe am √Ñquivalenzpunkt).",
    "Titrationskurve: grafische Darstellung von pH (oder Potential) gegen zugegebenes Volumen.",
    "Standardrezept Gehaltsbestimmung: c‚ÇÅ¬∑V‚ÇÅ = c‚ÇÇ¬∑V‚ÇÇ (nach Stoffmenge n = c¬∑V)."
  ],
  formulas: [
    "n = c ¬∑ V",
    "c(Probel√∂sung) = (c(Ma√ül√∂sung) ¬∑ V(Ma√ül√∂sung)) / V(Probel√∂sung) (bei einfacher 1:1-St√∂chiometrie)",
    "f√ºr andere Verh√§ltnisse: ŒΩ‚ÇÅ¬∑c‚ÇÅ¬∑V‚ÇÅ = ŒΩ‚ÇÇ¬∑c‚ÇÇ¬∑V‚ÇÇ (ŒΩ = st√∂chiometrischer Koeffizient)"
  ],
  visual: `
    <div style="font-size:11px;margin-bottom:4px;">Idealisierte S√§ure-Base-Titrationskurve (starke S√§ure mit starker Base):</div>
    <pre style="font-size:10px;line-height:1.2;">
pH
14 |                           ______
   |                        __/
   |                     __/
   |                  __/
   |               __/
   |            __/
   |         __/
   |      __/
   |   __/
   |__/
   +--------------------------------- V
          &uarr;
     √Ñquivalenzpunkt (starker Anstieg)
    </pre>
  `,
  detailBlocks: [
    {
      title: "Grundprinzip der Titration",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li>Man gibt eine <b>Ma√ül√∂sung</b> definierter Konzentration tropfenweise zu einer <b>Probel√∂sung</b> unbekannter Konzentration.</li>
          <li>Die reagierenden Stoffe stehen in einer <b>st√∂chiometrischen Reaktionsgleichung</b> (z. B. 1:1 oder 1:2).</li>
          <li>Am <b>√Ñquivalenzpunkt</b> sind die Stoffmengen im st√∂chiometrisch richtigen Verh√§ltnis umgesetzt.</li>
          <li>√úber das verbrauchte Volumen der Ma√ül√∂sung und ihre Konzentration kann man die Stoffmenge berechnen und daraus die Konzentration der Probe.</li>
          <li>Ein <b>Indikator</b> (oder pH-Meter/Leitf√§higkeit) zeigt an, wann der Endpunkt (nahe beim √Ñquivalenzpunkt) erreicht ist.</li>
        </ul>
      `
    },
    {
      title: "S√§ure-Base-Titrationen (stark/stark)",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>Beispiel:</b> HCl (starke S√§ure) mit NaOH (starke Base).</li>
          <li>Reaktionsgleichung: HCl + NaOH ‚Üí NaCl + H‚ÇÇO (1:1-Verh√§ltnis).</li>
          <li><b>Vor dem √ÑP:</b> L√∂sung ist sauer, pH wird durch √úberschuss an HCl bestimmt.</li>
          <li><b>Am √ÑP:</b> St√∂chiometrisch gleiche Stoffmenge HCl und NaOH umgesetzt, pH ‚âà 7 (bei starken S√§uren/Basen in Wasser).</li>
          <li><b>Nach dem √ÑP:</b> L√∂sung ist basisch, pH wird durch √úberschuss an NaOH bestimmt.</li>
        </ul>
        <div style="font-size:11px;margin-top:6px;">
          <b>Gehaltsberechnung (1:1):</b> c(HCl) = c(NaOH) ¬∑ V(NaOH) / V(HCl) 
        </div>
      `
    },
    {
      title: "Titrationen mit anderen St√∂chiometrien",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li>Reaktionsgleichung muss immer <b>zuerst</b> aufgestellt und ausgeglichen werden.</li>
          <li>Beispiel: 2 HCl + Na‚ÇÇCO‚ÇÉ ‚Üí 2 NaCl + H‚ÇÇO + CO‚ÇÇ ‚Üí Verh√§ltnis 2:1.</li>
          <li>Dann gilt: 2 ¬∑ n(Na‚ÇÇCO‚ÇÉ) = n(HCl) oder allgemein: ŒΩ‚ÇÅ¬∑n‚ÇÅ = ŒΩ‚ÇÇ¬∑n‚ÇÇ.</li>
          <li>√úbertragen auf Konzentration und Volumen: ŒΩ‚ÇÅ¬∑c‚ÇÅ¬∑V‚ÇÅ = ŒΩ‚ÇÇ¬∑c‚ÇÇ¬∑V‚ÇÇ.</li>
          <li>Das ist die <b>allgemeine Gehaltsgleichung</b> f√ºr Titrationen.</li>
        </ul>
      `
    },
    {
      title: "Beispielaufgabe (Gehaltsbestimmung)",
      content: `
        <div style="font-size:12px;margin-bottom:4px;">
          <b>Aufgabe:</b> 25,0 mL Salzs√§ure werden mit 0,100 mol/L NaOH titriert. Der √Ñquivalenzpunkt liegt bei 18,6 mL NaOH. Berechne c(HCl).
        </div>
        <ol style="padding-left:18px;margin:0;">
          <li>Reaktionsgleichung: HCl + NaOH ‚Üí NaCl + H‚ÇÇO (1:1).</li>
          <li>Formel: c(HCl) ¬∑ V(HCl) = c(NaOH) ¬∑ V(NaOH).</li>
          <li>Einsetzen: c(HCl) ¬∑ 25,0 mL = 0,100 mol/L ¬∑ 18,6 mL.</li>
          <li>Volumina in L umrechnen oder k√ºrzen, da beide in mL: c(HCl) = 0,100 ¬∑ 18,6 / 25,0 mol/L.</li>
          <li>c(HCl) ‚âà 0,0744 mol/L.</li>
        </ol>
        <div style="font-size:11px;margin-top:6px;">
          <b>Antwort:</b> Die Salzs√§ure hat eine Konzentration von ca. 0,074 mol/L.
        </div>
      `
    },
    {
      title: "Andere Titrationsarten (√úberblick)",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>F√§llungstitration:</b> Bildung eines schwerl√∂slichen Niederschlags (z. B. Ag‚Å∫ + Cl‚Åª ‚Üí AgCl‚Üì) ‚Äì √ÑP √ºber Leitf√§higkeit oder Indikator.</li>
          <li><b>Komplexometrische Titration:</b> Bildung von Komplexen (z. B. EDTA-Titration von Ca¬≤‚Å∫/Mg¬≤‚Å∫) ‚Äì Indikatoren sind oft Metallindikatoren.</li>
          <li><b>Redoxtitration:</b> Redoxreaktion zwischen Ma√ü- und Probel√∂sung (z. B. Permanganattitration) ‚Äì √ÑP √ºber Potentialsprung oder Eigenf√§rbung.</li>
        </ul>
      `
    },
    {
      title: "Typische Klausurfallen & Merks√§tze",
      content: `
        <ul style="padding-left:18px;margin:0;">
          <li><b>Falle 1:</b> Sto√üzahlen ignorieren ‚Üí immer zuerst Reaktionsgleichung sauber ausgleichen.</li>
          <li><b>Falle 2:</b> Volumen in mL einsetzen, obwohl in der Formel L gebraucht werden ‚Üí Einheit checken!</li>
          <li><b>Falle 3:</b> √Ñquivalenzpunkt und Umschlagpunkt verwechseln.</li>
          <li><b>Falle 4:</b> c‚ÇÅ¬∑V‚ÇÅ = c‚ÇÇ¬∑V‚ÇÇ anwenden, obwohl Verh√§ltnis ‚â† 1:1 ‚Üí dann braucht man ŒΩ‚ÇÅ¬∑c‚ÇÅ¬∑V‚ÇÅ = ŒΩ‚ÇÇ¬∑c‚ÇÇ¬∑V‚ÇÇ.</li>
          <li><b>Merksatz:</b> <i>‚ÄûErst Reaktionsgleichung, dann rechnen.‚Äú</i></li>
        </ul>
      `
    }
  ]
},

{
 id: "redox",
 title: "Redoxreaktionen & elektrochemische Spannungsreihe",
 tags: ["Oxidation", "Reduktion", "Redox", "Elektrochemie"],
 goals: [
   "Oxidation und Reduktion sicher definieren (Elektronenabgabe/-aufnahme).",
   "Oxidationszahlen zuweisen und einfache Redoxgleichungen interpretieren k√∂nnen.",
   "Die elektrochemische Spannungsreihe zur Vorhersage der Reaktionsrichtung nutzen.",
   "Grundidee von galvanischer Zelle, Standardpotential und Nernst-Gleichung verstehen (auf Klausur-Niveau)."
 ],
 summary:
   "Redoxreaktionen sind Elektronentransferprozesse: Oxidation bedeutet Elektronenabgabe, Reduktion Elektronenaufnahme. Die elektrochemische Spannungsreihe ordnet Halbzellen nach ihren Standardelektrodenpotenzialen. Elemente mit sehr negativem Potential geben leicht Elektronen ab (starke Reduktionsmittel), solche mit hohem Potential wirken als Oxidationsmittel. In galvanischen Zellen wird die freie Reaktionsenergie in elektrische Energie umgewandelt.",
 keyPoints: [
   "Oxidation: Elektronenabgabe (Oxidationszahl wird gr√∂√üer).",
   "Reduktion: Elektronenaufnahme (Oxidationszahl wird kleiner).",
   "Oxidationsmittel wird selbst reduziert, Reduktionsmittel selbst oxidiert.",
   "Spannungsreihe: Metalle mit negativeren E¬∞-Werten sind st√§rkere Reduktionsmittel.",
   "Zellspannung E¬∞(Zelle) = E¬∞(Kathode) ‚àí E¬∞(Anode).",
   "Nernst-Gleichung beschreibt Konzentrationsabh√§ngigkeit des Potentials."
 ],
 formulas: [
   "E¬∞(Zelle) = E¬∞(Kathode) ‚àí E¬∞(Anode)",
   "Nernst (vereinfacht, 25 ¬∞C): E = E¬∞ ‚àí (0,059 V / z) ¬∑ log(Q)"
 ],
 visual: `
   <div style="font-size:11px;margin-bottom:4px;">Beispiel: Daniell-Element (Zn/Cu-Zelle)</div>
   <pre style="font-size:10px;line-height:1.3;">
Anode (Oxidation):   Zn ‚Üí Zn¬≤‚Å∫ + 2 e‚Åª     (E¬∞ ‚âà ‚àí0,76 V)
Kathode (Reduktion): Cu¬≤‚Å∫ + 2 e‚Åª ‚Üí Cu     (E¬∞ ‚âà +0,34 V)

Zellreaktion:        Zn + Cu¬≤‚Å∫ ‚Üí Zn¬≤‚Å∫ + Cu

E¬∞(Zelle) = E¬∞(Kathode) ‚àí E¬∞(Anode)
       = (+0,34 V) ‚àí (‚àí0,76 V)
       = +1,10 V
   </pre>
 `,
 detailBlocks: [
   {
     title: "Oxidation, Reduktion & Oxidationszahlen",
     content: `
       <ul style="padding-left:18px;margin:0;">
         <li><b>Oxidation:</b> Abgabe von Elektronen (e‚Åª). Oxidationszahl wird <b>h√∂her</b>.</li>
         <li><b>Reduktion:</b> Aufnahme von Elektronen. Oxidationszahl wird <b>niedriger</b>.</li>
         <li><b>Oxidationsmittel:</b> Stoff, der andere oxidiert (nimmt Elektronen auf) ‚Üí wird selbst <b>reduziert</b>.</li>
         <li><b>Reduktionsmittel:</b> Stoff, der andere reduziert (gibt Elektronen ab) ‚Üí wird selbst <b>oxidiert</b>.</li>
         <li>Oxidationszahlen helfen, Elektronenzahl bei Redoxreaktionen nachzuvollziehen (Klausurklassiker).</li>
       </ul>
     `
   },
   {
     title: "Elektrochemische Spannungsreihe (Prinzip)",
     content: `
       <ul style="padding-left:18px;margin:0;">
         <li>Liste von Halbzellen mit ihren <b>Standardelektrodenpotenzialen E¬∞</b> (in V gegen Standard-Wasserstoffelektrode).</li>
         <li>Je <b>negativer</b> E¬∞, desto leichter gibt die Spezies Elektronen ab ‚Üí gutes Reduktionsmittel.</li>
         <li>Je <b>positiver</b> E¬∞, desto leichter nimmt die Spezies Elektronen auf ‚Üí gutes Oxidationsmittel.</li>
         <li><b>Regel:</b> Halbzelle mit gr√∂√üerem E¬∞ wirkt als <b>Kathode</b>, die mit kleinerem E¬∞ als <b>Anode</b>.</li>
       </ul>
     `
   },
   {
     title: "Galvanische Zelle (am Beispiel Zn/Cu)",
     content: `
       <ol style="padding-left:18px;margin:0;">
         <li><b>Anode:</b> Zn-Elektrode in Zn¬≤‚Å∫-L√∂sung, hier l√§uft die Oxidation: Zn ‚Üí Zn¬≤‚Å∫ + 2 e‚Åª.</li>
         <li><b>Kathode:</b> Cu-Elektrode in Cu¬≤‚Å∫-L√∂sung, hier l√§uft die Reduktion: Cu¬≤‚Å∫ + 2 e‚Åª ‚Üí Cu.</li>
         <li>Elektronen flie√üen √ºber den √§u√üeren Leiter von der Anode zur Kathode.</li>
         <li>Die <b>Salzbr√ºcke</b> sorgt f√ºr Ladungsausgleich (Ionentransport), damit der Strom nicht abrei√üt.</li>
         <li>Die gemessene Spannung entspricht E(Zelle).</li>
       </ol>
     `
   },
   {
     title: "Nernst-Gleichung (auf Klausurniveau)",
     content: `
       <div style="font-size:12px;margin-bottom:4px;">
         Die Nernst-Gleichung beschreibt, wie sich das Elektrodenpotential mit der Konzentration der beteiligten Ionen √§ndert.
       </div>
       <div style="padding-left:18px;font-size:12px;">
         <b>Allgemein (25 ¬∞C):</b><br/>
         E = E¬∞ ‚àí (0,059 V / z) ¬∑ log(Q)
       </div>
       <ul style="padding-left:18px;margin-top:4px;">
         <li>E: aktuelles Elektrodenpotential.</li>
         <li>E¬∞: Standardelektrodenpotential (bei 1 mol/L).</li>
         <li>z: Zahl der √ºbertragenen Elektronen.</li>
         <li>Q: Reaktionsquotient (Verh√§ltnis Produkte/Edukte).</li>
       </ul>
       <div style="font-size:11px;margin-top:6px;">
         In vielen Klausuren reicht es zu wissen, dass h√∂here Produktkonzentration das Potential verschiebt
         und dass aus Konzentrationsunterschieden eine messbare Spannung entsteht.
       </div>
     `
   },
   {
     title: "Typische Klausuraufgaben & Fallen",
        content: `
          <ul style="padding-left:18px;margin:0;">
            <li>Halbreaktionen identifizieren (was wird oxidiert, was reduziert?).</li>
            <li>E¬∞(Zelle) berechnen aus Tabellenwerten ‚Üí Kathode minus Anode.</li>
            <li>Vorhersagen, ob eine Redoxreaktion freiwillig abl√§uft (E¬∞(Zelle) > 0 ‚áí tendenziell freiwillig).</li>
            <li><b>Falle 1:</b> Anode/Kathode verwechseln (Merksatz: ‚ÄûAnode = Oxidation‚Äú).</li>
            <li><b>Falle 2:</b> Falsche Vorzeichen bei Potentialen (E¬∞ nicht einfach addieren, sondern Kathode ‚àí Anode).</li>
            <li><b>Falle 3:</b> z in der Nernst-Gleichung vergessen.</li>
          </ul>
        `
      }
    ]            // schlie√üt detailBlocks
  }              // schlie√üt Topic "redox"
  ]              // schlie√üt topics-Array
}                // schlie√üt Subject "Allgemeine Chemie"
  ]
};               // schlie√üt learnData



    // ---------- DATENMODELL ----------
    
let data = {
  theme: "dark",
  syncId: null,
  notebooks: [],
  activeNotebookId: null,
  activePageId: null,
  cards: { decks: [] },
  planner: { exams: [], focusSessions: [] },
  formulas: [],
  tasks: [],
  brain: { entries: [] },
  templateScale: "medium"   // üëà NEU: Rastergr√∂√üe (small / medium / large)
};


    const STORAGE_KEY = "uniHyperNotes_v3";

    // ---------- COMMON DOM ----------
    const tabButtons = document.querySelectorAll(".tab-btn");
    const sections = {
      notes: document.getElementById("notesLayout"),
      cards: document.getElementById("cardsSection"),
      planner: document.getElementById("plannerSection"),
      formulas: document.getElementById("formulasSection"),
      tools: document.getElementById("toolsSection"),
      learn: document.getElementById("learnSection"),
      tasks: document.getElementById("tasksSection"),
      brain: document.getElementById("brainSection"),
      stats: document.getElementById("statsSection")
    };

    const darkModeBtn = document.getElementById("darkModeBtn");
    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const importJsonBtn = document.getElementById("importJsonBtn");
    const importJsonInput = document.getElementById("importJsonInput");

    // ---------- NOTIZEN / CANVAS ----------
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const notebookSelect = document.getElementById("notebookSelect");
    const addNotebookBtn = document.getElementById("addNotebookBtn");

// iPad/Safari: eigenes Scroll-/Zoom-Verhalten abschalten
canvas.style.touchAction = "none";


    const addPageBtn = document.getElementById("addPageBtn");
    const pageList = document.getElementById("pageList");
    const templateSelect = document.getElementById("templateSelect");
    const templateSizeSelect = document.getElementById("templateSizeSelect"); // üëà NEU

// Pencil-Zeichnen √ºber Pointer Events



// ---- Zoom & Pan (NEU) ----
   let zoom = 1;
  let panX = 0;
  let panY = 0;

    let isPinching = false;
    let lastPinchDist = null;
    let lastPinchCenter = null;



    const colorPicker = document.getElementById("colorPicker");
    const toolButtons = document.querySelectorAll(".tool-btn");
    const strokeButtons = document.querySelectorAll(".stroke-btn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const clearBtn = document.getElementById("clearBtn");
    const exportPageBtn = document.getElementById("exportPageBtn");

    let currentTool = "pen"; // pen | highlighter | eraser | line | rect | circle
    let currentColor = colorPicker.value;
    let currentWidth = 2;
    let drawing = false;
    let currentStroke = null;
    let lastPos = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let shapeStartPos = null;

    function getActiveNotebook() {
      return data.notebooks.find(nb => nb.id === data.activeNotebookId);
    }

    function getActivePage() {
      const nb = getActiveNotebook();
      if (!nb) return null;
      return nb.pages.find(p => p.id === data.activePageId);
    }

    // ---------- Storage & Theme ----------
    function saveData() {
  // Lokal speichern (wie bisher)
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Versuchen, in die Cloud zu syncen (non-blocking)
  syncToCloud();
}

// ---- Cloud-Sync: Hochladen ----
async function syncToCloud() {
  try {
    const id = askForSyncId();  // sorgt daf√ºr, dass wir eine Sync-ID haben
    if (!id) return;

    updateSyncStatus("Synchronisiere mit Cloud ‚Ä¶");

    const ref = doc(db, "syncProfiles", id);
    await setDoc(ref, {
      data,
      updatedAt: Date.now()
    });

    updateSyncStatus("Mit Cloud synchronisiert ‚úî");
  } catch (err) {
    console.error("Cloud-Sync fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Cloud-Sync (lokal ist alles sicher).");
  }
}


    function loadData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const defaultNotebook = {
          id: "nb-" + Date.now(),
          name: "Standard",
          pages: [
            { id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }
          ]
        };
        data.notebooks = [defaultNotebook];
        data.activeNotebookId = defaultNotebook.id;
        data.activePageId = defaultNotebook.pages[0].id;
        data.theme = "dark";
        data.cards = { decks: [] };
        data.planner = { exams: [], focusSessions: [] };
        data.formulas = [];
        data.tasks = [];
        data.brain = { entries: [] };
        data.templateScale = "medium";
        return;
      }
      try {
        data = JSON.parse(raw);
        if (!data.templateScale) data.templateScale = "medium"; // üëà falls altes Backup
      } catch (e) {
        console.error("Fehler beim Laden, initialisiere neu", e);
        localStorage.removeItem(STORAGE_KEY);
        loadData();
      }
    }

// ---- Cloud-Sync: Herunterladen ----
async function syncFromCloud() {
  try {
    const id = askForSyncId();
    if (!id) return;

    updateSyncStatus("Lade Daten aus der Cloud ‚Ä¶");

    const ref = doc(db, "syncProfiles", id);
    const snap = await getDoc(ref);

    if (!snap.exists()) {
      updateSyncStatus("Noch keine Cloud-Daten f√ºr diese Sync-ID ‚Äì lokale Daten bleiben.");
      return;
    }

    const cloud = snap.data();
    if (cloud && cloud.data) {
  data = cloud.data;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Alles neu rendern, damit du es siehst
  applyTheme();
  renderNotebookSelect();
  resizeCanvas();
  renderPageList();
  redrawActivePage();

  renderDecks();
  renderExams();
  renderFormulas();
  renderTasks();
  renderBrainHistory();
  renderStats();
  renderToolInputs();
  renderLearnSubjects();
  renderLearnTopics();
  renderLearnContent();

  updateSyncStatus("Cloud-Daten geladen ‚úî");
}
 else {
      updateSyncStatus("Cloud-Dokument leer ‚Äì keine √Ñnderung.");
    }
  } catch (err) {
    console.error("Cloud-Download fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Laden aus der Cloud.");
  }
}

    function applyTheme() {
      if (data.theme === "light") {
        document.body.classList.add("light");
      } else {
        document.body.classList.remove("light");
      }
    }

    function toggleTheme() {
      data.theme = data.theme === "dark" ? "light" : "dark";
      applyTheme();
      saveData();
    }

    darkModeBtn.addEventListener("click", toggleTheme);

    // ---------- Tabs ----------
    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        tabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const tab = btn.getAttribute("data-tab");
        Object.keys(sections).forEach(k => {
          if (k === "notes") {
            sections[k].classList.toggle("active", tab === "notes");
            sections[k].style.display = tab === "notes" ? "flex" : "none";
          } else {
            sections[k].classList.toggle("active", k === tab);
          }
        });
        if (tab === "stats") renderStats();
      });
    });

    // ---------- Notebooks & Seiten ----------
    function renderNotebookSelect() {
      notebookSelect.innerHTML = "";
      data.notebooks.forEach(nb => {
        const opt = document.createElement("option");
        opt.value = nb.id;
        opt.textContent = nb.name;
        if (nb.id === data.activeNotebookId) opt.selected = true;
        notebookSelect.appendChild(opt);
      });
    }

    function switchNotebook(id) {
      if (id === data.activeNotebookId) return;
      data.activeNotebookId = id;
      const nb = getActiveNotebook();
      if (!nb) return;
      data.activePageId = nb.pages[0]?.id || null;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function addNotebook() {
      const name = prompt("Name f√ºr das neue Notizbuch:", "Neues Notizbuch");
      if (!name) return;
      const nb = {
        id: "nb-" + Date.now(),
        name,
        pages: [{ id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }]
      };
      data.notebooks.push(nb);
      data.activeNotebookId = nb.id;
      data.activePageId = nb.pages[0].id;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function renderPageList() {
      const nb = getActiveNotebook();
      pageList.innerHTML = "";
      if (!nb) return;
      nb.pages.forEach((page, index) => {
        const div = document.createElement("div");
        div.className = "page-thumb" + (page.id === data.activePageId ? " active" : "");
        div.textContent = page.name;
        const idx = document.createElement("span");
        idx.className = "index";
        idx.textContent = index + 1;
        div.appendChild(idx);
        div.addEventListener("click", () => {
          if (page.id === data.activePageId) return;
          data.activePageId = page.id;
          undoStack = [];
          redoStack = [];
          renderPageList();
          redrawActivePage();
          saveData();
        });
        pageList.appendChild(div);
      });
      const activePage = getActivePage();
      if (activePage) templateSelect.value = activePage.template || "blank";
    }

    function addPage() {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = {
        id: "p-" + Date.now(),
        name: "Seite " + (nb.pages.length + 1),
        template: templateSelect.value || "blank",
        strokes: []
      };
      nb.pages.push(page);
      data.activePageId = page.id;
      undoStack = [];
      redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function setPageTemplate(template) {
      const page = getActivePage();
      if (!page) return;
      page.template = template;
      redrawActivePage();
      saveData();
    }

    function resizeCanvas() {
  const isLandscape = window.innerWidth > window.innerHeight; // üëà NEU
  const margin = isLandscape ? 10 : 20;

  const wrapper = document.getElementById("canvasWrapper");
  const w = wrapper.clientWidth - margin * 2;
  const h = wrapper.clientHeight - margin * 2 - 40;

  const aspect = 1 / 1.414; // A4
  let cw = w, ch = w / aspect;
  if (ch > h) {
    ch = h;
    cw = h * aspect;
  }

  const page = getActivePage();
  const oldStrokes = page ? JSON.parse(JSON.stringify(page.strokes)) : null;
  const tmpl = page ? page.template : "blank";

  canvas.width = cw;
  canvas.height = ch;

// Zoom & Pan beim Resize zur√ºcksetzen (optional)
zoom = 1;
panX = 0;
panY = 0;
updateCanvasTransform();


  if (page && oldStrokes) {
    page.strokes = oldStrokes;
    page.template = tmpl;
  }
  redrawActivePage();
}


    window.addEventListener("resize", resizeCanvas);

function getTemplateSpacing() {
  const base = 32; // deine bisherige Standardgr√∂√üe

  switch (data.templateScale) {
    case "small":
      return base * 0.6;   // ca. 19 px ‚Äì fein wie GoodNotes
    case "large":
      return base * 1.3;   // ca. 42 px ‚Äì gro√üe K√§stchen
    case "medium":
    default:
      return base;         // Standard
  }
}


    function drawTemplate(template) {
  const w = canvas.width, h = canvas.height;
  const spacing = getTemplateSpacing();    // üëà NEU

  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = "#7a7a7a";
  ctx.lineWidth = 1;

  if (template === "lined") {
    const lineSpacing = spacing;
    for (let y = lineSpacing; y < h; y += lineSpacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }

  } else if (template === "dotted") {
    for (let y = spacing; y < h; y += spacing) {
      for (let x = spacing; x < w; x += spacing) {
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fillStyle = "#7a7a7a";
        ctx.fill();
      }
    }

  } else if (template === "grid") {
    for (let y = spacing; y < h; y += spacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }
    for (let x = spacing; x < w; x += spacing) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, h);
      ctx.stroke();
    }
  }

  ctx.restore();
}



function redrawActivePage() {
  const page = getActivePage();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!page) return;

  // 1. Erst alle Strokes zeichnen (Stift, Marker, Radierer)
  page.strokes.forEach(stroke => {
    ctx.save();

    if (stroke.tool === "eraser") {
      // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    } else if (stroke.tool === "highlighter") {
      // Halbtransparent wie echter Textmarker
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 0.35; // Transparent
    } else {
      // Normaler Stift
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    }

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const pts = stroke.points;
    if (pts.length > 1) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x * canvas.width, pts[0].y * canvas.height);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x * canvas.width, pts[i].y * canvas.height);
      }
      ctx.stroke();
    }

    ctx.restore();
  });

  // Reset
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  // 2. Template (kariert, liniert, ...) am Ende oben drauf
  drawTemplate(page.template || "blank");
}

function previewShape(endPos) {
  // Wenn wir keine Startposition haben, k√∂nnen wir nichts anzeigen
  if (!shapeStartPos) return;

  const start = shapeStartPos;
  const end = endPos;

  // Erst die Seite normal zeichnen
  redrawActivePage();

  ctx.save();

  // Zeichenstil f√ºr die Vorschau
  ctx.globalCompositeOperation = "source-over";
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentWidth;
  ctx.globalAlpha = 1;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  // Optional: gestrichelt, damit man sieht: das ist nur Vorschau
  ctx.setLineDash([6, 4]);

  const sx = start.x * canvas.width;
  const sy = start.y * canvas.height;
  const ex = end.x * canvas.width;
  const ey = end.y * canvas.height;

  if (currentTool === "line") {
    // Gerade Linie
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

  } else if (currentTool === "rect") {
    // Rechteck aus zwei Eckpunkten
    const x = Math.min(sx, ex);
    const y = Math.min(sy, ey);
    const w = Math.abs(ex - sx);
    const h = Math.abs(ey - sy);

    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.stroke();

  } else if (currentTool === "circle") {
    // Ellipse/Kreis
    const cx = (sx + ex) / 2;
    const cy = (sy + ey) / 2;
    const rx = Math.abs(ex - sx) / 2;
    const ry = Math.abs(ey - sy) / 2;

    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
    ctx.stroke();
  }

  ctx.restore();
}


   function normPos(evt) {
         const rect = canvas.getBoundingClientRect();
         let clientX, clientY;

  if (evt.touches && evt.touches.length > 0) {
          clientX = evt.touches[0].clientX;
          clientY = evt.touches[0].clientY;
  } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
  }

  const x = (clientX - rect.left) / rect.width;
  const y = (clientY - rect.top) / rect.height;
  return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
}


// Abstand zwischen zwei Touches (f√ºr Pinch)
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.hypot(dx, dy);
}

// Mittelpunkt zwischen zwei Fingern (f√ºr ‚Äûunter den Fingern zoomen‚Äú)
function getTouchCenter(touches) {
  return {
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  };
}

// CSS-Transform f√ºr Canvas anwenden
function updateCanvasTransform() {
  canvas.style.transformOrigin = "0 0";
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
}



    function startDrawing(evt) {
  evt.preventDefault();
  const page = getActivePage();
  if (!page) return;

  drawing = true;
  redoStack = [];

  const p = normPos(evt);
  lastPos = p;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // Formen: Startpunkt merken, Stroke nur als ‚ÄûPlatzhalter‚Äú
    shapeStartPos = p;
    currentStroke = {
      tool: "pen",
      color: currentColor,
      width: currentWidth,
      alpha: 1,
      points: [p]
    };
  } else {
    // Freihand-Stift / Marker / Radierer
    const stroke = {
      tool: currentTool,
      color: currentColor,
      // Marker bewusst dicker, wirkt mehr wie echter Textmarker
      width: currentTool === "highlighter" ? currentWidth * 4 : currentWidth,
      alpha: 1,
      points: [p]
    };

    if (currentTool === "eraser") {
      stroke.color = "#000000";
    }

    currentStroke = stroke;
    drawStrokeSegment(lastPos, p, stroke);
  }
}

function drawStrokeSegment(from, to, stroke) {
  ctx.save();

  if (stroke.tool === "eraser") {
    // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  } else if (stroke.tool === "highlighter") {
    // Halbtransparent wie echter Textmarker
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 0.35; // Transparent
  } else {
    // Normaler Stift
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  }

  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  ctx.beginPath();
  ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
  ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
  ctx.stroke();

  ctx.restore();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}


function moveDrawing(evt) {
  if (!drawing || !currentStroke) return;
  evt.preventDefault();

  const raw = normPos(evt);

  // F√ºr Linien/Rechteck/Kreis keine Gl√§ttung, nur Vorschau
  if (["line", "rect", "circle"].includes(currentTool)) {
    previewShape(raw);
    lastPos = raw;
    return;
  }

  // Gl√§ttung: Mischung aus alter und neuer Position (f√ºhlt sich noch direkt an)
  const p = {
    x: lastPos.x * 0.35 + raw.x * 0.65,
    y: lastPos.y * 0.35 + raw.y * 0.65
  };

  // Winzige Bewegungen ignorieren ‚Üí weniger Zittern
  const dx = p.x - lastPos.x;
  const dy = p.y - lastPos.y;
  const dist2 = dx * dx + dy * dy;
  if (dist2 < 0.000004) {
    return;
  }

  drawStrokeSegment(lastPos, p, currentStroke);
  currentStroke.points.push(p);
  lastPos = p;
}

function stopDrawing(evt) {
  if (!drawing) return;
  drawing = false;

  const page = getActivePage();
  if (!page || !currentStroke) return;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // finale Form als Punkte approximieren
    const start = shapeStartPos;
    const end = lastPos;
    let points = [];

    if (currentTool === "line") {
      points = [start, end];
    } else if (currentTool === "rect") {
      const xs = [start.x, end.x].sort((a, b) => a - b);
      const ys = [start.y, end.y].sort((a, b) => a - b);
      const xL = xs[0], xR = xs[1], yT = ys[0], yB = ys[1];
      points = [
        { x: xL, y: yT },
        { x: xR, y: yT },
        { x: xR, y: yB },
        { x: xL, y: yB },
        { x: xL, y: yT }
      ];
    } else if (currentTool === "circle") {
      const steps = 40;
      const cx = (start.x + end.x) / 2;
      const cy = (start.y + end.y) / 2;
      const rx = Math.abs(end.x - start.x) / 2;
      const ry = Math.abs(end.y - start.y) / 2;
      points = [];
      for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * 2 * Math.PI;
        points.push({
          x: cx + rx * Math.cos(t),
          y: cy + ry * Math.sin(t)
        });
      }
    }

    currentStroke.points = points;
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    shapeStartPos = null;
    redrawActivePage();
  } else {
    // Freihand-Stift / Marker / Radierer
    if (currentStroke.points.length < 2) {
      currentStroke.points.push({ ...currentStroke.points[0] });
    }
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    // Nach jedem Freihand-Strich alles neu zeichnen
    redrawActivePage();
  }

  currentStroke = null;
  saveData();
}



    function doUndo() {
      const page = getActivePage();
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      redoStack.push(stroke);
      undoStack.pop();
      redrawActivePage();
      saveData();
    }

    function doRedo() {
      const page = getActivePage();
      if (!page || redoStack.length === 0) return;
      const stroke = redoStack.pop();
      page.strokes.push(stroke);
      undoStack.push(stroke);
      redrawActivePage();
      saveData();
    }

    function clearPage() {
      const page = getActivePage();
      if (!page) return;
      if (!confirm("Diese Seite wirklich komplett leeren?")) return;
      page.strokes = [];
      undoStack = [];
      redoStack = [];
      redrawActivePage();
      saveData();
    }

    function exportPageAsPNG() {
      const page = getActivePage();
      if (!page) return;
      const link = document.createElement("a");
      link.href = canvas.toDataURL("image/png");
      link.download = (page.name || "Seite") + ".png";
      link.click();
    }

    // Canvas Events (Maus + Touch)
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", moveDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseleave", stopDrawing);

// Touch-Handling: 1 Finger = zeichnen, 2 Finger = Pinch-Zoom
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd);
canvas.addEventListener("touchcancel", handleTouchEnd);





function handleTouchStart(evt) {
  if (!evt.touches || evt.touches.length === 0) return;

  // 2 Finger ‚Üí Pinch-Zoom starten
  if (evt.touches.length === 2) {
    evt.preventDefault();          // Browser-Scroll/Zoom blockieren
    isPinching = true;
    lastPinchDist = getTouchDistance(evt.touches);
    lastPinchCenter = getTouchCenter(evt.touches);
  } else if (evt.touches.length === 1) {
    // 1 Finger ‚Üí normal zeichnen
    isPinching = false;
    startDrawing(evt);             // startDrawing nutzt normPos(evt)
  }
}

function handleTouchMove(evt) {
  if (!evt.touches || evt.touches.length === 0) return;

  if (isPinching && evt.touches.length === 2) {
    // Pinch aktiv
    evt.preventDefault();

    const newDist = getTouchDistance(evt.touches);
    const newCenter = getTouchCenter(evt.touches);

    const scaleChange = newDist / (lastPinchDist || newDist);
    zoom *= scaleChange;

    // Zoom-Grenzen (√§hnlich GoodNotes)
    zoom = Math.max(0.5, Math.min(zoom, 4));

    // Pan unter den Fingern anpassen
    if (lastPinchCenter) {
      panX += newCenter.x - lastPinchCenter.x;
      panY += newCenter.y - lastPinchCenter.y;
    }

    lastPinchDist = newDist;
    lastPinchCenter = newCenter;

    updateCanvasTransform();
  } else if (!isPinching && evt.touches.length === 1) {
    // normales Zeichnen mit einem Finger
    moveDrawing(evt); // moveDrawing ruft selbst preventDefault()
  }
}

function handleTouchEnd(evt) {
  // Pinch-Zustand beenden, wenn weniger als 2 Finger
  if (isPinching && (!evt.touches || evt.touches.length < 2)) {
    isPinching = false;
    lastPinchDist = null;
    lastPinchCenter = null;
  }

  // Wenn gar kein Finger mehr drauf ‚Üí Zeichnung abschlie√üen
  if (!evt.touches || evt.touches.length === 0) {
    stopDrawing(evt);
  }
}


    toolButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        toolButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentTool = btn.getAttribute("data-tool");
      });
    });

    colorPicker.addEventListener("input", () => {
      currentColor = colorPicker.value;
    });

    strokeButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        strokeButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentWidth = parseInt(btn.getAttribute("data-width"), 10);
      });
    });

    undoBtn.addEventListener("click", doUndo);
    redoBtn.addEventListener("click", doRedo);
    clearBtn.addEventListener("click", clearPage);
    addNotebookBtn.addEventListener("click", addNotebook);
    notebookSelect.addEventListener("change", e => switchNotebook(e.target.value));
    addPageBtn.addEventListener("click", addPage);
    templateSelect.addEventListener("change", e => setPageTemplate(e.target.value));
    exportPageBtn.addEventListener("click", exportPageAsPNG);

    // Rastergr√∂√üe √§ndern
if (templateSizeSelect) {
  // Beim Start auf gespeicherten Wert setzen
  templateSizeSelect.value = data.templateScale || "medium";

  templateSizeSelect.addEventListener("change", (e) => {
    data.templateScale = e.target.value;  // "small" | "medium" | "large"
    saveData();
    redrawActivePage();                   // Canvas neu zeichnen mit neuer Gr√∂√üe
  });
}


    // Backup
    exportJsonBtn.addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "uni-hyper-notes-backup.json";
      a.click();
      URL.revokeObjectURL(url);
    });
// Backup laden (Import)
importJsonBtn.addEventListener("click", () => {
  importJsonInput.value = "";      // evtl. alte Auswahl zur√ºcksetzen
  importJsonInput.click();         // Datei-Dialog √∂ffnen
});

importJsonInput.addEventListener("change", () => {
  const file = importJsonInput.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);

      // Ganz grobe Plausibilit√§tspr√ºfung
      if (!imported || !Array.isArray(imported.notebooks)) {
        alert("Diese Datei sieht nicht wie ein Uni-Hyper-Notes-Backup aus.");
        return;
      }

      // Unsere globale data ersetzen
      data = imported;

      // Sicherheitshalber: falls alte Backups ein paar Felder nicht hatten
      if (!data.cards) data.cards = { decks: [] };
      if (!data.planner) data.planner = { exams: [], focusSessions: [] };
      if (!data.formulas) data.formulas = [];
      if (!data.tasks) data.tasks = [];
      if (!data.brain) data.brain = { entries: [] };
      if (!data.theme) data.theme = "dark";

      // Aktive IDs setzen, falls fehlen
      if (!data.activeNotebookId && data.notebooks[0]) {
        data.activeNotebookId = data.notebooks[0].id;
      }
      const nb = data.notebooks.find(nb => nb.id === data.activeNotebookId) || data.notebooks[0];
      if (nb && !data.activePageId && nb.pages[0]) {
        data.activePageId = nb.pages[0].id;
      }

      // In localStorage speichern
      saveData();

      // UI komplett neu aufbauen
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      renderDecks();
      renderExams();
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();
      renderLearnSubjects();
      renderLearnTopics();
      renderLearnContent();

      alert("Backup wurde erfolgreich geladen ‚úÖ");

    } catch (err) {
      console.error(err);
      alert("Fehler beim Laden des Backups. Bist du sicher, dass es die richtige Datei ist?");
    }
  };

  reader.readAsText(file, "utf-8");
});

    // ---------- KARTEIKARTEN ----------
    const deckNameInput = document.getElementById("cardDeckName");
    const addDeckBtn = document.getElementById("addDeckBtn");
    const deckListDiv = document.getElementById("deckList");
    const cardQuestion = document.getElementById("cardQuestion");
    const cardAnswer = document.getElementById("cardAnswer");
    const cardTags = document.getElementById("cardTags");
    const addCardBtn = document.getElementById("addCardBtn");
    const cardListDiv = document.getElementById("cardList");
    const studyDeckSelect = document.getElementById("studyDeckSelect");
    const startStudyBtn = document.getElementById("startStudyBtn");
    const studyArea = document.getElementById("studyArea");
    const studyQuestionDiv = document.getElementById("studyQuestion");
    const studyAnswerDiv = document.getElementById("studyAnswer");
    const revealAnswerBtn = document.getElementById("revealAnswerBtn");
    const studyFeedback = document.getElementById("studyFeedback");
    const studyGradeBtns = document.querySelectorAll(".studyGradeBtn");
    let currentStudyDeckId = null;
    let currentStudyCardId = null;

    function renderDecks() {
      deckListDiv.innerHTML = "";
      studyDeckSelect.innerHTML = "";
      data.cards.decks.forEach(deck => {
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `<strong>${deck.name}</strong> <span class="badge">${deck.cards.length} Karten</span>`;
        card.addEventListener("click", () => selectDeck(deck.id));
        deckListDiv.appendChild(card);

        const opt = document.createElement("option");
        opt.value = deck.id;
        opt.textContent = deck.name;
        studyDeckSelect.appendChild(opt);
      });
      if (!currentStudyDeckId && data.cards.decks[0]) currentStudyDeckId = data.cards.decks[0].id;
      if (currentStudyDeckId) studyDeckSelect.value = currentStudyDeckId;
      renderCards();
    }

    function selectDeck(id) {
      currentStudyDeckId = id;
      renderCards();
    }

    function renderCards() {
      const deck = data.cards.decks.find(d => d.id === currentStudyDeckId);
      cardListDiv.innerHTML = "";
      if (!deck) return;
      deck.cards.forEach(c => {
        const div = document.createElement("div");
        div.className = "card";
        const due = c.nextDue ? new Date(c.nextDue) : null;
        const daysLeft = due ? Math.round((due - Date.now()) / (1000 * 60 * 60 * 24)) : null;
        div.innerHTML = `
          <div style="font-weight:600;">${c.q}</div>
          <div style="font-size:13px; margin-top:4px; opacity:0.8;">${c.a}</div>
          <div style="margin-top:4px;">
            ${(c.tags || []).map(t => `<span class="pill">${t}</span>`).join("")}
          </div>
          <div style="margin-top:4px; font-size:11px; opacity:0.7;">
            N√§chste Wiederholung: ${
              due
                ? due.toLocaleDateString() +
                  (daysLeft >= 0 ? ` (in ${daysLeft} Tagen)` : ` (√ºberf√§llig)`)
                : "noch nie"
            }
          </div>`;
        cardListDiv.appendChild(div);
      });
    }

    function addDeck() {
      const name = deckNameInput.value.trim();
      if (!name) return;
      data.cards.decks.push({ id: "deck-" + Date.now(), name, cards: [] });
      deckNameInput.value = "";
      saveData();
      renderDecks();
    }

    function addCard() {
      const deck = data.cards.decks.find(d => d.id === currentStudyDeckId);
      if (!deck) return;
      const q = cardQuestion.value.trim();
      const a = cardAnswer.value.trim();
      if (!q || !a) return;
      const tags = cardTags.value
        ? cardTags.value.split(",").map(t => t.trim()).filter(Boolean)
        : [];
      deck.cards.push({
        id: "card-" + Date.now(),
        q, a, tags,
        nextDue: null,
        easiness: 2.5,
        interval: 1,
        repetitions: 0
      });
      cardQuestion.value = "";
      cardAnswer.value = "";
      cardTags.value = "";
      saveData();
      renderCards();
    }

    function startStudy() {
      const deckId = studyDeckSelect.value;
      currentStudyDeckId = deckId;
      const deck = data.cards.decks.find(d => d.id === deckId);
      if (!deck || deck.cards.length === 0) return;
      pickNextStudyCard();
      studyArea.style.display = "block";
    }

    function pickNextStudyCard() {
      const deck = data.cards.decks.find(d => d.id === currentStudyDeckId);
      if (!deck) return;
      const now = Date.now();
      const dueCards = deck.cards.filter(c => !c.nextDue || c.nextDue <= now);
      const pool = dueCards.length > 0 ? dueCards : deck.cards;
      const card = pool[Math.floor(Math.random() * pool.length)];
      currentStudyCardId = card.id;
      studyQuestionDiv.textContent = card.q;
      studyAnswerDiv.textContent = card.a;
      studyAnswerDiv.style.display = "none";
      studyFeedback.style.display = "none";
      revealAnswerBtn.style.display = "inline-block";
    }

    function revealAnswer() {
      studyAnswerDiv.style.display = "block";
      studyFeedback.style.display = "block";
      revealAnswerBtn.style.display = "none";
    }

    function gradeStudy(evt) {
      const grade = parseInt(evt.target.getAttribute("data-grade"), 10);
      const deck = data.cards.decks.find(d => d.id === currentStudyDeckId);
      if (!deck) return;
      const card = deck.cards.find(c => c.id === currentStudyCardId);
      if (!card) return;
      let e = card.easiness || 2.5;
      e = e + (0.1 - (3 - grade) * (0.08 + (3 - grade) * 0.02));
      if (e < 1.3) e = 1.3;
      card.easiness = e;
      if (grade < 2) {
        card.repetitions = 0;
        card.interval = 1;
      } else {
        card.repetitions = (card.repetitions || 0) + 1;
        if (card.repetitions === 1) card.interval = 1;
        else if (card.repetitions === 2) card.interval = 6;
        else card.interval = Math.round((card.interval || 1) * e);
      }
      const now = Date.now();
      card.nextDue = now + card.interval * 24 * 60 * 60 * 1000;
      saveData();
      renderCards();
      pickNextStudyCard();
    }

    addDeckBtn.addEventListener("click", addDeck);
    addCardBtn.addEventListener("click", addCard);
    startStudyBtn.addEventListener("click", startStudy);
    revealAnswerBtn.addEventListener("click", revealAnswer);
    studyGradeBtns.forEach(b => b.addEventListener("click", gradeStudy));

    // ---------- PLANER ----------
    const examName = document.getElementById("examName");
    const examDate = document.getElementById("examDate");
    const examWeight = document.getElementById("examWeight");
    const addExamBtn = document.getElementById("addExamBtn");
    const examListDiv = document.getElementById("examList");
    const blockTopic = document.getElementById("blockTopic");
    const blockMinutes = document.getElementById("blockMinutes");
    const startBlockBtn = document.getElementById("startBlockBtn");
    const focusStatus = document.getElementById("focusStatus");
    let blockTimer = null;
    let blockEndTime = null;

    function renderExams() {
      examListDiv.innerHTML = "";
      const exams = data.planner.exams.slice().sort((a, b) => (a.date || "") < (b.date || "") ? -1 : 1);
      exams.forEach(ex => {
        const div = document.createElement("div");
        div.className = "card";
        const d = ex.date ? new Date(ex.date) : null;
        let daysText = "‚Äì";
        if (d) {
          const diff = Math.round((d.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
          daysText = diff >= 0 ? `in ${diff} Tagen` : `${-diff} Tage her`;
        }
        div.innerHTML = `
          <div style="font-weight:600;">${ex.name}</div>
          <div style="font-size:13px; margin-top:4px;">Datum: ${d ? d.toLocaleDateString() : "kein Datum"} | Wichtigkeit: ${ex.weight || "-"}</div>
          <div style="font-size:12px; margin-top:4px; opacity:0.8;">${daysText}</div>`;
        examListDiv.appendChild(div);
      });
    }

    function addExam() {
      const name = examName.value.trim();
      const date = examDate.value || null;
      const weight = examWeight.value ? parseInt(examWeight.value, 10) : null;
      if (!name) return;
      data.planner.exams.push({ id: "exam-" + Date.now(), name, date, weight });
      examName.value = "";
      examDate.value = "";
      examWeight.value = "";
      saveData();
      renderExams();
    }

    function startFocusBlock() {
      const topic = blockTopic.value.trim();
      let minutes = parseInt(blockMinutes.value, 10);
      if (!topic || !minutes || minutes < 5) return;
      const session = {
        id: "fs-" + Date.now(),
        topic,
        minutes,
        timestamp: Date.now()
      };
      data.planner.focusSessions.push(session);
      saveData();
      blockEndTime = Date.now() + minutes * 60 * 1000;
      updateFocusStatus();
      if (blockTimer) clearInterval(blockTimer);
      blockTimer = setInterval(updateFocusStatus, 1000);
    }

    function updateFocusStatus() {
      if (!blockEndTime) {
        focusStatus.textContent = "";
        return;
      }
      const diff = blockEndTime - Date.now();
      if (diff <= 0) {
        focusStatus.textContent = "Fokus-Block beendet ‚Äì nice!";
        clearInterval(blockTimer);
        blockTimer = null;
        blockEndTime = null;
        return;
      }
      const m = Math.floor(diff / 60000);
      const s = Math.floor((diff % 60000) / 1000);
      focusStatus.textContent = `Fokus l√§uft ‚Äì noch ${m}m ${s}s`;
    }

    addExamBtn.addEventListener("click", addExam);
    startBlockBtn.addEventListener("click", startFocusBlock);

    // ---------- FORMELN ----------
    const formulaName = document.getElementById("formulaName");
    const formulaExpression = document.getElementById("formulaExpression");
    const formulaTopic = document.getElementById("formulaTopic");
    const formulaVariables = document.getElementById("formulaVariables");
    const formulaNotes = document.getElementById("formulaNotes");
    const addFormulaBtn = document.getElementById("addFormulaBtn");
    const loadBiotechFormulasBtn = document.getElementById("loadBiotechFormulasBtn");
    const formulaFilter = document.getElementById("formulaFilter");
    const formulaListDiv = document.getElementById("formulaList");

    function renderFormulas() {
      const q = formulaFilter.value.toLowerCase();
      formulaListDiv.innerHTML = "";
      data.formulas
        .filter(f =>
          !q ||
          f.name.toLowerCase().includes(q) ||
          (f.topic || "").toLowerCase().includes(q)
        )
        .forEach(f => {
          const div = document.createElement("div");
          div.className = "card";
          div.innerHTML = `
            <div style="font-weight:600;">${f.name}</div>
            <div style="margin-top:4px;">${f.expression}</div>
            <div style="margin-top:4px; font-size:12px;">
              Thema: <span class="pill">${f.topic || "-"}</span>
            </div>
            <div style="margin-top:4px; font-size:12px; opacity:0.8;">
              Variablen: ${f.variables || "-"}
            </div>
            <div style="margin-top:4px; font-size:12px;">${f.notes || ""}</div>`;
          formulaListDiv.appendChild(div);
        });
    }

    function addFormula() {
      const name = formulaName.value.trim();
      const expr = formulaExpression.value.trim();
      if (!name || !expr) return;
      data.formulas.push({
        id: "formula-" + Date.now(),
        name,
        expression: expr,
        topic: formulaTopic.value.trim(),
        variables: formulaVariables.value.trim(),
        notes: formulaNotes.value.trim()
      });
      formulaName.value = "";
      formulaExpression.value = "";
      formulaTopic.value = "";
      formulaVariables.value = "";
      formulaNotes.value = "";
      saveData();
      renderFormulas();
    }

    function loadBiotechFormulas() {
      const presets = [
        {
          name: "Ideale Gasgleichung",
          expression: "p ¬∑ V = n ¬∑ R ¬∑ T",
          topic: "Allgemeine Chemie / Gase",
          variables: "p [Pa], V [m¬≥], n [mol], R = 8,314 J¬∑mol‚Åª¬π¬∑K‚Åª¬π, T [K]",
          notes: "Grundformel f√ºr ideale Gase. In PC/Allg. Chemie oft umstellen nach p, V, n oder T."
        },
        {
          name: "Arrhenius-Gleichung",
          expression: "k = A ¬∑ e^(‚àíE‚Çê / (R ¬∑ T))",
          topic: "Allgemeine Chemie / Kinetik",
          variables: "k [1/s], A: Frequenzfaktor, E‚Çê [J/mol], R, T [K]",
          notes: "Beschreibt Temperaturabh√§ngigkeit der Reaktionsgeschwindigkeit."
        },
        {
          name: "Lambert-Beer-Gesetz",
          expression: "A = Œµ ¬∑ c ¬∑ l",
          topic: "Analytik / Spektroskopie",
          variables: "A: Absorption, Œµ [L¬∑mol‚Åª¬π¬∑cm‚Åª¬π], c [mol/L], l [cm]",
          notes: "Standard zur Konzentrationsbestimmung mit Photometer."
        },
        {
          name: "Henderson-Hasselbalch",
          expression: "pH = pK‚Çê + log10([A‚Åª]/[HA])",
          topic: "Allgemeine Chemie / S√§ure-Base",
          variables: "[A‚Åª]: konjugierte Base, [HA]: S√§ure",
          notes: "Wichtig zur Berechnung von Pufferl√∂sungen."
        },
        {
          name: "Verd√ºnnungsgleichung",
          expression: "c‚ÇÅ ¬∑ V‚ÇÅ = c‚ÇÇ ¬∑ V‚ÇÇ",
          topic: "Allgemeine Chemie / L√∂sungen",
          variables: "c in [mol/L], V in [L]",
          notes: "Basis beim Ansetzen und Verd√ºnnen von L√∂sungen."
        },
        {
          name: "Stoffmenge",
          expression: "n = m / M",
          topic: "Allgemeine Chemie / Grundlagen",
          variables: "n [mol], m [g], M [g/mol]",
          notes: "Elementare Umrechnung zwischen Masse und Stoffmenge."
        }
      ];

      presets.forEach(f => {
        const exists = data.formulas.some(ex => ex.name === f.name);
        if (!exists) {
          data.formulas.push({
            id: "formula-" + Date.now() + "-" + Math.random().toString(36).slice(2),
            name: f.name,
            expression: f.expression,
            topic: f.topic,
            variables: f.variables,
            notes: f.notes
          });
        }
      });

      saveData();
      renderFormulas();
      alert("Biotech/Allg.-Chemie-Basisformeln wurden hinzugef√ºgt (wo sie noch gefehlt haben).");
    }

    addFormulaBtn.addEventListener("click", addFormula);
    formulaFilter.addEventListener("input", renderFormulas);
    loadBiotechFormulasBtn.addEventListener("click", loadBiotechFormulas);

    // ---------- TOOLS / RECHENTOOL ----------
    const toolFormulaSelect = document.getElementById("toolFormulaSelect");
    const toolInputs = document.getElementById("toolInputs");
    const toolCalcBtn = document.getElementById("toolCalcBtn");
    const toolResult = document.getElementById("toolResult");

    function renderToolInputs() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="dil_c1" placeholder="c‚ÇÅ (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="dil_v1" placeholder="V‚ÇÅ"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="dil_c2" placeholder="c‚ÇÇ"></div>
            <div><input type="number" step="any" id="dil_v2" placeholder="V‚ÇÇ"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Hinweis: Eine der Gr√∂√üen (c‚ÇÅ, V‚ÇÅ, c‚ÇÇ oder V‚ÇÇ) leer lassen, dann wird sie berechnet. Einheiten m√ºssen zueinander passen.</div>
        `;
      } else if (mode === "lambert") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="lam_A" placeholder="A (Absorption)"></div>
            <div><input type="number" step="any" id="lam_eps" placeholder="Œµ (z.B. L¬∑mol‚Åª¬π¬∑cm‚Åª¬π)"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="lam_c" placeholder="c [mol/L] (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="lam_l" placeholder="l [cm]"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Lambert-Beer: A = Œµ ¬∑ c ¬∑ l. Eine der Gr√∂√üen (meist c) leer lassen, dann wird sie berechnet.</div>
        `;
      }
    }

    function calcTool() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        const c1 = parseFloat(document.getElementById("dil_c1").value);
        const v1 = parseFloat(document.getElementById("dil_v1").value);
        const c2 = parseFloat(document.getElementById("dil_c2").value);
        const v2 = parseFloat(document.getElementById("dil_v2").value);

        const vals = { c1, v1, c2, v2 };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE Gr√∂√üe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "c1") result = c2 * v2 / v1;
          else if (missing === "v1") result = c2 * v2 / c1;
          else if (missing === "c2") result = c1 * v1 / v2;
          else if (missing === "v2") result = c1 * v1 / c2;
        } catch {
          toolResult.textContent = "Rechenfehler ‚Äì bitte Eingaben pr√ºfen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      } else if (mode === "lambert") {
        const A = parseFloat(document.getElementById("lam_A").value);
        const eps = parseFloat(document.getElementById("lam_eps").value);
        const c = parseFloat(document.getElementById("lam_c").value);
        const l = parseFloat(document.getElementById("lam_l").value);

        const vals = { A, eps, c, l };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE Gr√∂√üe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "A") result = eps * c * l;
          else if (missing === "eps") result = A / (c * l);
          else if (missing === "c") result = A / (eps * l);
          else if (missing === "l") result = A / (eps * c);
        } catch {
          toolResult.textContent = "Rechenfehler ‚Äì bitte Eingaben pr√ºfen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      }
    }

    toolFormulaSelect.addEventListener("change", renderToolInputs);
    toolCalcBtn.addEventListener("click", calcTool);

    // ---------- AUFGABEN ----------
    const taskTitle = document.getElementById("taskTitle");
    const taskTopic = document.getElementById("taskTopic");
    const taskText = document.getElementById("taskText");
    const taskNotes = document.getElementById("taskNotes");
    const addTaskBtn = document.getElementById("addTaskBtn");
    const taskListDiv = document.getElementById("taskList");

    function renderTasks() {
      taskListDiv.innerHTML = "";
      data.tasks.forEach(t => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div><strong>${t.title}</strong></div>
            <div>
              <span class="pill">${t.topic || "-"}</span>
              <select data-id="${t.id}" class="taskStatusSel">
                <option value="open" ${t.status === "open" ? "selected" : ""}>unsicher</option>
                <option value="ok" ${t.status === "ok" ? "selected" : ""}>geht so</option>
                <option value="done" ${t.status === "done" ? "selected" : ""}>sicher</option>
              </select>
            </div>
          </div>
          <div style="margin-top:4px; font-size:13px; white-space:pre-wrap;">${t.text}</div>
          <div style="margin-top:4px; font-size:12px; opacity:0.8; white-space:pre-wrap;">${t.notes || ""}</div>`;
        taskListDiv.appendChild(div);
      });
      document.querySelectorAll(".taskStatusSel").forEach(sel => {
        sel.addEventListener("change", evt => {
          const id = evt.target.getAttribute("data-id");
          const task = data.tasks.find(tt => tt.id === id);
          if (!task) return;
          task.status = evt.target.value;
          saveData();
        });
      });
    }

    function addTask() {
      const title = taskTitle.value.trim();
      const text = taskText.value.trim();
      if (!title || !text) return;
      data.tasks.push({
        id: "task-" + Date.now(),
        title,
        topic: taskTopic.value.trim(),
        text,
        notes: taskNotes.value.trim(),
        status: "open"
      });
      taskTitle.value = "";
      taskTopic.value = "";
      taskText.value = "";
      taskNotes.value = "";
      saveData();
      renderTasks();
    }

    addTaskBtn.addEventListener("click", addTask);

    // ---------- BRAIN-DUMP ----------
    const brainText = document.getElementById("brainText");
    const saveBrainBtn = document.getElementById("saveBrainBtn");
    const brainStatus = document.getElementById("brainStatus");
    const brainHistory = document.getElementById("brainHistory");

    function renderBrainHistory() {
      brainHistory.innerHTML = "";
      const entries = data.brain.entries.slice().sort((a, b) => b.date - a.date);
      entries.forEach(e => {
        const div = document.createElement("div");
        div.className = "card";
        const d = new Date(e.date);
        div.innerHTML = `
          <div style="font-size:12px; opacity:0.7;">${d.toLocaleString()}</div>
          <div style="margin-top:4px; white-space:pre-wrap;">${e.text}</div>`;
        brainHistory.appendChild(div);
      });
    }

    function saveBrainEntry() {
      const text = brainText.value.trim();
      if (!text) return;
      data.brain.entries.push({ id: "brain-" + Date.now(), text, date: Date.now() });
      brainText.value = "";
      brainStatus.textContent = "Gespeichert.";
      setTimeout(() => (brainStatus.textContent = ""), 2000);
      saveData();
      renderBrainHistory();
    }

    saveBrainBtn.addEventListener("click", saveBrainEntry);

    // ---------- STATS ----------
    const statsContent = document.getElementById("statsContent");

    function renderStats() {
      const sessions = data.planner.focusSessions || [];
      if (sessions.length === 0) {
        statsContent.textContent = "Noch keine Fokus-Sessions gespeichert.";
        return;
      }
      const totalMinutes = sessions.reduce((sum, s) => sum + (s.minutes || 0), 0);
      const byTopic = {};
      sessions.forEach(s => {
        const t = s.topic || "Sonstiges";
        byTopic[t] = (byTopic[t] || 0) + (s.minutes || 0);
      });
      let html = `<div>Gesamt-Lernzeit (nur Fokus-Bl√∂cke): <strong>${totalMinutes} Minuten</strong></div>`;
      html += `<div style="margin-top:6px;">Verteilung nach Themen:</div>`;
      html += `<ul style="padding-left:16px; margin-top:4px;">`;
      Object.keys(byTopic).forEach(t => {
        html += `<li>${t}: ${byTopic[t]} Min</li>`;
      });
      html += `</ul>`;
      statsContent.innerHTML = html;
    }

    // ---------- LERNEN ----------
    const learnSubjectsUl = document.getElementById("learnSubjects");
    const learnTopicsUl = document.getElementById("learnTopics");
    const learnContentDiv = document.getElementById("learnContent");
    let currentSubjectId = "allg-chem";
    let currentTopicId = "aufbau-materie";

    function renderLearnSubjects() {
      learnSubjectsUl.innerHTML = "";
      learnData.subjects.forEach(sub => {
        const li = document.createElement("li");
        li.className = "learn-item" + (sub.id === currentSubjectId ? " active" : "");
        li.textContent = sub.name;
        li.addEventListener("click", () => {
          currentSubjectId = sub.id;
          const firstTopic = sub.topics[0];
          if (firstTopic) currentTopicId = firstTopic.id;
          renderLearnSubjects();
          renderLearnTopics();
          renderLearnContent();
        });
        learnSubjectsUl.appendChild(li);
      });
    }

    function renderLearnTopics() {
      learnTopicsUl.innerHTML = "";
      const subject = learnData.subjects.find(s => s.id === currentSubjectId);
      if (!subject) return;
      subject.topics.forEach(t => {
        const li = document.createElement("li");
        li.className = "learn-item" + (t.id === currentTopicId ? " active" : "");
        li.textContent = t.title;
        li.addEventListener("click", () => {
          currentTopicId = t.id;
          renderLearnTopics();
          renderLearnContent();
        });
        learnTopicsUl.appendChild(li);
      });
    }

 function renderLearnContent() {
  const subject = learnData.subjects.find(s => s.id === currentSubjectId);
  if (!subject) {
    learnContentDiv.innerHTML = "";
    return;
  }

  const topic = subject.topics.find(t => t.id === currentTopicId) || subject.topics[0];
  if (!topic) {
    learnContentDiv.innerHTML = "";
    return;
  }

  const tagsHtml = (topic.tags || [])
    .map(tag => `<span class="learn-chip">${tag}</span>`)
    .join("");

  const goalsHtml = (topic.goals || [])
    .map(g => `<li>${g}</li>`)
    .join("");

  const keyHtml = (topic.keyPoints || [])
    .map(k => `<li>${k}</li>`)
    .join("");

  const formulasHtml = (topic.formulas || [])
    .map(f => `<li><code>${f}</code></li>`)
    .join("");

  const visualHtml = topic.visual
    ? `<div class="learn-section-title">Visuelle Hilfe</div>
       <div class="learn-visual">${topic.visual}</div>`
    : "";

  const detailBlocksHtml = (topic.detailBlocks || [])
    .map(block => `
      <div class="learn-section-title">${block.title}</div>
      <div style="font-size:12px; line-height:1.5; margin-bottom:6px;">
        ${block.content}
      </div>
    `)
    .join("");

  learnContentDiv.innerHTML = `
    <div class="card learn-card">
      <div class="learn-card-header">
        <div>
          <div class="learn-heading">${topic.title}</div>
          <div class="learn-subheading">${subject.name}</div>
        </div>
        <div class="learn-tagcount">
          ${(topic.tags || []).length} Stichworte
        </div>
      </div>

      <div class="learn-chiprow">${tagsHtml}</div>

      <div class="learn-section-title">Lernziele</div>
      <ul class="learn-list">${goalsHtml}</ul>

      <div class="learn-section-title">Zusammenfassung</div>
      <p style="font-size:13px; line-height:1.5; margin-top:4px;">
        ${topic.summary}
      </p>

      <div class="learn-section-title">Wichtige Punkte</div>
      <ul class="learn-list">${keyHtml}</ul>

      ${formulasHtml
        ? `<div class="learn-section-title">Wichtige Formeln (√úberblick)</div>
           <ul class="learn-list">${formulasHtml}</ul>`
        : ""}

      ${visualHtml}

      ${detailBlocksHtml}
    </div>
  `;
}


    // ---------- INIT ----------
    window.addEventListener("load", () => {
      loadData();
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      renderDecks();
      renderExams();
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();
      renderLearnSubjects();
      renderLearnTopics();
      renderLearnContent();
      syncFromCloud();
      updateCanvasTransform();
    });

// --- Sync-Button: Sync-ID speichern + aus Cloud laden ---
if (syncSaveBtn && syncIdInput) {
  syncSaveBtn.addEventListener("click", () => {
    const entered = syncIdInput.value.trim();
    if (!entered) {
      alert("Bitte eine Sync-ID eingeben.");
      return;
    }

    syncId = entered;
    localStorage.setItem("uniHyperNotes_syncId", syncId);
    updateSyncStatus("Sync-ID gespeichert: " + syncId);

    // Beim Klick auch gleich aus der Cloud laden
    syncFromCloud();
  });
}
  </script>
</body>
</html>
