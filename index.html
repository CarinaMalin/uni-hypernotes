const clearBtn = document.getElementById("clearBtn");
const exportPageBtn = document.getElementById("exportPageBtn");

    let currentTool = "pen"; // pen | highlighter | eraser | line | rect | circle
    let currentColor = colorPicker.value;
    let currentWidth = 2;
    let drawing = false;
    let currentStroke = null;
    let lastPos = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let shapeStartPos = null;
    let currentTool = "pen"; // pen | highlighter | eraser | line | rect | circle
    let currentColor = colorPicker.value;
    let currentWidth = 2;
    let drawing = false;
    let activePointerId = null;
    let currentStroke = null;
    let lastPos = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let shapeStartPos = null;

function getActiveNotebook() {
return data.notebooks.find(nb => nb.id === data.activeNotebookId);
@@ -2104,239 +2105,146 @@ <h3>Sync-Einstellungen</h3>
};
}

function handleTouchStart(e) {
  if (!e.touches || e.touches.length === 0) return;

  // Browser-Scroll/Zoom verhindern
  e.preventDefault();

  if (e.touches.length === 1) {
    // ðŸ‘‰ 1 Finger = normal zeichnen
    isPinching = false;
    startDrawing(e);
  } else if (e.touches.length === 2) {
    // ðŸ‘‰ 2 Finger = Pinch-Zoom starten
    isPinching = true;
    lastPinchDist = getTouchDistance(e.touches);
    lastPinchCenter = getTouchCenter(e.touches);
  }
}
function handleTouchStart(e) {
  if (!e.touches || e.touches.length === 0) return;

  if (e.touches.length === 2) {
    e.preventDefault();
    isPinching = true;
    lastPinchDist = getTouchDistance(e.touches);
    lastPinchCenter = getTouchCenter(e.touches);
  } else {
    isPinching = false;
  }
}

  function handleTouchMove(e) {
    if (!e.touches || e.touches.length === 0) return;
function handleTouchMove(e) {
  if (!e.touches || e.touches.length === 0) return;

    if (isPinching && e.touches.length === 2) {
      // ðŸ‘‰ Pinch aktiv
      e.preventDefault();
  if (isPinching && e.touches.length === 2) {
    e.preventDefault();

      const newDist = getTouchDistance(e.touches);
      const newCenter = getTouchCenter(e.touches);
    const newDist = getTouchDistance(e.touches);
    const newCenter = getTouchCenter(e.touches);

      // Zoom-Faktor anpassen
      const scaleChange = newDist / (lastPinchDist || newDist);
      setZoom(zoom * scaleChange, newCenter);
    const scaleChange = newDist / (lastPinchDist || newDist);
    setZoom(zoom * scaleChange, newCenter);

      // Pan unter den Fingern anpassen
      if (lastPinchCenter) {
        panX += newCenter.x - lastPinchCenter.x;
        panY += newCenter.y - lastPinchCenter.y;
      }
    if (lastPinchCenter) {
      panX += newCenter.x - lastPinchCenter.x;
      panY += newCenter.y - lastPinchCenter.y;
    }

      lastPinchDist = newDist;
      lastPinchCenter = newCenter;
    lastPinchDist = newDist;
    lastPinchCenter = newCenter;

      updateCanvasTransform();
    } else if (!isPinching && e.touches.length === 1) {
      // ðŸ‘‰ normales Zeichnen mit einem Finger
      moveDrawing(e); // nutzt dein normPos(e)
    }
    updateCanvasTransform();
}
}

function handleTouchEnd(e) {
  // Pinch beenden, wenn weniger als 2 Finger
  if (isPinching && (!e.touches || e.touches.length < 2)) {
    isPinching = false;
    lastPinchDist = 0;
    lastPinchCenter = null;
  }

  // Wenn gar kein Finger mehr drauf -> Zeichnung abschlieÃŸen
  if (!e.touches || e.touches.length === 0) {
    stopDrawing(e);
  }
}

    function startDrawing(evt) {
  evt.preventDefault();
  const page = getActivePage();
  if (!page) return;

  drawing = true;
  redoStack = [];

  const p = normPos(evt);
  lastPos = p;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // Formen: Startpunkt merken, Stroke nur als â€žPlatzhalterâ€œ
    shapeStartPos = p;
    currentStroke = {
      tool: "pen",
      color: currentColor,
      width: currentWidth,
      alpha: 1,
      points: [p]
    };
  } else {
    // Freihand-Stift / Marker / Radierer
    const stroke = {
      tool: currentTool,
      color: currentColor,
      // Marker bewusst dicker, wirkt mehr wie echter Textmarker
      width: currentTool === "highlighter" ? currentWidth * 4 : currentWidth,
      alpha: 1,
      points: [p]
    };

    if (currentTool === "eraser") {
      stroke.color = "#000000";
    }

    currentStroke = stroke;
    drawStrokeSegment(lastPos, p, stroke);
  }
}

function drawStrokeSegment(from, to, stroke) {
  ctx.save();

  if (stroke.tool === "eraser") {
    // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  } else if (stroke.tool === "highlighter") {
    // Halbtransparent wie echter Textmarker
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 0.35; // Transparent
  } else {
    // Normaler Stift
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  }

  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  ctx.beginPath();
  ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
  ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
  ctx.stroke();

  ctx.restore();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}


function moveDrawing(evt) {
  if (!drawing || !currentStroke) return;
  evt.preventDefault();

  const raw = normPos(evt);

  // FÃ¼r Linien/Rechteck/Kreis keine GlÃ¤ttung, nur Vorschau
  if (["line", "rect", "circle"].includes(currentTool)) {
    previewShape(raw);
    lastPos = raw;
    return;
  }

  // GlÃ¤ttung: Mischung aus alter und neuer Position (fÃ¼hlt sich noch direkt an)
  const p = {
    x: lastPos.x * 0.35 + raw.x * 0.65,
    y: lastPos.y * 0.35 + raw.y * 0.65
  };

  // Winzige Bewegungen ignorieren â†’ weniger Zittern
  const dx = p.x - lastPos.x;
  const dy = p.y - lastPos.y;
  const dist2 = dx * dx + dy * dy;
  if (dist2 < 0.000004) {
    return;
  }

  drawStrokeSegment(lastPos, p, currentStroke);
  currentStroke.points.push(p);
  lastPos = p;
}

function stopDrawing(evt) {
  if (!drawing) return;
  drawing = false;

  const page = getActivePage();
  if (!page || !currentStroke) return;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // finale Form als Punkte approximieren
    const start = shapeStartPos;
    const end = lastPos;
    let points = [];

    if (currentTool === "line") {
      points = [start, end];
    } else if (currentTool === "rect") {
      const xs = [start.x, end.x].sort((a, b) => a - b);
      const ys = [start.y, end.y].sort((a, b) => a - b);
      const xL = xs[0], xR = xs[1], yT = ys[0], yB = ys[1];
      points = [
        { x: xL, y: yT },
        { x: xR, y: yT },
        { x: xR, y: yB },
        { x: xL, y: yB },
        { x: xL, y: yT }
      ];
    } else if (currentTool === "circle") {
      const steps = 40;
      const cx = (start.x + end.x) / 2;
      const cy = (start.y + end.y) / 2;
      const rx = Math.abs(end.x - start.x) / 2;
      const ry = Math.abs(end.y - start.y) / 2;
      points = [];
      for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * 2 * Math.PI;
        points.push({
          x: cx + rx * Math.cos(t),
          y: cy + ry * Math.sin(t)
        });
      }
    }

    currentStroke.points = points;
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    shapeStartPos = null;
    redrawActivePage();
  } else {
    // Freihand-Stift / Marker / Radierer
    if (currentStroke.points.length < 2) {
      currentStroke.points.push({ ...currentStroke.points[0] });
    }
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    // Nach jedem Freihand-Strich alles neu zeichnen
    redrawActivePage();
  }
function handleTouchEnd(e) {
  if (isPinching && (!e.touches || e.touches.length < 2)) {
    isPinching = false;
    lastPinchDist = 0;
    lastPinchCenter = null;
  }
}

  currentStroke = null;
  saveData();
}
function applyStrokeStyle(stroke) {
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.miterLimit = 1;

  if (stroke.tool === "eraser") {
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  } else if (stroke.tool === "highlighter") {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 0.35;
  } else {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  }
}

function startDrawing(e) {
  if (e.pointerType === "touch") return;
  const page = getActivePage();
  if (!page) return;

  drawing = true;
  redoStack = [];
  activePointerId = e.pointerId;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const nx = x / rect.width;
  const ny = y / rect.height;

  const stroke = {
    tool: currentTool,
    color: currentColor,
    width: currentTool === "highlighter" ? currentWidth * 4 : currentWidth,
    alpha: 1,
    points: [{ x: nx, y: ny }]
  };

  if (stroke.tool === "eraser") {
    stroke.color = "#000000";
  }

  currentStroke = stroke;
  applyStrokeStyle(stroke);

  ctx.beginPath();
  ctx.moveTo(nx * canvas.width, ny * canvas.height);
}

function moveDrawing(e) {
  if (!drawing || e.pointerId !== activePointerId || !currentStroke) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const nx = x / rect.width;
  const ny = y / rect.height;

  applyStrokeStyle(currentStroke);
  ctx.lineTo(nx * canvas.width, ny * canvas.height);
  ctx.stroke();

  currentStroke.points.push({ x: nx, y: ny });
  lastPos = { x: nx, y: ny };
}

function stopDrawing(e) {
  if (!drawing || e.pointerId !== activePointerId) return;
  drawing = false;
  activePointerId = null;

  const page = getActivePage();
  if (!page || !currentStroke) return;

  if (currentStroke.points.length < 2) {
    currentStroke.points.push({ ...currentStroke.points[0] });
  }

  page.strokes.push(currentStroke);
  undoStack.push(currentStroke);
  currentStroke = null;

  ctx.closePath();

  redrawActivePage();
  saveData();
}



@@ -2380,18 +2288,18 @@ <h3>Sync-Einstellungen</h3>
link.click();
}

    // Canvas Events (Maus)
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", moveDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseleave", stopDrawing);
    // Canvas Events (Pointer)
canvas.addEventListener("pointerdown", startDrawing);
canvas.addEventListener("pointermove", moveDrawing);
canvas.addEventListener("pointerup", stopDrawing);
canvas.addEventListener("pointercancel", stopDrawing);


// Canvas Events (Touch â€“ 1 Finger = zeichnen, 2 Finger = Pinch-Zoom)
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove",  handleTouchMove,  { passive: false });
canvas.addEventListener("touchend",   handleTouchEnd,   { passive: false });
canvas.addEventListener("touchcancel",handleTouchEnd,   { passive: false });
// Canvas Events (Touch â€“ Pinch-Zoom/Pan)
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove",  handleTouchMove,  { passive: false });
canvas.addEventListener("touchend",   handleTouchEnd,   { passive: false });
canvas.addEventListener("touchcancel",handleTouchEnd,   { passive: false });

restore index.html to Simplify canvas drawing logic
