<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Uni Hyper Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    :root {
      --bg: #161821;
      --bg-gradient: radial-gradient(circle at top, #2a3245 0, #10121a 45%, #05060a 100%);
      --bg-elevated: #1f2230;
      --bg-sidebar: #181b27;
      --border: #2f3445;
      --text: #f7f7ff;
      --muted: #a4aac5;
      --accent: #7b8cff;
      --accent-soft: rgba(123, 140, 255, 0.16);
      --danger: #ff6b81;
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.55);
      --radius-card: 18px;
      --bg-primary: #0a0d1a;
      --bg-secondary: #12151f;
      --bg-card: #1a1d2e;
      --accent-hover: #8b9cff;
      --text-muted: #a4aac5;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .light {
      --bg: #f5f5fb;
      --bg-gradient: radial-gradient(circle at top, #ffffff 0, #eceefd 40%, #dde2ff 100%);
      --bg-elevated: #ffffff;
      --bg-sidebar: #f1f3ff;
      --border: #d3d7f0;
      --text: #1a1c2c;
      --muted: #6f7593;
      --accent: #4a5cff;
      --accent-soft: rgba(74, 92, 255, 0.18);
      --danger: #ff4d6a;
      --shadow-soft: 0 16px 40px rgba(32, 36, 90, 0.18);
      --radius-card: 18px;
      --bg-primary: #0a0d1a;
      --bg-secondary: #12151f;
      --bg-card: #1a1d2e;
      --accent-hover: #8b9cff;
      --text-muted: #a4aac5;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    /* ---------- Topbar ---------- */

    #topbar {
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
      background: rgba(5, 7, 15, 0.9);
      backdrop-filter: blur(18px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      z-index: 20;
    }

    body.light #topbar {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 12px 30px rgba(39, 46, 120, 0.25);
    }

    #topbar-left,
    #topbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #appTitle {
      font-weight: 800;
      font-size: 17px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #appTitle::before {
      content: "ğŸ“š";
      font-size: 16px;
    }

    button,
    select,
    input,
    textarea {
      font-family: inherit;
      font-size: 13px;
    }

    button,
    select {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 6px 11px;
      background: rgba(9, 11, 25, 0.9);
      color: var(--text);
      cursor: pointer;
      outline: none;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.15s ease transform, 0.15s ease box-shadow, 0.15s ease background-color, 0.15s ease border-color;
    }

    body.light button,
    body.light select {
      background: rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 0, 0, 0.05);
    }

    button:hover {
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0px) scale(0.97);
      box-shadow: none;
    }

    #darkModeBtn {
      font-size: 14px;
      padding-inline: 10px;
    }

    /* ---------- Tabbar ---------- */

    #tabbar {
      display: flex;
      align-items: center;
      padding: 5px 10px;
      background: radial-gradient(circle at top left, rgba(123, 140, 255, 0.2), transparent 40%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      gap: 4px;
      flex-wrap: wrap;
    }

    .tab-btn {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 4px 11px 5px;
      font-size: 12px;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: 0.16s ease background-color, 0.16s ease color, 0.16s ease transform;
    }

    .tab-btn::before {
      font-size: 13px;
    }

    .tab-btn[data-tab="notes"]::before { content: "âœï¸"; }
    .tab-btn[data-tab="cards"]::before { content: "ğŸ´"; }
    .tab-btn[data-tab="planner"]::before { content: "ğŸ—“ï¸"; }
    .tab-btn[data-tab="formulas"]::before { content: "âˆ‘"; }
    .tab-btn[data-tab="tools"]::before { content: "ğŸ§®"; }
    .tab-btn[data-tab="learn"]::before { content: "ğŸ“–"; }
    .tab-btn[data-tab="tasks"]::before { content: "ğŸ“Œ"; }
    .tab-btn[data-tab="biochem"]::before { content: "ğŸ§¬"; }
    .tab-btn[data-tab="brain"]::before { content: "ğŸ’­"; }
    .tab-btn[data-tab="stats"]::before { content: "ğŸ“Š"; }

    .tab-btn.active {
      background: var(--accent-soft);
      border-color: rgba(255, 255, 255, 0.16);
      color: var(--text);
      transform: translateY(-1px);
    }

    /* ---------- Main Layout ---------- */

    #main {
      flex: 1;
      display: flex;
      min-height: 0;
      padding: 10px 10px 12px 10px;
      gap: 10px;
    }

    /* ---------- Notizen-Bereich ---------- */

    #notesLayout.section {
      flex: 1;
      display: none;
      min-height: 0;
      background: transparent;
      position: relative;
    }

    #notesLayout.section.active {
      display: flex;
      gap: 8px;
    }

    /* Seiten-KontextmenÃ¼ */
    #pageContextMenu {
      position: fixed;
      background: rgba(18, 21, 38, 0.98);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 5px;
      z-index: 200;
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
      min-width: 150px;
      display: none;
    }
    .ctx-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 9px 13px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.1s;
      color: var(--text);
      user-select: none;
    }
    .ctx-menu-item:hover { background: rgba(255,255,255,0.09); }
    .ctx-menu-item.danger { color: var(--danger); }

    /* â”€â”€ Sidebar Toggle Button (im Flex-Flow zwischen Sidebar und Canvas) â”€â”€ */
    #sidebarToggleBtn {
      flex-shrink: 0;
      width: 18px;
      align-self: stretch;
      border-radius: 8px;
      padding: 0;
      font-size: 9px;
      background: rgba(123, 140, 255, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: 0.18s ease background, 0.18s ease color;
      writing-mode: vertical-rl;
      letter-spacing: 1px;
    }
    #sidebarToggleBtn:hover { background: rgba(123, 140, 255, 0.28); color: var(--text); }

    /* â”€â”€ Sidebar â”€â”€ */
    #sidebarNotes {
      width: 190px;
      min-width: 190px;
      background: linear-gradient(180deg, rgba(15, 18, 32, 0.99), rgba(10, 12, 22, 0.99));
      border-radius: var(--radius-card);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: var(--shadow-soft);
      padding: 10px 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: hidden;
      transition: width 0.22s ease, min-width 0.22s ease, padding 0.22s ease, opacity 0.22s ease;
    }
    #sidebarNotes.collapsed {
      width: 0;
      min-width: 0;
      padding: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* Notebook row */
    #notebookRow {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #notebookRow select { display: none; } /* jetzt nur intern genutzt */
    #notebookRow button {
      padding: 5px 7px;
      font-size: 12px;
      border-radius: 8px;
      flex-shrink: 0;
      min-width: 28px;
      min-height: 28px;
    }
    #notebookNameDisplay {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text);
      min-width: 0;
    }
    #backToLibraryBtn { font-size: 15px; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Notizbuch-Bibliothek
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #notebookLibrary {
      position: absolute;
      inset: 0;
      z-index: 20;
      background: var(--bg);
      border-radius: var(--radius-card);
      display: flex;
      flex-direction: column;
      padding: 28px 28px 20px;
      overflow-y: auto;
      transition: opacity 0.22s ease, transform 0.22s ease;
    }
    #notebookLibrary.lib-hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.975);
    }
    .nb-lib-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 22px;
      flex-shrink: 0;
    }
    .nb-lib-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    .nb-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(148px, 1fr));
      gap: 16px;
      align-content: start;
    }

    /* Notizbuch-Karte */
    .nb-card {
      border-radius: 14px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s cubic-bezier(.34,1.56,.64,1), box-shadow 0.2s;
      box-shadow: 0 5px 18px rgba(0,0,0,0.38);
      user-select: none;
      position: relative;
    }
    .nb-card:hover  { transform: translateY(-6px) scale(1.025); box-shadow: 0 14px 36px rgba(0,0,0,0.52); }
    .nb-card:active { transform: scale(0.97); }

    .nb-card-cover {
      height: 108px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 44px;
      position: relative;
      overflow: hidden;
    }
    /* Buch-RÃ¼cken (linker Schatten) */
    .nb-card-cover::before {
      content: "";
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 14px;
      background: rgba(0,0,0,0.22);
    }
    /* Glanzstreifen oben */
    .nb-card-cover::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 45%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.14), transparent);
      pointer-events: none;
    }
    .nb-card-info {
      padding: 10px 12px 11px;
      background: rgba(0,0,0,0.30);
    }
    .nb-card-name {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nb-card-meta {
      font-size: 11px;
      color: rgba(255,255,255,0.48);
      margin-top: 3px;
    }

    /* "+" Neue Karte */
    .nb-add-card {
      border-radius: 14px;
      border: 2px dashed rgba(255,255,255,0.13);
      cursor: pointer;
      min-height: 152px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: rgba(255,255,255,0.32);
      font-size: 13px;
      transition: border-color 0.2s, color 0.2s, background 0.2s;
      user-select: none;
    }
    .nb-add-card:hover {
      border-color: rgba(123,140,255,0.55);
      color: rgba(123,140,255,0.9);
      background: rgba(123,140,255,0.07);
    }
    .nb-add-card-icon { font-size: 30px; line-height: 1; }

    /* Erstellen-Modal */
    #nbCreateModal {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.68);
      backdrop-filter: blur(10px);
    }
    .nb-create-box {
      background: rgba(14,17,36,0.99);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 22px;
      padding: 28px 28px 24px;
      width: 340px;
      box-shadow: 0 28px 70px rgba(0,0,0,0.75);
    }
    .nb-create-box h3 {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 20px;
      color: var(--text);
    }
    .nb-create-preview {
      width: 76px; height: 76px;
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-size: 36px;
      margin: 0 auto 18px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.45);
    }
    .nb-section-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .nb-color-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 18px;
    }
    .nb-color-swatch {
      width: 26px; height: 26px;
      border-radius: 50%;
      cursor: pointer;
      border: 2.5px solid transparent;
      transition: transform 0.14s, border-color 0.14s;
    }
    .nb-color-swatch:hover   { transform: scale(1.2); }
    .nb-color-swatch.active  { border-color: #fff; transform: scale(1.15); }

    .nb-emoji-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 5px;
      margin-bottom: 20px;
      max-height: 110px;
      overflow-y: auto;
    }
    .nb-emoji-btn {
      font-size: 20px;
      padding: 6px;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      border: 2px solid transparent;
      transition: background 0.12s, border-color 0.12s;
    }
    .nb-emoji-btn:hover  { background: rgba(255,255,255,0.09); }
    .nb-emoji-btn.active { border-color: var(--accent); background: rgba(123,140,255,0.18); }

    .nb-create-name {
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 20px;
      font-size: 14px;
      padding: 10px 13px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
    }
    .nb-create-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .nb-btn-cancel {
      padding: 9px 18px;
      border-radius: 10px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--muted);
      font-size: 13px;
      cursor: pointer;
    }
    .nb-btn-create {
      padding: 9px 20px;
      border-radius: 10px;
      background: var(--accent);
      border: none;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.15s;
    }
    .nb-btn-create:hover { opacity: 0.88; }

    /* Bearbeiten-Button auf Karte */
    .nb-card-edit-btn {
      position: absolute;
      top: 8px; right: 8px;
      width: 30px; height: 30px;
      border-radius: 50%;
      background: rgba(0,0,0,0.45);
      border: 1.5px solid rgba(255,255,255,0.22);
      color: #fff;
      font-size: 13px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.15s, background 0.15s;
      z-index: 2;
      padding: 0;
    }
    .nb-card:hover .nb-card-edit-btn { opacity: 1; }
    .nb-card-edit-btn:hover { background: rgba(0,0,0,0.7); }
    /* iPad / Touch: immer sichtbar */
    @media (hover: none) { .nb-card-edit-btn { opacity: 0.82; } }

    /* Aktives Notizbuch â€“ weiÃŸer Ring */
    .nb-card.nb-active {
      box-shadow: 0 0 0 3px rgba(255,255,255,0.88), 0 8px 28px rgba(0,0,0,0.5);
    }

    /* Light-Mode-Overrides */
    body.light #notebookLibrary    { background: #eef0fa; }
    body.light .nb-add-card        { border-color: rgba(0,0,0,0.13); color: rgba(0,0,0,0.38); }
    body.light .nb-add-card:hover  { border-color: var(--accent); color: var(--accent); background: rgba(123,140,255,0.06); }
    body.light .nb-create-box      { background: #f8f9ff; border-color: rgba(0,0,0,0.1); }
    body.light .nb-create-name     { background: rgba(0,0,0,0.04); border-color: rgba(0,0,0,0.12); color: #222; }

    /* Pages header */
    #sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 6px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }
    #sidebar-section-title {
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.6;
      font-weight: 600;
    }
    #sidebar-header button {
      padding: 4px 9px;
      font-size: 14px;
      min-height: 30px;
      min-width: 30px;
    }

    /* Page list */
    #pageList {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 2px;
    }
    #pageList::-webkit-scrollbar { width: 3px; }
    #pageList::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.14); border-radius: 2px; }

    /* Page thumbnail â€“ GoodNotes style */
    .page-thumb {
      position: relative;
      background: rgba(10, 12, 24, 0.96);
      border-radius: 10px;
      border: 1.5px solid rgba(255,255,255,0.07);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
      cursor: pointer;
      overflow: hidden;
      transition: border-color 0.14s, box-shadow 0.14s, transform 0.1s;
      user-select: none;
    }
    .page-thumb:active { transform: scale(0.97); }
    .page-thumb.active {
      border-color: var(--accent);
      box-shadow: 0 4px 16px rgba(123,140,255,0.3);
    }

    /* Canvas preview inside thumbnail */
    .page-thumb-canvas {
      width: 100%;
      height: 95px;
      display: block;
      background: #fbfbff;
      border-radius: 8px 8px 0 0;
    }
    body.light .page-thumb-canvas { background: #fff; }

    /* Label bar */
    .page-thumb-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 7px;
      background: rgba(18, 21, 38, 0.96);
    }
    .page-thumb.active .page-thumb-label { background: rgba(123,140,255,0.2); }
    .page-thumb-name {
      font-size: 10px;
      color: var(--muted);
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .page-thumb.active .page-thumb-name { color: var(--text); }
    .page-thumb-num {
      font-size: 9px;
      opacity: 0.45;
      margin-left: 4px;
      flex-shrink: 0;
    }

    /* Delete button (visible on hover / long press) */
    .page-thumb-delete {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.88);
      color: white;
      font-size: 13px;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      border: none;
      cursor: pointer;
      z-index: 3;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }
    .page-thumb:hover .page-thumb-delete,
    .page-thumb.show-delete .page-thumb-delete { display: flex; }

    /* Drag & Drop â€“ Seiten umsortieren */
    .page-thumb.dragging  { opacity: 0.3; }
    .page-thumb.drag-over {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(123,140,255,0.18);
    }
    .page-thumb { cursor: grab; }
    .page-thumb:active { cursor: grabbing; }

    /* Template-Picker Popover */
    .page-tmpl-picker {
      position: fixed;
      background: #1e2135;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 5px;
      box-shadow: 0 14px 44px rgba(0,0,0,0.75);
      z-index: 300;
      display: flex;
      flex-direction: column;
      gap: 1px;
      min-width: 148px;
    }
    .page-tmpl-picker button {
      text-align: left;
      padding: 9px 13px;
      border-radius: 8px;
      font-size: 13px;
      color: #f0f0ff;
      background: none;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background 0.12s;
    }
    .page-tmpl-picker button:hover { background: rgba(255,255,255,0.1); }
    .page-tmpl-picker .tmpl-icon {
      font-size: 15px;
      width: 20px;
      text-align: center;
    }
    body.light .page-tmpl-picker { background: #ffffff; border-color: rgba(0,0,0,0.12); box-shadow: 0 14px 44px rgba(0,0,0,0.18); }
    body.light .page-tmpl-picker button { color: #1a1a2e; }
    body.light .page-tmpl-picker button:hover { background: rgba(0,0,0,0.06); }

    /* Template controls */
    #templateControls {
      border-top: 1px solid rgba(255,255,255,0.06);
      padding-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #templateControls label {
      font-size: 10px;
      opacity: 0.55;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-top: 4px;
    }
    #templateControls select {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 8px;
      width: 100%;
    }

    /* â”€â”€ Canvas wrapper â”€â”€ */
    #canvasWrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 6px;
      min-width: 0;
      gap: 6px;
      overflow: hidden;
    }

    /* Toolbar */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 3px;
      background: radial-gradient(circle at top left, rgba(123,140,255,0.28), rgba(14,16,30,0.97));
      padding: 5px 10px;
      border-radius: 999px;
      box-shadow: var(--shadow-soft);
      flex-wrap: wrap;
      border: 1px solid rgba(255,255,255,0.06);
      max-width: 100%;
      width: fit-content;
    }
    body.light #toolbar {
      background: radial-gradient(circle at top left, rgba(123,140,255,0.14), rgba(255,255,255,0.97));
    }
    body.light #sidebarNotes {
      background: linear-gradient(180deg, rgba(245,247,255,0.99), rgba(238,241,255,0.99));
      border-color: rgba(0,0,0,0.07);
    }
    body.light #sidebar-header { border-top-color: rgba(0,0,0,0.07); }
    body.light .page-thumb { background: rgba(240,242,255,0.98); border-color: rgba(0,0,0,0.09); }
    body.light .page-thumb.active { border-color: var(--accent); }
    body.light .page-thumb-label { background: rgba(225,228,250,0.96); }
    body.light .page-thumb.active .page-thumb-label { background: rgba(74,92,255,0.15); }
    body.light .page-thumb-name { color: #3a3d5c; }
    body.light .page-thumb.active .page-thumb-name { color: #1a1c2c; }
    body.light #templateControls { border-top-color: rgba(0,0,0,0.07); }
    body.light #sidebarToggleBtn { background: rgba(74,92,255,0.1); border-color: rgba(0,0,0,0.08); color: #3a3d5c; }
    body.light .tool-btn { background: rgba(240,242,255,0.9); border-color: rgba(0,0,0,0.07); color: #4a4d6a; }
    body.light .tool-btn.active { background: rgba(74,92,255,0.2); border-color: var(--accent); color: #1a1c2c; }
    body.light .stroke-btn.active { background: rgba(74,92,255,0.18); border-color: var(--accent); }
    body.light .toolbar-sep { background: rgba(0,0,0,0.1); }
    body.light #pageContextMenu { background: rgba(245,247,255,0.98); border-color: rgba(0,0,0,0.1); }
    body.light .ctx-menu-item { color: #1a1c2c; }
    body.light .ctx-menu-item:hover { background: rgba(0,0,0,0.05); }

    /* Toolbar separator */
    .toolbar-sep {
      width: 1px;
      height: 20px;
      background: rgba(255,255,255,0.09);
      margin: 0 3px;
      flex-shrink: 0;
    }

    /* Canvas container â€“ clips overflow during zoom */
    #canvasContainer {
      flex: 1;
      width: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border-radius: 14px;
    }

    #canvas {
      background-color: #fbfbff;
      border-radius: 18px;
      box-shadow: 0 22px 55px rgba(5,6,17,0.85);
      touch-action: none;
      border: 1px solid rgba(0,0,0,0.08);
      transform-origin: center center;
      will-change: transform;
      cursor: crosshair;
    }
    body.light #canvas { background-color: #ffffff; }

    input[type="color"] {
      border: none;
      background: transparent;
      width: 30px;
      height: 30px;
      padding: 0;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.18);
      cursor: pointer;
    }

    .tool-btn {
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 9px;
      font-size: 14px;
      background: rgba(6,8,20,0.82);
      cursor: pointer;
      color: var(--muted);
      min-height: 34px;
      min-width: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn.active {
      border-color: var(--accent);
      background: rgba(123,140,255,0.26);
      color: var(--text);
    }

    .stroke-btn {
      padding: 5px 10px;
      font-size: 13px;
      min-height: 32px;
      border-radius: 8px;
    }
    .stroke-btn.active {
      border-color: var(--accent);
      background: rgba(123,140,255,0.18);
      color: var(--text);
    }

    /* Zoom indicator */
    #zoomLabel {
      font-size: 11px;
      opacity: 0.65;
      min-width: 40px;
      text-align: center;
      pointer-events: none;
    }

    /* Touch mode toggle */
    #touchModeBtn.scroll-mode {
      border-color: var(--warning);
      background: rgba(245,158,11,0.2);
      color: var(--warning);
    }

    label {
      font-size: 11px;
      opacity: 0.8;
    }

    /* ---------- Generische Sektionen (andere Tabs) ---------- */

    .section {
      flex: 1;
      padding: 0;
      display: none;
      overflow: auto;
    }

    .section.active {
      display: block;
    }

    /* Planner + Formeln iframe fills full height */
    #plannerSection.active, #formulasSection.active {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 0;
    }
    #plannerSection iframe, #formulasSection iframe {
      flex: 1;
      min-height: 0;
    }

    /* Lernen iframe fills full height (wie Planner/Formeln) */
    #learnSection.active { display: flex; flex-direction: column; overflow: hidden; padding: 0; }
    #learnSection iframe  { flex: 1; min-height: 0; }

    @media (max-width: 860px) {
      #sidebarNotes { width: 160px; min-width: 160px; }
      button, select { font-size: 11px; padding: 4px 8px; }
      #toolbar { padding: 4px 8px; }
      .tool-btn { min-height: 38px; min-width: 38px; font-size: 15px; }
    }
    /* iPad: bigger touch targets */
    @media (hover: none) and (pointer: coarse) {
      .tool-btn { min-height: 44px; min-width: 44px; font-size: 16px; padding: 8px; }
      .stroke-btn { min-height: 40px; padding: 7px 13px; }
      #sidebar-header button { min-height: 38px; min-width: 38px; }
      .page-thumb-canvas { height: 110px; }
      #notebookRow button { min-height: 34px; min-width: 34px; }
    }


/* ========== AMINOSÃ„URE-STRUKTUR ========== */
/* ====== AminosÃ¤ure-Struktur (funktioniert garantiert) ====== */
/* ======= AminosÃ¤ure-Struktur (funktioniert garantiert) ====== */
.amino-structure {
  display: grid;
  grid-template-columns: auto auto auto;
  grid-template-rows: auto auto auto;
  justify-items: center;
  align-items: center;
  gap: 4px;
  font-size: 1.2rem;
  font-family: system-ui, sans-serif;
}

/* ========= AminosÃ¤ure-Struktur â€“ saubere Version ========= */

#flashcardPreview {
  margin: 20px 0;
  display: flex;
  justify-content: center;   /* Struktur in der Mitte des Karteikarten-Bereichs */
}

/* Die Karte mit der Struktur */
.amino-structure {
  display: grid;
  grid-template-columns: auto auto auto;
  grid-template-rows: auto auto auto;
  gap: 6px;
  justify-items: center;
  align-items: center;
  padding: 16px 20px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  font-size: 1.2rem;
  font-family: system-ui, sans-serif;
  width: max-content;        /* ganz wichtig: wird nur so breit wie der Inhalt */
}

/* Positionen der Atome */
.amino-structure .top    { grid-row: 1; grid-column: 2; }
.amino-structure .left   { grid-row: 2; grid-column: 1; }

.amino-structure .center {
  grid-row: 2;
  grid-column: 2;
  font-weight: 700;

  position: relative;
  z-index: 2;
  padding: 0 0.25em 0.05em;           /* bisschen Abstand um das C herum */
  background-color: #181a24;          /* gleiche Farbe wie dein Kartenhintergrund */
  border-radius: 4px;                 /* leicht abgerundet, damit es weich aussieht */
}

.amino-structure .right  { grid-row: 2; grid-column: 3; }
.amino-structure .bottom { grid-row: 3; grid-column: 2; }

/* Bindungen â€“ beide im selben Grid-Feld in der Mitte -> Kreuz */
.amino-structure .bond-v {
  grid-row: 2;
  grid-column: 2;
  width: 3px;
  height: 40px;              /* LÃ¤nge vertikale Linie */
  background-color: #a88242;
}

.amino-structure .bond-h {
  grid-row: 2;
  grid-column: 2;
  height: 3px;
  width: 70px;               /* LÃ¤nge horizontale Linie */
  background-color: #a88242;
}

/* SchÃ¶ne Anzeige fÃ¼r ASCII-AminosÃ¤ure-Strukturen */
.amino-pretty {
  white-space: pre;          /* ZeilenumbrÃ¼che und Leerzeichen beibehalten */
  font-family: "Fira Code", Consolas, monospace;
  font-size: 1.1rem;
  line-height: 1.4;
  text-align: center;
}

/* ===== Tools Cards: Project idea styling ===== */
.tool-note {
  font-size: 13px;
  line-height: 1.6;
  opacity: 0.96;
}

.tool-note h4 {
  margin: 12px 0 6px;
  font-size: 13px;
  font-weight: 700;
  opacity: 0.95;
}

.tool-note p {
  margin: 8px 0;
}

.tool-note ul {
  margin: 6px 0 10px;
  padding-left: 18px;
}

.tool-note li {
  margin: 4px 0;
}

.tool-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 8px 0 10px;
}

.tool-tag {
  font-size: 12px;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  opacity: 0.95;
}

.formula-box {
  margin-top: 8px;
  padding: 10px 12px;
  border-radius: 14px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.07);
}

.formula-mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 12px;
}

.formula-sub {
  margin-top: 6px;
  font-size: 12px;
  opacity: 0.85;
}

/* ===== Collapsible Tool Cards ===== */
.tool-card {
  background: var(--bg-elevated);
  border-radius: var(--radius-card);
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: var(--shadow-soft);
  margin-bottom: 10px;
  overflow: hidden;
}

.tool-header {
  cursor: pointer;
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 15px;
  font-weight: 600;
  transition: background 0.2s ease;
  user-select: none;
  list-style: none;
}

.tool-header::-webkit-details-marker {
  display: none;
}

.tool-header:hover {
  background: rgba(255, 255, 255, 0.02);
}

.tool-icon {
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: var(--accent-soft);
}

.tool-title {
  flex: 1;
}

.tool-content {
  padding: 16px;
  border-top: 1px solid rgba(255, 255, 255, 0.04);
}

.tool-card[open] .tool-header {
  background: rgba(255, 255, 255, 0.02);
}

/* ===== Bio-Simulation Tabs ===== */
.bio-tabs {
  display: flex;
  gap: 6px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
  padding-bottom: 8px;
}

.bio-tab {
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 8px;
  border: 1px solid transparent;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.2s ease;
}

.bio-tab:hover {
  background: rgba(255, 255, 255, 0.03);
}

.bio-tab.active {
  background: var(--accent-soft);
  border-color: rgba(255, 255, 255, 0.1);
  color: var(--text);
}

.bio-tab-content {
  display: none;
}

.bio-tab-content.active {
  display: block;
}

/* ===== Parameter Groups ===== */
.param-group {
  background: rgba(255, 255, 255, 0.02);
  border-radius: 10px;
  padding: 10px 12px;
  margin-bottom: 10px;
}

.param-group-title {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 8px;
  opacity: 0.9;
}

.bio-param {
  display: grid !important;
  grid-template-columns: 1fr 2fr auto;
  align-items: center;
  gap: 8px;
  font-size: 11px !important;
  opacity: 0.85 !important;
  margin-bottom: 8px !important;
}

.bio-param span:first-child {
  font-weight: 500;
}

.param-val {
  min-width: 50px;
  text-align: right;
  font-weight: 600;
  opacity: 1 !important;
}

.formula-sub {
  margin-top: 6px;
  font-size: 12px;
  opacity: 0.85;
}

.modelCard {
      margin: 10px 0 14px 0;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .modelCard summary {
      cursor: pointer;
      user-select: none;
      margin-bottom: 6px;
    }
    .modelCard .small {
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.5;
    }

</style>



<body>
  <!-- TOPBAR -->
  <div id="topbar">
    <div id="topbar-left">
      <div id="appTitle">Uni Hyper Notes</div>
    </div>
    <div id="topbar-right">
      <button id="darkModeBtn">ğŸŒ™ / â˜€ï¸</button>
      <button id="exportPageBtn" title="Seite als PNG exportieren">ğŸ–¼ï¸ PNG</button>
      <button id="exportJsonBtn" title="Backup herunterladen">ğŸ’¾ Backup</button>
      <button id="importJsonBtn" title="Backup laden">ğŸ“‚ Laden</button>
      <input type="file" id="importJsonInput" accept="application/json" style="display:none;">
    </div>
  </div>

  <!-- TABBAR -->
  <div id="tabbar">
    <button class="tab-btn active" data-tab="notes">Notizen</button>
    <button class="tab-btn" data-tab="cards">Karteikarten</button>
    <button class="tab-btn" data-tab="planner">Planer</button>
    <button class="tab-btn" data-tab="formulas">Formeln</button>
    <button class="tab-btn" data-tab="tools">Tools</button>
    <button class="tab-btn" data-tab="learn">Lernen</button>
    <button class="tab-btn" data-tab="tasks">Aufgaben</button>
    <button class="tab-btn" data-tab="biochem">Bio/Chemie</button>
    <button class="tab-btn" data-tab="brain">Brain-Dump</button>
    <button class="tab-btn" data-tab="stats">Stats</button>
  </div>

  <div id="main">
    <!-- NOTIZEN-TAB -->
    <div id="notesLayout" class="section active">

      <!-- â•â• Notizbuch-Bibliothek (Overlay) â•â• -->
      <div id="notebookLibrary" class="lib-hidden">
        <div class="nb-lib-header">
          <span class="nb-lib-title">ğŸ“š Meine NotizbÃ¼cher</span>
        </div>
        <div id="nbGrid" class="nb-grid">
          <!-- wird per JS befÃ¼llt -->
        </div>
      </div>

      <!-- Erstellen-Modal (auÃŸerhalb des Overlays, fixed) -->
      <div id="nbCreateModal" style="display:none">
        <div class="nb-create-box">
          <h3>Neues Notizbuch</h3>
          <div class="nb-create-preview" id="nbCreatePreview">ğŸ“š</div>
          <div class="nb-section-label">Farbe</div>
          <div class="nb-color-row" id="nbColorRow"></div>
          <div class="nb-section-label">Emoji</div>
          <div class="nb-emoji-grid" id="nbEmojiGrid"></div>
          <input class="nb-create-name" id="nbCreateName" type="text" placeholder="Name des Notizbuchs â€¦" maxlength="40">
          <div class="nb-create-actions">
            <button class="nb-btn-cancel" id="nbCancelBtn">Abbrechen</button>
            <button class="nb-btn-create" id="nbConfirmBtn">Erstellen âœ“</button>
          </div>
        </div>
      </div>

      <!-- â”€â”€ Sidebar â”€â”€ -->
      <div id="sidebarNotes">

        <!-- Notizbuch-Zeile (select bleibt fÃ¼r JS, aber versteckt) -->
        <div id="notebookRow">
          <button id="backToLibraryBtn" title="Alle NotizbÃ¼cher anzeigen">ğŸ“š</button>
          <span id="notebookNameDisplay">â€“</span>
          <button id="deleteNotebookBtn" title="Notizbuch lÃ¶schen" style="color:var(--danger)">ğŸ—‘</button>
          <select id="notebookSelect" title="Notizbuch wÃ¤hlen"></select>
          <button id="addNotebookBtn" style="display:none">ï¼‹</button>
        </div>

        <!-- Seiten-Header -->
        <div id="sidebar-header">
          <span id="sidebar-section-title">Seiten</span>
          <button id="addPageBtn" title="Neue Seite">ï¼‹</button>
        </div>

        <!-- Seiten-Thumbnails -->
        <div id="pageList"></div>

        <!-- Template-Einstellungen -->
        <div id="templateControls">
          <label for="templateSelect">Vorlage</label>
          <select id="templateSelect">
            <option value="blank">Blanko</option>
            <option value="lined">Liniert</option>
            <option value="dotted">Gepunktet</option>
            <option value="grid">Kariert</option>
          </select>
          <label for="templateSizeSelect">RastergrÃ¶ÃŸe</label>
          <select id="templateSizeSelect">
            <option value="small">Fein</option>
            <option value="medium" selected>Mittel</option>
            <option value="large">GroÃŸ</option>
          </select>
        </div>
      </div>

      <!-- Sidebar-Toggle (zwischen Sidebar und Canvas) -->
      <button id="sidebarToggleBtn" title="Sidebar ein-/ausblenden">â—€</button>

      <!-- â”€â”€ Canvas-Bereich â”€â”€ -->
      <div id="canvasWrapper">

        <!-- Toolbar -->
        <div id="toolbar">
          <!-- Zeichenwerkzeuge -->
          <button class="tool-btn active" data-tool="pen" title="Stift">âœï¸</button>
          <button class="tool-btn" data-tool="highlighter" title="Marker">ğŸ–Šï¸</button>
          <button class="tool-btn" data-tool="eraser" title="Radierer">â¬œ</button>
          <button class="tool-btn" data-tool="line" title="Linie">â•±</button>
          <button class="tool-btn" data-tool="rect" title="Rechteck">â–­</button>
          <button class="tool-btn" data-tool="circle" title="Kreis">â—¯</button>

          <div class="toolbar-sep"></div>

          <!-- Farbe & StÃ¤rke -->
          <input type="color" id="colorPicker" value="#000000" title="Farbe wÃ¤hlen">
          <button class="stroke-btn active" data-width="2" title="DÃ¼nn">Â·</button>
          <button class="stroke-btn" data-width="5" title="Mittel">â€”</button>
          <button class="stroke-btn" data-width="9" title="Dick">â”</button>

          <div class="toolbar-sep"></div>

          <!-- Aktionen -->
          <button id="undoBtn" title="RÃ¼ckgÃ¤ngig (Strg+Z)">â†¶</button>
          <button id="redoBtn" title="Wiederholen (Strg+Y)">â†·</button>
          <button id="clearBtn" title="Seite leeren">ğŸ§¹</button>

          <div class="toolbar-sep"></div>

          <!-- Zoom-Steuerung -->
          <button id="zoomOutBtn" title="Herauszoomen">âˆ’</button>
          <span id="zoomLabel">100%</span>
          <button id="zoomInBtn" title="Hineinzoomen">ï¼‹</button>
          <button id="zoomResetBtn" title="Zoom zurÃ¼cksetzen">âŠ¡</button>

          <div class="toolbar-sep"></div>

          <!-- Touch-Modus (Finger: Zeichnen / Scrollen) -->
          <button id="touchModeBtn" title="Touch-Modus umschalten" style="font-size:13px;">âœï¸</button>
        </div>

        <!-- Canvas-Container (Overflow fÃ¼r Zoom/Pan) -->
        <div id="canvasContainer">
          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- KARTEIKARTEN-TAB -->
    <div id="cardsSection" class="section">
      <iframe 
        id="karteikarten-frame"
        src="karteikarten/index.html" 
        style="width:100%; height:100%; border:none; display:block;"
        allowfullscreen>
      </iframe>
    </div>

    <!-- PLANER-TAB -->
    <div id="plannerSection" class="section" style="padding:0;overflow:hidden;">
      <iframe
        id="plannerFrame"
        src="planner/index.html"
        style="width:100%;height:100%;border:none;display:block;"
        title="Planner"
      ></iframe>
    </div>

    <!-- FORMELN-TAB -->
    <div id="formulasSection" class="section" style="padding:0;overflow:hidden;">
      <iframe
        id="formelnFrame"
        src="formeln/index.html"
        style="width:100%;height:100%;border:none;display:block;"
        title="Formelsammlung"
      ></iframe>
    </div>

    <!-- TOOLS-TAB (Rechentool) -->
    <div id="toolsSection" class="section">

      <!-- Chemie-Rechentool -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">âš—ï¸</span>
          <span class="tool-title">Chemie-Rechentool</span>
        </summary>
        <div class="tool-content">
          <div class="row">
            <div>
              <select id="toolFormulaSelect">
                <option value="dilution">VerdÃ¼nnung (câ‚Â·Vâ‚ = câ‚‚Â·Vâ‚‚)</option>
                <option value="lambert">Lambert-Beer-Gesetz (A = ÎµÂ·cÂ·l)</option>
              </select>
            </div>
          </div>
          <div id="toolInputs" style="margin-top:8px;"></div>
          <div style="margin-top:6px;">
            <button id="toolCalcBtn">Berechnen</button>
            <span id="toolResult" style="font-size:13px; margin-left:8px;"></span>
          </div>
        </div>
      </details>

      <!-- pH-Rechner -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ§ª</span>
          <span class="tool-title">pH-Rechner</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:400px;">
            <label>
              Hâº-Konzentration (mol/L):
              <input id="phH" type="number" step="0.0000001" value="0.0001" placeholder="z.B. 0.0001">
            </label>
            <button id="phCalcBtn">pH berechnen</button>
            <div id="phResult" style="font-size:14px; font-weight:600; margin-top:4px;"></div>
          </div>
        </div>
      </details>

      <!-- Molmasse-Rechner -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">âš–ï¸</span>
          <span class="tool-title">Molmasse-Rechner</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:400px;">
            <label>
              Summenformel eingeben (z.B. H2O, NaCl, C6H12O6):
              <input id="molFormula" type="text" placeholder="z.B. H2O">
            </label>
            <button id="molCalcBtn">Molmasse berechnen</button>
            <div id="molResult" style="font-size:14px; font-weight:600; margin-top:4px;"></div>
          </div>
        </div>
      </details>

      <!-- Graphen-Zeichen-Tool -->
      <details class="tool-card">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ“ˆ</span>
          <span class="tool-title">Funktions-Plotter</span>
        </summary>
        <div class="tool-content">
          <div style="display:grid; gap:10px; max-width:700px;">
            <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap;">
              <label style="flex:1; min-width:200px;">
                Funktion (z.B. x^2, sin(x), 2*x+1):
                <input id="graphFunc" type="text" placeholder="x^2" value="x^2">
              </label>
              <label style="width:90px;">
                x von:
                <input id="graphXmin" type="number" value="-10" step="0.5">
              </label>
              <label style="width:90px;">
                bis:
                <input id="graphXmax" type="number" value="10" step="0.5">
              </label>
            </div>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:6px;">
              <button id="graphPlotBtn">ğŸ“Š Plotten</button>
              <button id="graphAddBtn">â• HinzufÃ¼gen</button>
              <button id="graphClearBtn">ğŸ—‘ï¸ Clear</button>
              <button id="graphToggleYAxis">âš™ï¸ Y-Achse</button>
            </div>
            
            <!-- Analyse-Features -->
            <div style="display:flex; gap:6px; flex-wrap:wrap; padding:8px; background:rgba(123,140,255,0.08); border-radius:8px;">
              <div style="font-size:11px; font-weight:600; width:100%; margin-bottom:4px;">ğŸ“Š Analyse:</div>
              <button id="graphDerivBtn" title="Ableitung anzeigen">ğŸ“ˆ Ableitung</button>
              <button id="graphZerosBtn" title="Nullstellen anzeigen">ğŸ¯ Nullstellen</button>
              <button id="graphExtremaBtn" title="Extrema anzeigen">â›°ï¸ Extrema</button>
              <button id="graphPolarBtn" title="Polar-Modus">ğŸŒ€ Polar</button>
            </div>
            
            <!-- Zoom/Pan Controls -->
            <div style="display:grid; grid-template-columns:auto 1fr auto; gap:8px; padding:8px; background:rgba(255,255,255,0.04); border-radius:8px; align-items:center;">
              <div style="font-size:11px; font-weight:600;">ğŸ” Navigation:</div>
              <div style="display:flex; gap:4px; justify-content:center; flex-wrap:wrap;">
                <button id="graphZoomInBtn" title="Hineinzoomen">ğŸ” +</button>
                <button id="graphZoomOutBtn" title="Herauszoomen">ğŸ” âˆ’</button>
                <button id="graphResetZoomBtn" title="Zoom zurÃ¼cksetzen">â†º Reset</button>
                <button id="graphPanUpBtn" title="Nach oben">â†‘</button>
                <button id="graphPanDownBtn" title="Nach unten">â†“</button>
                <button id="graphPanLeftBtn" title="Nach links">â†</button>
                <button id="graphPanRightBtn" title="Nach rechts">â†’</button>
                <button id="graphCenterBtn" title="Zentrieren">âŠ™ Center</button>
              </div>
              <div id="graphZoomLevel" style="font-size:11px; opacity:0.8; min-width:60px; text-align:right;">1.0x</div>
            </div>
            
            <div style="padding:6px 8px; background:rgba(255,255,255,0.03); border-radius:6px; font-size:10px; opacity:0.8;">
              ğŸ’¡ <b>Maus:</b> Mausrad = Zoom | Drag = Pan | Doppelklick = Reset | Shift+Click = Tangente<br>
              ğŸ“ <b>Funktionen:</b> sin, cos, tan, ln, log, exp, sqrt, abs, pi, e, factorial, heaviside, etc.<br>
              ğŸ“ <b>Parametrisch:</b> Eingabe als "x(t); y(t)" z.B. "cos(t); sin(t)" fÃ¼r Kreis
            </div>
            <!-- Manuelle Y-Achsen-Einstellung -->
            <div id="graphManualYAxisDiv" style="display:none; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px;">
              <div style="font-size:11px; font-weight:600; margin-bottom:6px; opacity:0.9;">ğŸ“ Y-Achse manuell:</div>
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:11px;">
                <label style="display:flex; flex-direction:column; gap:2px;">
                  <span style="opacity:0.8;">y min</span>
                  <input id="graphYmin" type="number" value="" placeholder="auto" step="1" style="font-size:11px; padding:3px;">
                </label>
                <label style="display:flex; flex-direction:column; gap:2px;">
                  <span style="opacity:0.8;">y max</span>
                  <input id="graphYmax" type="number" value="" placeholder="auto" step="1" style="font-size:11px; padding:3px;">
                </label>
              </div>
              <div style="margin-top:6px; display:flex; gap:6px;">
                <button id="graphApplyYAxis" style="font-size:11px; padding:4px 10px;">âœ“ Anwenden</button>
                <button id="graphResetYAxis" style="font-size:11px; padding:4px 10px;">â†» Auto</button>
              </div>
            </div>
            <canvas id="graphCanvas" width="2000" height="1200" 
                    style="width:100%; max-width:1200px; height:auto; border-radius:12px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08); cursor:grab;">
            </canvas>
            <div id="graphInfo" style="font-size:11px; opacity:.7;"></div>
          </div>
        </div>
      </details>

      <!-- Bakterienwachstums-Simulation -->
      <details class="tool-card" id="bioSimCard">
        <summary class="tool-header">
          <span class="tool-icon">ğŸ§¬</span>
          <span class="tool-title">Bakterienwachstums-Simulation</span>
        </summary>
        <div class="tool-content">

          <!-- Mini-Tabs fÃ¼r Parameter-Gruppen -->
          <div class="bio-tabs">
            <button class="bio-tab active" data-bio-tab="basic">Basis-Parameter</button>
            <button class="bio-tab" data-bio-tab="environment">Umwelt</button>
            <button class="bio-tab" data-bio-tab="advanced">Advanced</button>
          </div>

          <div style="display:grid; grid-template-columns: 1fr 1.2fr; gap:16px; margin-top:16px;">
            
            <!-- Parameter-Bereich -->
            <div>
              <!-- Basis-Parameter -->
              <div class="bio-tab-content active" data-bio-content="basic">
                <div class="param-group">
                  <div class="param-group-title">ğŸ¦  Population</div>
                  <label class="bio-param">
                    <span>Startpopulation Nâ‚€</span>
                    <input id="bioN0" type="range" min="10" max="1000000" step="10" value="1000">
                    <span id="bioN0Val" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Wachstumsrate râ‚€</span>
                    <input id="bioR0" type="range" min="0.05" max="1.2" step="0.01" value="0.60">
                    <span id="bioR0Val" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>KapazitÃ¤t Kâ‚€</span>
                    <input id="bioK0" type="range" min="100" max="1000000" step="100" value="200000">
                    <span id="bioK0Val" class="param-val"></span>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">â±ï¸ Simulation</div>
                  <label class="bio-param">
                    <span>Dauer (h)</span>
                    <input id="bioTmax" type="range" min="1" max="72" step="1" value="24">
                    <span id="bioTmaxVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Zeitschritt dt (h)</span>
                    <input id="bioDt" type="range" min="0.01" max="0.5" step="0.01" value="0.05">
                    <span id="bioDtVal" class="param-val"></span>
                  </label>
                </div>
              </div>

              <!-- Umwelt-Parameter -->
              <div class="bio-tab-content" data-bio-content="environment">
                <div class="param-group">
                  <div class="param-group-title">ğŸŒ¡ï¸ Umweltbedingungen</div>
                  <label class="bio-param">
                    <span>NÃ¤hrstoffe (%)</span>
                    <input id="bioNutr" type="range" min="0" max="100" step="1" value="70">
                    <span id="bioNutrVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Temperatur (Â°C)</span>
                    <input id="bioTemp" type="range" min="0" max="50" step="0.5" value="37">
                    <span id="bioTempVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>pH-Wert</span>
                    <input id="bioPH" type="range" min="3" max="10" step="0.1" value="7.0">
                    <span id="bioPHVal" class="param-val"></span>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">âš¡ Presets</div>
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                    <button type="button" id="bioPresetOptimal">âœ… Optimal</button>
                    <button type="button" id="bioPresetCold">â„ï¸ Kalt</button>
                    <button type="button" id="bioPresetPHStress">âš ï¸ pH-Stress</button>
                    <button type="button" id="bioPresetLowNutr">ğŸ½ï¸ Arm</button>
                  </div>
                </div>
              </div>

              <!-- Advanced Parameter -->
              <div class="bio-tab-content" data-bio-content="advanced">
                <div class="param-group">
                  <div class="param-group-title">âš™ï¸ Erweitert</div>
                  <label class="bio-param">
                    <span>Stress-Schwelle</span>
                    <input id="bioStressThr" type="range" min="0.05" max="0.80" step="0.01" value="0.30">
                    <span id="bioStressThrVal" class="param-val"></span>
                  </label>
                  <label class="bio-param">
                    <span>Sterberate (1/h)</span>
                    <input id="bioDeathMax" type="range" min="0.00" max="1.50" step="0.01" value="0.25">
                    <span id="bioDeathMaxVal" class="param-val"></span>
                  </label>
                  <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                    <input id="bioAdvancedToggle" type="checkbox">
                    <span style="font-size:12px;">Integrator-Auswahl aktivieren</span>
                  </label>
                  <label id="bioIntegratorWrap" style="display:none; margin-top:8px;">
                    <span style="font-size:12px;">Integrator:</span>
                    <select id="bioIntegrator" style="margin-left:6px; font-size:12px;">
                      <option value="euler">Euler</option>
                      <option value="heun">RK2 / Heun</option>
                    </select>
                  </label>
                </div>

                <div class="param-group">
                  <div class="param-group-title">â„¹ï¸ Modell</div>
                  <div style="font-size:11px; line-height:1.5; opacity:0.8;">
                    <div><b>Gleichung:</b> dN/dt = rÂ·NÂ·(1âˆ’N/K) âˆ’ dÂ·N</div>
                    <div style="margin-top:4px;"><b>Umwelt:</b> Fitness â†’ r, NÃ¤hrstoffe â†’ K</div>
                    <div style="margin-top:4px;"><b>Numerik:</b> Euler (Standard) / RK2</div>
                  </div>
                </div>
              </div>

              <!-- Buttons -->
              <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:12px;">
                <button id="bioRunBtn">â–¶ï¸ Simulieren</button>
                <button id="bioAddBtn">â• Vergleich</button>
                <button id="bioClearBtn">ğŸ—‘ï¸ Clear</button>
              </div>
            </div>

            <!-- Canvas-Bereich -->
            <div>
              <canvas id="bioCanvas" width="1200" height="750"
                      style="width:100%; height:auto; border-radius:12px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08);">
              </canvas>
              
              <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; font-size:11px;">
                <button id="bioExportPlotBtn" style="font-size:11px; padding:4px 8px;">ğŸ“· PNG</button>
                <button id="bioExportCsvBtn" style="font-size:11px; padding:4px 8px;">ğŸ“Š CSV</button>
                <button id="bioExportJsonBtn" style="font-size:11px; padding:4px 8px;">ğŸ“„ JSON</button>
                <span style="width:8px;"></span>
                <button id="bioAxisLockBtn" style="font-size:11px; padding:4px 8px;">ğŸ”’ Lock</button>
                <button id="bioAxisAutoBtn" style="font-size:11px; padding:4px 8px;">ğŸ”“ Auto</button>
                <span id="bioAxisStatus" style="opacity:.7; margin-left:6px;"></span>
              </div>

              <!-- Manuelle Achsen-Einstellung -->
              <div id="bioManualAxisDiv" style="display:none; margin-top:8px; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px;">
                <div style="font-size:11px; font-weight:600; margin-bottom:6px; opacity:0.9;">ğŸ“ Achsen manuell einstellen:</div>
                <div style="display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:6px; font-size:11px;">
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">t min (h)</span>
                    <input id="bioAxisTmin" type="number" value="0" step="1" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">t max (h)</span>
                    <input id="bioAxisTmax" type="number" value="24" step="1" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">N min</span>
                    <input id="bioAxisNmin" type="number" value="0" step="1000" style="font-size:11px; padding:3px;">
                  </label>
                  <label style="display:flex; flex-direction:column; gap:2px;">
                    <span style="opacity:0.8;">N max</span>
                    <input id="bioAxisNmax" type="number" value="200000" step="1000" style="font-size:11px; padding:3px;">
                  </label>
                </div>
                <div style="margin-top:6px; display:flex; gap:6px;">
                  <button id="bioApplyAxisBtn" style="font-size:11px; padding:4px 10px;">âœ“ Anwenden</button>
                  <button id="bioToggleManualAxis" style="font-size:11px; padding:4px 10px;">âœ• SchlieÃŸen</button>
                </div>
              </div>
              <button id="bioToggleManualAxis" style="font-size:11px; padding:4px 8px; margin-top:6px;">âš™ï¸ Achsen manuell</button>

              <div id="bioInfo" style="margin-top:8px; font-size:11px; opacity:.7;"></div>
            </div>

          </div>

        </div>
      </details>


    </div>



    <!-- LERNEN-TAB -->
    <div id="learnSection" class="section" style="padding:0;overflow:hidden;">
      <iframe
        id="learnFrame"
        src="lernen/"
        style="width:100%;height:100%;border:none;display:block;"
        title="Lernen"
      ></iframe>
    </div>

    <!-- AUFGABEN-TAB -->
    <div id="tasksSection" class="section">
      <div class="card">
        <h3>Rechenaufgabe / VerstÃ¤ndnisaufgabe hinzufÃ¼gen</h3>
        <div class="row">
          <div><input type="text" id="taskTitle" placeholder="Kurzbeschreibung (z.B. pV=nRT umstellen)"></div>
          <div><input type="text" id="taskTopic" placeholder="Thema / Modul (z.B. Allg. Chemie)"></div>
        </div>
        <div class="row">
          <div><textarea id="taskText" placeholder="Aufgabe (Text oder kopierter Inhalt)"></textarea></div>
          <div><textarea id="taskNotes" placeholder="Dein LÃ¶sungsweg / Notizen (optional)"></textarea></div>
        </div>
        <div class="row">
          <div style="flex:0 0 auto;"><button id="addTaskBtn">ï¼‹ Aufgabe speichern</button></div>
        </div>
      </div>

      <div class="card">
        <h3>Aufgaben-Liste</h3>
        <div id="taskList"></div>
      </div>
    </div>

    <!-- BRAIN-DUMP-TAB -->
    <div id="brainSection" class="section">
      <div class="card">
        <h3>Brain-Dump (Gedanken, Sorgen, Ideen)</h3>
        <textarea id="brainText" placeholder="Alles, was im Kopf rumschwirrt..."></textarea>
        <div style="margin-top:6px;">
          <button id="saveBrainBtn">Speichern</button>
          <span id="brainStatus" style="font-size:11px; opacity:0.7; margin-left:6px;"></span>
        </div>
      </div>

      <div class="card">
        <h3>Vergangene EintrÃ¤ge</h3>
        <div id="brainHistory"></div>
      </div>
    </div>

    <!-- BIO/CHEMIE-TAB -->
    <div id="biochemSection" class="section">
      <div class="card" style="padding: 0; overflow: hidden; height: calc(100vh - 150px);">
        <iframe 
          id="aminoFrame" 
          src="amino-tool/index.html" 
          style="width: 100%; height: 100%; border: none; display: block;"
          title="AminosÃ¤uren 3D Viewer"
        ></iframe>
      </div>
    </div>

    <!-- STATS-TAB -->
    <!-- STATS-TAB -->
<div id="statsSection" class="section">
  	<div class="card">
   	 <h3>Lern-Stats (einfach)</h3>
   	 <div id="statsContent"></div>
  	</div>

  <div class="card">
    	<h3>Sync-Einstellungen</h3>
   	 <div class="row">
     		 <div>
        <input type="text" id="syncIdInput" placeholder="z.B. CARINA-UNI-01">
      </div>
      <div style="flex:0 0 auto;">
        <button id="syncSaveIdBtn">Sync-ID speichern</button>
      </div>
    </div>
    <div style="margin-top:6px; font-size:12px; opacity:0.8;">
      GerÃ¤te mit der gleichen Sync-ID greifen auf dieselben Cloud-Daten zu.
      Wenn du keine Sync-ID setzt, bleibt alles nur lokal auf diesem GerÃ¤t.
    </div>
    <div id="syncStatus" style="margin-top:4px; font-size:11px; opacity:0.7;"></div>
  </div>
</div>


<script type="module">

// ---------- Firebase Setup ----------
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC0gBG9LNOOjWib7u5a5Ztq2bd9MGg7k",
  authDomain: "uni-hyper-notes.firebaseapp.com",
  projectId: "uni-hyper-notes",
  storageBucket: "uni-hyper-notes.firebasestorage.app",
  messagingSenderId: "1430311668000",
  appId: "1:1430311668000:web:802d30dea4e71fabfa77f45",
  measurementId: "G-2QN7W0W73K"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Sync-ID
let syncId = localStorage.getItem("uniHyperNotes_syncId") || null;

function askForSyncId() {
  if (!syncId) {
    const defaultId = "user-" + Math.random().toString(36).slice(2, 8);
    const entered = prompt("Sync-ID eingeben oder neue anlegen:", defaultId);
    syncId = (entered || defaultId).trim();
    localStorage.setItem("uniHyperNotes_syncId", syncId);
  }
  return syncId;
}

// --- Elemente fÃ¼r die Sync-UI ---
const syncIdInput  = document.getElementById("syncIdInput");
const syncSaveBtn  = document.getElementById("syncSaveIdBtn");
const syncStatusEl = document.getElementById("syncStatus");

// Sync-ID ins Eingabefeld schreiben (falls schon vorhanden)
if (syncIdInput && syncId) {
  syncIdInput.value = syncId;
}

// Statusanzeige bequem setzen
function updateSyncStatus(msg) {
  if (syncStatusEl) {
    syncStatusEl.textContent = msg;
  }
  console.log("[SYNC]", msg);
}

// ---------- LERN-DATEN (Allgemeine Chemie, erweitert) ----------


    // ---------- DATENMODELL ----------
    
let data = {
  theme: "dark",
  syncId: null,
  notebooks: [],
  activeNotebookId: null,
  activePageId: null,
  cards: { decks: [] },
  planner: { exams: [], focusSessions: [] },
  formulas: [],
  tasks: [],
  brain: { entries: [] },
  templateScale: "medium"   // ğŸ‘ˆ NEU: RastergrÃ¶ÃŸe (small / medium / large)
};


    const STORAGE_KEY = "uniHyperNotes_v3";

    // ---------- COMMON DOM ----------
    const tabButtons = document.querySelectorAll(".tab-btn");
    const sections = {
      notes: document.getElementById("notesLayout"),
      cards: document.getElementById("cardsSection"),
      planner: document.getElementById("plannerSection"),
      formulas: document.getElementById("formulasSection"),
      tools: document.getElementById("toolsSection"),
      learn: document.getElementById("learnSection"),
      tasks: document.getElementById("tasksSection"),
      biochem: document.getElementById("biochemSection"),
      brain: document.getElementById("brainSection"),
      stats: document.getElementById("statsSection")
    };

    const darkModeBtn = document.getElementById("darkModeBtn");
    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const importJsonBtn = document.getElementById("importJsonBtn");
    const importJsonInput = document.getElementById("importJsonInput");

    // ---------- NOTIZEN / CANVAS ----------
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const notebookSelect = document.getElementById("notebookSelect");
    const addNotebookBtn = document.getElementById("addNotebookBtn");

// iPad/Safari: eigenes Scroll-/Zoom-Verhalten abschalten
canvas.style.touchAction = "none";


// --- Zoom & Pan ---
let zoom = 1;
let panX = 0;
let panY = 0;
let isPinching = false;
let lastPinchDist = 0;
let lastPinchCenter = null;
let touchMode = "draw"; // "draw" | "scroll"
let panStart = null; // for 1-finger pan in scroll mode

// Wendet CSS-Transform auf Canvas an und aktualisiert Zoom-Label
function updateCanvasTransform() {
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
  const zl = document.getElementById("zoomLabel");
  if (zl) zl.textContent = Math.round(zoom * 100) + "%";
}

function resetZoom() {
  zoom = 1; panX = 0; panY = 0;
  updateCanvasTransform();
}

// Zoom auf einen Bildschirm-Punkt (cx, cy) - korrekte Zoom-zu-Punkt Formel
function zoomToPoint(cx, cy, factor) {
  const rect = canvas.getBoundingClientRect();
  const screenCX = rect.left + rect.width / 2;
  const screenCY = rect.top + rect.height / 2;
  const oldZoom = zoom;
  zoom = Math.max(0.4, Math.min(5, zoom * factor));
  // Pan anpassen, sodass der Punkt unter (cx,cy) bleibt
  panX += (cx - screenCX) * (1 - zoom / oldZoom);
  panY += (cy - screenCY) * (1 - zoom / oldZoom);
  updateCanvasTransform();
}


    const addPageBtn = document.getElementById("addPageBtn");
    const pageList = document.getElementById("pageList");
    const templateSelect = document.getElementById("templateSelect");
    const templateSizeSelect = document.getElementById("templateSizeSelect");
    const sidebarNotes = document.getElementById("sidebarNotes");

// Pencil-Zeichnen Ã¼ber Pointer Events


    const colorPicker = document.getElementById("colorPicker");
    const toolButtons = document.querySelectorAll(".tool-btn");
    const strokeButtons = document.querySelectorAll(".stroke-btn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const clearBtn = document.getElementById("clearBtn");
    const exportPageBtn = document.getElementById("exportPageBtn");

    let currentTool = "pen"; // pen | highlighter | eraser | line | rect | circle
    let currentColor = colorPicker.value;
    let currentWidth = 2;
    let drawing = false;
    let currentStroke = null;
    let lastPos = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let shapeStartPos = null;

    function getActiveNotebook() {
      return data.notebooks.find(nb => nb.id === data.activeNotebookId);
    }

    function getActivePage() {
      const nb = getActiveNotebook();
      if (!nb) return null;
      return nb.pages.find(p => p.id === data.activePageId);
    }

    // ---------- Storage & Theme ----------
    function saveData() {
  // Lokal speichern (wie bisher)
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Versuchen, in die Cloud zu syncen (non-blocking)
  syncToCloud();
}

// ---- Cloud-Sync: Hochladen ----
async function syncToCloud() {
  try {
    const id = askForSyncId();  // sorgt dafÃ¼r, dass wir eine Sync-ID haben
    if (!id) return;

    updateSyncStatus("Synchronisiere mit Cloud â€¦");

    const ref = doc(db, "syncProfiles", id);
    await setDoc(ref, {
      data,
      updatedAt: Date.now()
    });

    updateSyncStatus("Mit Cloud synchronisiert âœ”");
  } catch (err) {
    console.error("Cloud-Sync fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Cloud-Sync (lokal ist alles sicher).");
  }
}


    function loadData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const defaultNotebook = {
          id: "nb-" + Date.now(),
          name: "Standard",
          pages: [
            { id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }
          ]
        };
        data.notebooks = [defaultNotebook];
        data.activeNotebookId = defaultNotebook.id;
        data.activePageId = defaultNotebook.pages[0].id;
        data.theme = "dark";
        data.cards = { decks: [] };
        data.planner = { exams: [], focusSessions: [] };
        data.formulas          = [];
        data.tasks             = [];
        data.brain             = { entries: [] };
        data.templateScale     = "medium";
        data.learnTopicStatus  = {};
        data.learnUserTopics   = [];
        return;
      }
      try {
        data = JSON.parse(raw);
        if (!data.templateScale)     data.templateScale     = "medium"; // ğŸ‘ˆ falls altes Backup
        if (!data.learnTopicStatus)  data.learnTopicStatus  = {};
        if (!data.learnUserTopics)   data.learnUserTopics   = [];
      } catch (e) {
        console.error("Fehler beim Laden, initialisiere neu", e);
        localStorage.removeItem(STORAGE_KEY);
        loadData();
      }
    }

// ---- Cloud-Sync: Herunterladen ----
async function syncFromCloud() {
  try {
    const id = askForSyncId();
    if (!id) return;

    updateSyncStatus("Lade Daten aus der Cloud â€¦");

    const ref = doc(db, "syncProfiles", id);
    const snap = await getDoc(ref);

    if (!snap.exists()) {
      updateSyncStatus("Noch keine Cloud-Daten fÃ¼r diese Sync-ID â€“ lokale Daten bleiben.");
      return;
    }

    const cloud = snap.data();
    if (cloud && cloud.data) {
  data = cloud.data;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Alles neu rendern, damit du es siehst
  applyTheme();
  renderNotebookSelect();
  resizeCanvas();
  renderPageList();
  redrawActivePage();

  // renderDecks() removed - replaced by Karteikarten2
  renderExams();
  renderFormulas();
  renderTasks();
  renderBrainHistory();
  renderStats();
  renderToolInputs();

  updateSyncStatus("Cloud-Daten geladen âœ”");
}
 else {
      updateSyncStatus("Cloud-Dokument leer â€“ keine Ã„nderung.");
    }
  } catch (err) {
    console.error("Cloud-Download fehlgeschlagen:", err);
    updateSyncStatus("Fehler beim Laden aus der Cloud.");
  }
}

    function applyTheme() {
      if (data.theme === "light") {
        document.body.classList.add("light");
      } else {
        document.body.classList.remove("light");
      }
    }

    function toggleTheme() {
      data.theme = data.theme === "dark" ? "light" : "dark";
      applyTheme();
      saveData();
    }

    darkModeBtn.addEventListener("click", toggleTheme);

    // ---------- Tabs ----------
    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        tabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const tab = btn.getAttribute("data-tab");
        Object.keys(sections).forEach(k => {
          if (k === "notes") {
            sections[k].classList.toggle("active", tab === "notes");
            sections[k].style.display = tab === "notes" ? "flex" : "none";
          } else {
            sections[k].classList.toggle("active", k === tab);
          }
        });
        if (tab === "stats") renderStats();
        if (tab === "notes") { renderNotebookLibrary(); showLibrary(); }
      });
    });

    // ---------- Notizbuch-Bibliothek ----------

    const NB_COLORS = [
      "#7b8cff", "#ff7b8a", "#7bddb0", "#ffc96b",
      "#c87bff", "#7bd4ff", "#ff8cc8", "#a0e87b"
    ];
    const NB_EMOJIS = [
      "ğŸ“š","ğŸ“–","ğŸ“","ğŸ“","ğŸ”¬","ğŸ§¬","âš—ï¸","ğŸ§ª",
      "ğŸ“Š","ğŸ“ˆ","ğŸ’¡","ğŸ¨","ğŸ¯","ğŸ§®","ğŸ”­","ğŸŒ¿",
      "âš¡","ğŸ¦‹","ğŸŒ¸","ğŸ†","ğŸ§ ","ğŸ”¥","ğŸµ","ğŸŒ"
    ];

    // Stellt sicher dass alte NotizbÃ¼cher color+emoji haben
    function ensureNotebookMeta() {
      data.notebooks.forEach((nb, i) => {
        if (!nb.color) nb.color = NB_COLORS[i % NB_COLORS.length];
        if (!nb.emoji) nb.emoji = "ğŸ“š";
      });
    }

    function showLibrary() {
      document.getElementById("notebookLibrary").classList.remove("lib-hidden");
    }

    function hideLibrary() {
      document.getElementById("notebookLibrary").classList.add("lib-hidden");
    }

    function renderNotebookLibrary() {
      ensureNotebookMeta();
      const grid = document.getElementById("nbGrid");
      if (!grid) return;
      grid.innerHTML = "";

      data.notebooks.forEach(nb => {
        const pageCount = nb.pages ? nb.pages.length : 0;
        const isActive  = nb.id === data.activeNotebookId;
        const card = document.createElement("div");
        card.className = "nb-card" + (isActive ? " nb-active" : "");
        card.innerHTML = `
          <div class="nb-card-cover" style="background:${nb.color}">
            <span style="position:relative;z-index:1">${nb.emoji}</span>
            <button class="nb-card-edit-btn" title="Bearbeiten">âœï¸</button>
          </div>
          <div class="nb-card-info">
            <div class="nb-card-name">${nb.name}</div>
            <div class="nb-card-meta">${pageCount} Seite${pageCount !== 1 ? "n" : ""}</div>
          </div>`;

        // Karte klicken â†’ Notizbuch Ã¶ffnen
        card.addEventListener("click", () => {
          switchNotebook(nb.id);
          hideLibrary();
        });

        // Edit-Button: stoppt Propagation, Ã¶ffnet Modal im Bearbeiten-Modus
        const editBtn = card.querySelector(".nb-card-edit-btn");
        editBtn.addEventListener("click", e => {
          e.stopPropagation();
          showNbCreateModal(nb.id);
        });

        grid.appendChild(card);
      });

      // "+ Neues Notizbuch"-Karte
      const addCard = document.createElement("div");
      addCard.className = "nb-add-card";
      addCard.innerHTML = `<span class="nb-add-card-icon">ï¼‹</span><span>Neues Notizbuch</span>`;
      addCard.addEventListener("click", showNbCreateModal);
      grid.appendChild(addCard);
    }

    function updateNotebookNameDisplay() {
      const nb = getActiveNotebook();
      const el = document.getElementById("notebookNameDisplay");
      if (el && nb) el.textContent = nb.name;
    }

    // â”€â”€ Create / Edit-Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let _nbPickColor = NB_COLORS[0];
    let _nbPickEmoji = "ğŸ“š";
    let _nbEditId    = null;   // null = Erstellen, id = Bearbeiten

    // Ã–ffnet das Modal â€“ ohne Argument: Neues Notizbuch
    //                    mit nbId-Argument: Notizbuch bearbeiten
    function showNbCreateModal(nbIdToEdit) {
      ensureNotebookMeta();
      _nbEditId = nbIdToEdit || null;
      const isEdit = !!_nbEditId;
      const existing = isEdit ? data.notebooks.find(n => n.id === _nbEditId) : null;

      // Titel + Button-Label anpassen
      const h3 = document.querySelector(".nb-create-box h3");
      if (h3) h3.textContent = isEdit ? "Notizbuch bearbeiten" : "Neues Notizbuch";
      const confirmBtn = document.getElementById("nbConfirmBtn");
      if (confirmBtn) confirmBtn.textContent = isEdit ? "Speichern âœ“" : "Erstellen âœ“";

      // Startwerte
      _nbPickColor = isEdit ? (existing.color || NB_COLORS[0])
                             : NB_COLORS[data.notebooks.length % NB_COLORS.length];
      _nbPickEmoji = isEdit ? (existing.emoji || "ğŸ“š")
                             : NB_EMOJIS[data.notebooks.length % NB_EMOJIS.length];

      // Vorschau
      const preview = document.getElementById("nbCreatePreview");
      preview.style.background = _nbPickColor;
      preview.textContent = _nbPickEmoji;

      // Farbfelder aufbauen
      const colorRow = document.getElementById("nbColorRow");
      colorRow.innerHTML = "";
      NB_COLORS.forEach(c => {
        const sw = document.createElement("span");
        sw.className = "nb-color-swatch" + (c === _nbPickColor ? " active" : "");
        sw.style.background = c;
        sw.addEventListener("click", () => {
          _nbPickColor = c;
          colorRow.querySelectorAll(".nb-color-swatch").forEach(s => s.classList.remove("active"));
          sw.classList.add("active");
          preview.style.background = _nbPickColor;
        });
        colorRow.appendChild(sw);
      });

      // Emoji-Grid aufbauen
      const emojiGrid = document.getElementById("nbEmojiGrid");
      emojiGrid.innerHTML = "";
      NB_EMOJIS.forEach(em => {
        const btn = document.createElement("span");
        btn.className = "nb-emoji-btn" + (em === _nbPickEmoji ? " active" : "");
        btn.textContent = em;
        btn.addEventListener("click", () => {
          _nbPickEmoji = em;
          emojiGrid.querySelectorAll(".nb-emoji-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          preview.textContent = _nbPickEmoji;
        });
        emojiGrid.appendChild(btn);
      });

      // Name-Feld
      const nameInput = document.getElementById("nbCreateName");
      nameInput.value = isEdit ? existing.name : "";
      document.getElementById("nbCreateModal").style.display = "flex";
      setTimeout(() => { nameInput.focus(); if (isEdit) nameInput.select(); }, 80);
    }

    function hideNbCreateModal() {
      document.getElementById("nbCreateModal").style.display = "none";
    }

    function confirmCreateNotebook() {
      const nameInput = document.getElementById("nbCreateName");
      const name = nameInput.value.trim() || (_nbEditId ? "Notizbuch" : "Neues Notizbuch");

      if (_nbEditId) {
        // â”€â”€ Bearbeiten: Name, Farbe, Emoji aktualisieren â”€â”€
        const nb = data.notebooks.find(n => n.id === _nbEditId);
        if (nb) {
          nb.name  = name;
          nb.color = _nbPickColor;
          nb.emoji = _nbPickEmoji;
          saveData();
          renderNotebookSelect();
          updateNotebookNameDisplay();
          renderNotebookLibrary();
        }
        hideNbCreateModal();
        return;
      }

      // â”€â”€ Erstellen: neues Notizbuch anlegen â”€â”€
      const nb = {
        id:    "nb-" + Date.now(),
        name,
        color: _nbPickColor,
        emoji: _nbPickEmoji,
        pages: [{ id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }]
      };
      data.notebooks.push(nb);
      data.activeNotebookId = nb.id;
      data.activePageId = nb.pages[0].id;
      undoStack = []; redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      updateNotebookNameDisplay();
      hideNbCreateModal();
      hideLibrary();
      saveData();
    }

    // ---------- Notebooks & Seiten ----------
    function renderNotebookSelect() {
      notebookSelect.innerHTML = "";
      data.notebooks.forEach(nb => {
        const opt = document.createElement("option");
        opt.value = nb.id;
        opt.textContent = nb.name;
        if (nb.id === data.activeNotebookId) opt.selected = true;
        notebookSelect.appendChild(opt);
      });
    }

    function switchNotebook(id) {
      if (id === data.activeNotebookId) return;
      data.activeNotebookId = id;
      const nb = getActiveNotebook();
      if (!nb) return;
      data.activePageId = nb.pages[0]?.id || null;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      updateNotebookNameDisplay();
      saveData();
    }

    function addNotebook() {
      const name = prompt("Name fÃ¼r das neue Notizbuch:", "Neues Notizbuch");
      if (!name) return;
      const nb = {
        id: "nb-" + Date.now(),
        name,
        pages: [{ id: "p-" + Date.now(), name: "Seite 1", template: "blank", strokes: [] }]
      };
      data.notebooks.push(nb);
      data.activeNotebookId = nb.id;
      data.activePageId = nb.pages[0].id;
      undoStack = [];
      redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      saveData();
    }

    let _dragPageId = null;

    function renderPageList() {
      const nb = getActiveNotebook();
      pageList.innerHTML = "";
      if (!nb) return;

      nb.pages.forEach((page, index) => {
        const div = document.createElement("div");
        div.className = "page-thumb" + (page.id === data.activePageId ? " active" : "");
        div.draggable = true;

        // Canvas-Vorschau
        const previewCanvas = document.createElement("canvas");
        previewCanvas.className = "page-thumb-canvas";
        const pw = 174, ph = 95;
        previewCanvas.width = pw;
        previewCanvas.height = ph;
        renderPageThumbnail(page, previewCanvas);
        div.appendChild(previewCanvas);

        // Label-Leiste
        const label = document.createElement("div");
        label.className = "page-thumb-label";
        const nameSpan = document.createElement("span");
        nameSpan.className = "page-thumb-name";
        nameSpan.textContent = page.name;
        const numSpan = document.createElement("span");
        numSpan.className = "page-thumb-num";
        numSpan.textContent = index + 1;
        label.appendChild(nameSpan);
        label.appendChild(numSpan);
        div.appendChild(label);

        // LÃ¶schen-Button
        const delBtn = document.createElement("button");
        delBtn.className = "page-thumb-delete";
        delBtn.innerHTML = "Ã—";
        delBtn.title = "Seite lÃ¶schen";
        delBtn.addEventListener("click", e => { e.stopPropagation(); deletePage(page.id); });
        div.appendChild(delBtn);

        // Seite auswÃ¤hlen
        div.addEventListener("click", () => {
          if (page.id === data.activePageId) return;
          data.activePageId = page.id;
          undoStack = []; redoStack = [];
          renderPageList();
          redrawActivePage();
          saveData();
        });

        // Doppelklick = Umbenennen
        div.addEventListener("dblclick", e => { e.stopPropagation(); renamePage(page.id); });

        // Rechtsklick = KontextmenÃ¼
        div.addEventListener("contextmenu", e => {
          e.preventDefault();
          showPageContextMenu(e, page.id);
        });

        // Long-Press auf Touch = LÃ¶schen-Button anzeigen
        let lpTimer = null;
        div.addEventListener("touchstart", () => {
          lpTimer = setTimeout(() => div.classList.add("show-delete"), 550);
        }, { passive: true });
        div.addEventListener("touchend", () => { clearTimeout(lpTimer); });
        div.addEventListener("touchmove", () => { clearTimeout(lpTimer); });

        // â”€â”€ Drag & Drop: Seiten umsortieren â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        div.addEventListener("dragstart", e => {
          _dragPageId = page.id;
          e.dataTransfer.effectAllowed = "move";
          setTimeout(() => div.classList.add("dragging"), 0);
        });
        div.addEventListener("dragend", () => {
          div.classList.remove("dragging");
          pageList.querySelectorAll(".page-thumb").forEach(el => el.classList.remove("drag-over"));
          _dragPageId = null;
        });
        div.addEventListener("dragover", e => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          if (page.id !== _dragPageId) {
            pageList.querySelectorAll(".page-thumb").forEach(el => el.classList.remove("drag-over"));
            div.classList.add("drag-over");
          }
        });
        div.addEventListener("drop", e => {
          e.preventDefault();
          if (!_dragPageId || _dragPageId === page.id) return;
          const nb2 = getActiveNotebook();
          if (!nb2) return;
          const fromIdx = nb2.pages.findIndex(p => p.id === _dragPageId);
          const toIdx   = nb2.pages.findIndex(p => p.id === page.id);
          if (fromIdx === -1 || toIdx === -1) return;
          const [moved] = nb2.pages.splice(fromIdx, 1);
          nb2.pages.splice(toIdx, 0, moved);
          saveData();
          renderPageList();
        });

        pageList.appendChild(div);
      });

      const activePage = getActivePage();
      if (activePage) templateSelect.value = activePage.template || "blank";
    }

    // Rendert eine Seite auf ein kleines Thumbnail-Canvas
    function renderPageThumbnail(page, thumbCanvas) {
      const tctx = thumbCanvas.getContext("2d");
      const tw = thumbCanvas.width;
      const th = thumbCanvas.height;

      // WeiÃŸer Hintergrund
      tctx.fillStyle = "#fbfbff";
      tctx.fillRect(0, 0, tw, th);

      // Template fein zeichnen
      const spacing = 11;
      tctx.save();
      tctx.globalAlpha = 0.13;
      tctx.strokeStyle = "#666";
      tctx.lineWidth = 0.6;
      if (page.template === "lined") {
        for (let y = spacing; y < th; y += spacing) {
          tctx.beginPath(); tctx.moveTo(0, y); tctx.lineTo(tw, y); tctx.stroke();
        }
      } else if (page.template === "grid") {
        for (let y = spacing; y < th; y += spacing) {
          tctx.beginPath(); tctx.moveTo(0, y); tctx.lineTo(tw, y); tctx.stroke();
        }
        for (let x = spacing; x < tw; x += spacing) {
          tctx.beginPath(); tctx.moveTo(x, 0); tctx.lineTo(x, th); tctx.stroke();
        }
      } else if (page.template === "dotted") {
        tctx.fillStyle = "#666";
        for (let y = spacing; y < th; y += spacing)
          for (let x = spacing; x < tw; x += spacing) {
            tctx.beginPath(); tctx.arc(x, y, 0.9, 0, Math.PI * 2); tctx.fill();
          }
      }
      tctx.restore();

      // Strokes zeichnen (skaliert auf Thumbnail-GrÃ¶ÃŸe)
      if (!page.strokes || page.strokes.length === 0) return;
      const mainW = canvas.width || 800;
      const mainH = canvas.height || 600;

      page.strokes.forEach(stroke => {
        if (!stroke.points || stroke.points.length < 2) return;
        tctx.save();
        if (stroke.tool === "eraser") {
          tctx.globalCompositeOperation = "destination-out";
          tctx.strokeStyle = "rgba(0,0,0,1)";
        } else {
          tctx.strokeStyle = stroke.color || "#000";
          if (stroke.tool === "highlighter") tctx.globalAlpha = 0.35;
        }
        tctx.lineWidth = Math.max(0.5, (stroke.width || 2) * (tw / mainW));
        tctx.lineCap = "round";
        tctx.lineJoin = "round";
        tctx.beginPath();
        tctx.moveTo(stroke.points[0].x * tw, stroke.points[0].y * th);
        for (let i = 1; i < stroke.points.length; i++) {
          tctx.lineTo(stroke.points[i].x * tw, stroke.points[i].y * th);
        }
        tctx.stroke();
        tctx.restore();
      });
    }

    // KontextmenÃ¼ fÃ¼r Seiten
    function showPageContextMenu(evt, pageId) {
      let menu = document.getElementById("pageContextMenu");
      if (!menu) {
        menu = document.createElement("div");
        menu.id = "pageContextMenu";
        document.body.appendChild(menu);
      }
      menu.innerHTML = `
        <div class="ctx-menu-item" data-action="rename">âœï¸ Umbenennen</div>
        <div class="ctx-menu-item" data-action="duplicate">ğŸ“‹ Duplizieren</div>
        <div class="ctx-menu-item danger" data-action="delete">ğŸ—‘ï¸ LÃ¶schen</div>
      `;
      menu.style.display = "block";
      menu.style.left = Math.min(evt.clientX, window.innerWidth - 160) + "px";
      menu.style.top = Math.min(evt.clientY, window.innerHeight - 120) + "px";

      menu.querySelectorAll(".ctx-menu-item").forEach(item => {
        item.addEventListener("click", () => {
          const action = item.dataset.action;
          if (action === "rename") renamePage(pageId);
          else if (action === "duplicate") duplicatePage(pageId);
          else if (action === "delete") deletePage(pageId);
          menu.style.display = "none";
        });
      });

      const hide = e => { if (!menu.contains(e.target)) { menu.style.display = "none"; document.removeEventListener("click", hide); } };
      setTimeout(() => document.addEventListener("click", hide), 0);
    }

    // Template-Picker beim "ï¼‹"-Button
    const NB_TEMPLATES = [
      { value: "blank",  label: "Blanko",  icon: "â¬œ" },
      { value: "lined",  label: "Liniert", icon: "â˜°"  },
      { value: "grid",   label: "Kariert", icon: "âŠ"  },
      { value: "dotted", label: "Punkte",  icon: "â ¿"  },
    ];

    function showPageTemplatePicker(e) {
      const existing = document.getElementById("pageTmplPicker");
      if (existing) { existing.remove(); return; }

      const picker = document.createElement("div");
      picker.id = "pageTmplPicker";
      picker.className = "page-tmpl-picker";

      NB_TEMPLATES.forEach(t => {
        const btn = document.createElement("button");
        btn.innerHTML = `<span class="tmpl-icon">${t.icon}</span>${t.label}`;
        btn.addEventListener("click", () => { picker.remove(); addPage(t.value); });
        picker.appendChild(btn);
      });

      // Unter dem Button positionieren
      const rect = e.currentTarget.getBoundingClientRect();
      picker.style.top  = (rect.bottom + 6) + "px";
      picker.style.left = Math.max(4, rect.right - 148) + "px";
      document.body.appendChild(picker);

      // SchlieÃŸen bei Klick auÃŸerhalb
      setTimeout(() => {
        document.addEventListener("click", function hide(ev) {
          if (!picker.contains(ev.target)) {
            picker.remove();
            document.removeEventListener("click", hide);
          }
        });
      }, 0);
    }

    function addPage(template) {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = {
        id: "p-" + Date.now(),
        name: "Seite " + (nb.pages.length + 1),
        template: template || templateSelect.value || "blank",
        strokes: []
      };
      nb.pages.push(page);
      data.activePageId = page.id;
      undoStack = [];
      redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function setPageTemplate(template) {
      const page = getActivePage();
      if (!page) return;
      page.template = template;
      redrawActivePage();
      saveData();
    }

    function deletePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      if (nb.pages.length <= 1) {
        alert("Du kannst die letzte Seite nicht lÃ¶schen.");
        return;
      }
      if (!confirm("Diese Seite wirklich lÃ¶schen?")) return;
      const idx = nb.pages.findIndex(p => p.id === pageId);
      nb.pages.splice(idx, 1);
      if (data.activePageId === pageId) {
        data.activePageId = nb.pages[Math.max(0, idx - 1)].id;
      }
      undoStack = []; redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function renamePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = nb.pages.find(p => p.id === pageId);
      if (!page) return;
      const name = prompt("Seitenname:", page.name);
      if (!name || name.trim() === page.name) return;
      page.name = name.trim();
      renderPageList();
      saveData();
    }

    function duplicatePage(pageId) {
      const nb = getActiveNotebook();
      if (!nb) return;
      const page = nb.pages.find(p => p.id === pageId);
      if (!page) return;
      const copy = JSON.parse(JSON.stringify(page));
      copy.id = "p-" + Date.now();
      copy.name = page.name + " (Kopie)";
      const idx = nb.pages.findIndex(p => p.id === pageId);
      nb.pages.splice(idx + 1, 0, copy);
      data.activePageId = copy.id;
      undoStack = []; redoStack = [];
      renderPageList();
      redrawActivePage();
      saveData();
    }

    function deleteNotebook() {
      if (data.notebooks.length <= 1) {
        alert("Das letzte Notizbuch kann nicht gelÃ¶scht werden.");
        return;
      }
      const nb = getActiveNotebook();
      if (!nb) return;
      if (!confirm(`Notizbuch "${nb.name}" wirklich lÃ¶schen?\nAlle ${nb.pages.length} Seite(n) gehen verloren.`)) return;
      const idx = data.notebooks.findIndex(n => n.id === nb.id);
      data.notebooks.splice(idx, 1);
      data.activeNotebookId = data.notebooks[Math.max(0, idx - 1)].id;
      const newNb = getActiveNotebook();
      data.activePageId = newNb?.pages[0]?.id || null;
      undoStack = []; redoStack = [];
      renderNotebookSelect();
      renderPageList();
      redrawActivePage();
      updateNotebookNameDisplay();
      renderNotebookLibrary();
      showLibrary();
      saveData();
    }

    function renameNotebook() {
      const nb = getActiveNotebook();
      if (!nb) return;
      const name = prompt("Notizbuch umbenennen:", nb.name);
      if (!name || name.trim() === nb.name) return;
      nb.name = name.trim();
      renderNotebookSelect();
      saveData();
    }


    function resizeCanvas() {
  const container = document.getElementById("canvasContainer") || document.getElementById("canvasWrapper");
  const margin = 12;
  const w = container.clientWidth - margin * 2;
  const h = container.clientHeight - margin * 2;

  const aspect = 1 / 1.414; // A4-Querformat
  let cw = w, ch = w / aspect;
  if (ch > h) { ch = h; cw = h * aspect; }
  cw = Math.max(200, Math.round(cw));
  ch = Math.max(200, Math.round(ch));

  const page = getActivePage();
  const oldStrokes = page ? JSON.parse(JSON.stringify(page.strokes)) : null;
  const tmpl = page ? page.template : "blank";

  canvas.width = cw;
  canvas.height = ch;

  // Zoom & Pan beim Resize zurÃ¼cksetzen
  zoom = 1; panX = 0; panY = 0;
  updateCanvasTransform();

  if (page && oldStrokes) {
    page.strokes = oldStrokes;
    page.template = tmpl;
  }
  redrawActivePage();
}


    window.addEventListener("resize", resizeCanvas);

function getTemplateSpacing() {
  const base = 32; // deine bisherige StandardgrÃ¶ÃŸe

  switch (data.templateScale) {
    case "small":
      return base * 0.6;   // ca. 19 px â€“ fein wie GoodNotes
    case "large":
      return base * 1.3;   // ca. 42 px â€“ groÃŸe KÃ¤stchen
    case "medium":
    default:
      return base;         // Standard
  }
}


    function drawTemplate(template) {
  const w = canvas.width, h = canvas.height;
  const spacing = getTemplateSpacing();    // ğŸ‘ˆ NEU

  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = "#7a7a7a";
  ctx.lineWidth = 1;

  if (template === "lined") {
    const lineSpacing = spacing;
    for (let y = lineSpacing; y < h; y += lineSpacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }

  } else if (template === "dotted") {
    for (let y = spacing; y < h; y += spacing) {
      for (let x = spacing; x < w; x += spacing) {
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fillStyle = "#7a7a7a";
        ctx.fill();
      }
    }

  } else if (template === "grid") {
    for (let y = spacing; y < h; y += spacing) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(w, y + 0.5);
      ctx.stroke();
    }
    for (let x = spacing; x < w; x += spacing) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, h);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// Zeichnet das Seitenraster als CSS-Hintergrund des Canvas.
// CSS-HintergrÃ¼nde skalieren vektorbasiert â†’ kein UnschÃ¤rfen beim Zoomen.
function updateTemplateBackground(template) {
  const s = getTemplateSpacing();
  const c = "rgba(122,122,122,0.15)";
  canvas.style.backgroundRepeat = "repeat";
  canvas.style.backgroundSize  = "auto";

  if (template === "lined") {
    canvas.style.backgroundImage =
      `repeating-linear-gradient(to bottom, transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px)`;

  } else if (template === "grid") {
    canvas.style.backgroundImage =
      `repeating-linear-gradient(to bottom, transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px),` +
      `repeating-linear-gradient(to right,  transparent 0px, transparent ${s - 1}px, ${c} ${s - 1}px, ${c} ${s}px)`;

  } else if (template === "dotted") {
    const half = s / 2;
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${s}' height='${s}'>`
               + `<circle cx='${half}' cy='${half}' r='1.5' fill='rgba(122,122,122,0.6)'/></svg>`;
    canvas.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}")`;
    canvas.style.backgroundSize  = `${s}px ${s}px`;

  } else {
    canvas.style.backgroundImage = "none";
  }
}

function redrawActivePage() {
  const page = getActivePage();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!page) { updateTemplateBackground("blank"); return; }

  // 1. Erst alle Strokes zeichnen (Stift, Marker, Radierer)
  page.strokes.forEach(stroke => {
    ctx.save();

    if (stroke.tool === "eraser") {
      // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    } else if (stroke.tool === "highlighter") {
      // Halbtransparent wie echter Textmarker
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 0.35; // Transparent
    } else {
      // Normaler Stift
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.globalAlpha = 1;
    }

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const pts = stroke.points;
    if (pts.length > 1) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x * canvas.width, pts[0].y * canvas.height);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x * canvas.width, pts[i].y * canvas.height);
      }
      ctx.stroke();
    }

    ctx.restore();
  });

  // Reset
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  // 2. Template als scharfes CSS-Hintergrundmuster (bleibt beim Zoomen scharf)
  updateTemplateBackground(page.template || "blank");
}

function previewShape(endPos) {
  // Wenn wir keine Startposition haben, kÃ¶nnen wir nichts anzeigen
  if (!shapeStartPos) return;

  const start = shapeStartPos;
  const end = endPos;

  // Erst die Seite normal zeichnen
  redrawActivePage();

  ctx.save();

  // Zeichenstil fÃ¼r die Vorschau
  ctx.globalCompositeOperation = "source-over";
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentWidth;
  ctx.globalAlpha = 1;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  // Optional: gestrichelt, damit man sieht: das ist nur Vorschau
  ctx.setLineDash([6, 4]);

  const sx = start.x * canvas.width;
  const sy = start.y * canvas.height;
  const ex = end.x * canvas.width;
  const ey = end.y * canvas.height;

  if (currentTool === "line") {
    // Gerade Linie
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

  } else if (currentTool === "rect") {
    // Rechteck aus zwei Eckpunkten
    const x = Math.min(sx, ex);
    const y = Math.min(sy, ey);
    const w = Math.abs(ex - sx);
    const h = Math.abs(ey - sy);

    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.stroke();

  } else if (currentTool === "circle") {
    // Ellipse/Kreis
    const cx = (sx + ex) / 2;
    const cy = (sy + ey) / 2;
    const rx = Math.abs(ex - sx) / 2;
    const ry = Math.abs(ey - sy) / 2;

    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
    ctx.stroke();
  }

  ctx.restore();
}


   function normPos(evt) {
         const rect = canvas.getBoundingClientRect();
         let clientX, clientY;

  if (evt.touches && evt.touches.length > 0) {
          clientX = evt.touches[0].clientX;
          clientY = evt.touches[0].clientY;
  } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
  }

  const x = (clientX - rect.left) / rect.width;
  const y = (clientY - rect.top) / rect.height;
  return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
}

// Abstand zwischen zwei Fingern
// Abstand zwischen zwei Fingern
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.hypot(dx, dy);
}

// Mittelpunkt der zwei Finger
function getTouchCenter(touches) {
  return {
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  };
}

// Gibt true zurÃ¼ck wenn der Touch ein Apple Pencil (Stylus) ist.
// Nutzt Safari-spezifisches Touch.touchType â€“ auf anderen Browsern immer false.
function isStylusTouch(touch) {
  return typeof touch.touchType !== "undefined" && touch.touchType === "stylus";
}

// Entscheidet: Zeichnen oder Scrollen fÃ¼r einen einzelnen Touch.
// Auf Safari: Stylus â†’ zeichnen, Finger â†’ scrollen (unabhÃ¤ngig von touchMode-Button).
// Auf anderen Browsern: Fallback auf touchMode-Variable.
function shouldDrawTouch(touch) {
  if (typeof touch.touchType !== "undefined") {
    return touch.touchType === "stylus";
  }
  return touchMode === "draw";
}

function handleTouchStart(e) {
  if (!e.touches || e.touches.length === 0) return;
  e.preventDefault();

  if (e.touches.length === 1) {
    isPinching = false;
    if (shouldDrawTouch(e.touches[0])) {
      startDrawing(e);
    } else {
      // Finger-Touch â†’ Canvas verschieben
      panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  } else if (e.touches.length === 2) {
    // 2 Finger = Pinch-Zoom & Pan
    isPinching = true;
    if (drawing) { drawing = false; currentStroke = null; } // Zeichnen abbrechen
    lastPinchDist = getTouchDistance(e.touches);
    lastPinchCenter = getTouchCenter(e.touches);
  }
}

function handleTouchMove(e) {
  if (!e.touches || e.touches.length === 0) return;

  if (isPinching && e.touches.length === 2) {
    e.preventDefault();
    const newDist = getTouchDistance(e.touches);
    const newCenter = getTouchCenter(e.touches);

    if (lastPinchDist > 0 && lastPinchCenter) {
      const scaleChange = newDist / lastPinchDist;
      const oldZoom = zoom;
      zoom = Math.max(0.4, Math.min(5, zoom * scaleChange));

      // Canvas-Mittelpunkt in Bildschirmkoordinaten
      const rect = canvas.getBoundingClientRect();
      const screenCX = rect.left + rect.width / 2;
      const screenCY = rect.top + rect.height / 2;

      // Pan so anpassen, dass der Pinch-Punkt bleibt
      panX += (lastPinchCenter.x - screenCX) * (1 - zoom / oldZoom);
      panY += (lastPinchCenter.y - screenCY) * (1 - zoom / oldZoom);

      // Finger-Bewegung als Pan Ã¼bernehmen
      panX += newCenter.x - lastPinchCenter.x;
      panY += newCenter.y - lastPinchCenter.y;
    }

    lastPinchDist = newDist;
    lastPinchCenter = newCenter;
    updateCanvasTransform();

  } else if (!isPinching && e.touches.length === 1) {
    if (shouldDrawTouch(e.touches[0])) {
      moveDrawing(e);
    } else {
      // Finger-Touch Pan
      e.preventDefault();
      if (panStart) {
        panX += e.touches[0].clientX - panStart.x;
        panY += e.touches[0].clientY - panStart.y;
        panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        updateCanvasTransform();
      }
    }
  }
}

function handleTouchEnd(e) {
  if (isPinching && (!e.touches || e.touches.length < 2)) {
    isPinching = false;
    lastPinchDist = 0;
    lastPinchCenter = null;
  }
  if (!e.touches || e.touches.length === 0) {
    panStart = null;
    stopDrawing(e);
  }
}

    function startDrawing(evt) {
  evt.preventDefault();
  const page = getActivePage();
  if (!page) return;

  drawing = true;
  redoStack = [];

  const p = normPos(evt);
  lastPos = p;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // Formen: Startpunkt merken, Stroke nur als â€Platzhalterâ€œ
    shapeStartPos = p;
    currentStroke = {
      tool: "pen",
      color: currentColor,
      width: currentWidth,
      alpha: 1,
      points: [p]
    };
  } else {
    // Freihand-Stift / Marker / Radierer
    const stroke = {
      tool: currentTool,
      color: currentColor,
      // Marker bewusst dicker, wirkt mehr wie echter Textmarker
      width: currentTool === "highlighter" ? currentWidth * 4 : currentWidth,
      alpha: 1,
      points: [p]
    };

    if (currentTool === "eraser") {
      stroke.color = "#000000";
    }

    currentStroke = stroke;
    drawStrokeSegment(lastPos, p, stroke);
  }
}

function drawStrokeSegment(from, to, stroke) {
  ctx.save();

  if (stroke.tool === "eraser") {
    // Radiert nur gezeichnete Sachen, Template bleibt, weil das danach kommt
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  } else if (stroke.tool === "highlighter") {
    // Halbtransparent wie echter Textmarker
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 0.35; // Transparent
  } else {
    // Normaler Stift
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.globalAlpha = 1;
  }

  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  ctx.beginPath();
  ctx.moveTo(from.x * canvas.width, from.y * canvas.height);
  ctx.lineTo(to.x * canvas.width, to.y * canvas.height);
  ctx.stroke();

  ctx.restore();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}


function moveDrawing(evt) {
  if (!drawing || !currentStroke) return;
  evt.preventDefault();

  const raw = normPos(evt);

  // FÃ¼r Linien/Rechteck/Kreis keine GlÃ¤ttung, nur Vorschau
  if (["line", "rect", "circle"].includes(currentTool)) {
    previewShape(raw);
    lastPos = raw;
    return;
  }

  // GlÃ¤ttung: Mischung aus alter und neuer Position (fÃ¼hlt sich noch direkt an)
  const p = {
    x: lastPos.x * 0.35 + raw.x * 0.65,
    y: lastPos.y * 0.35 + raw.y * 0.65
  };

  // Winzige Bewegungen ignorieren â†’ weniger Zittern
  const dx = p.x - lastPos.x;
  const dy = p.y - lastPos.y;
  const dist2 = dx * dx + dy * dy;
  if (dist2 < 0.000004) {
    return;
  }

  drawStrokeSegment(lastPos, p, currentStroke);
  currentStroke.points.push(p);
  lastPos = p;
}

function stopDrawing(evt) {
  if (!drawing) return;
  drawing = false;

  const page = getActivePage();
  if (!page || !currentStroke) return;

  if (["line", "rect", "circle"].includes(currentTool)) {
    // finale Form als Punkte approximieren
    const start = shapeStartPos;
    const end = lastPos;
    let points = [];

    if (currentTool === "line") {
      points = [start, end];
    } else if (currentTool === "rect") {
      const xs = [start.x, end.x].sort((a, b) => a - b);
      const ys = [start.y, end.y].sort((a, b) => a - b);
      const xL = xs[0], xR = xs[1], yT = ys[0], yB = ys[1];
      points = [
        { x: xL, y: yT },
        { x: xR, y: yT },
        { x: xR, y: yB },
        { x: xL, y: yB },
        { x: xL, y: yT }
      ];
    } else if (currentTool === "circle") {
      const steps = 40;
      const cx = (start.x + end.x) / 2;
      const cy = (start.y + end.y) / 2;
      const rx = Math.abs(end.x - start.x) / 2;
      const ry = Math.abs(end.y - start.y) / 2;
      points = [];
      for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * 2 * Math.PI;
        points.push({
          x: cx + rx * Math.cos(t),
          y: cy + ry * Math.sin(t)
        });
      }
    }

    currentStroke.points = points;
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    shapeStartPos = null;
    redrawActivePage();
  } else {
    // Freihand-Stift / Marker / Radierer
    if (currentStroke.points.length < 2) {
      currentStroke.points.push({ ...currentStroke.points[0] });
    }
    page.strokes.push(currentStroke);
    undoStack.push(currentStroke);
    // Nach jedem Freihand-Strich alles neu zeichnen
    redrawActivePage();
  }

  currentStroke = null;
  saveData();
}



    function doUndo() {
      const page = getActivePage();
      if (!page || page.strokes.length === 0) return;
      const stroke = page.strokes.pop();
      redoStack.push(stroke);
      undoStack.pop();
      redrawActivePage();
      saveData();
    }

    function doRedo() {
      const page = getActivePage();
      if (!page || redoStack.length === 0) return;
      const stroke = redoStack.pop();
      page.strokes.push(stroke);
      undoStack.push(stroke);
      redrawActivePage();
      saveData();
    }

    function clearPage() {
      const page = getActivePage();
      if (!page) return;
      if (!confirm("Diese Seite wirklich komplett leeren?")) return;
      page.strokes = [];
      undoStack = [];
      redoStack = [];
      redrawActivePage();
      saveData();
    }

    function exportPageAsPNG() {
      const page = getActivePage();
      if (!page) return;
      const link = document.createElement("a");
      link.href = canvas.toDataURL("image/png");
      link.download = (page.name || "Seite") + ".png";
      link.click();
    }

    // Canvas Events (Maus)
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", moveDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseleave", stopDrawing);


// Canvas Events (Touch â€“ 1 Finger = zeichnen, 2 Finger = Pinch-Zoom)
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove",  handleTouchMove,  { passive: false });
canvas.addEventListener("touchend",   handleTouchEnd,   { passive: false });
canvas.addEventListener("touchcancel",handleTouchEnd,   { passive: false });




    toolButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        toolButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentTool = btn.getAttribute("data-tool");
      });
    });

    colorPicker.addEventListener("input", () => {
      currentColor = colorPicker.value;
    });

    strokeButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        strokeButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentWidth = parseInt(btn.getAttribute("data-width"), 10);
      });
    });

    undoBtn.addEventListener("click", doUndo);
    redoBtn.addEventListener("click", doRedo);
    clearBtn.addEventListener("click", clearPage);
    addNotebookBtn.addEventListener("click", addNotebook);
    notebookSelect.addEventListener("change", e => switchNotebook(e.target.value));
    addPageBtn.addEventListener("click", showPageTemplatePicker);
    templateSelect.addEventListener("change", e => setPageTemplate(e.target.value));
    exportPageBtn.addEventListener("click", exportPageAsPNG);

    // Notebook lÃ¶schen
    const deleteNotebookBtn = document.getElementById("deleteNotebookBtn");
    if (deleteNotebookBtn) deleteNotebookBtn.addEventListener("click", deleteNotebook);

    // Bibliothek: ZurÃ¼ck-Button
    const backToLibraryBtn = document.getElementById("backToLibraryBtn");
    if (backToLibraryBtn) backToLibraryBtn.addEventListener("click", () => {
      renderNotebookLibrary();
      showLibrary();
    });

    // Create-Modal: Abbrechen / Erstellen
    const nbCancelBtn = document.getElementById("nbCancelBtn");
    if (nbCancelBtn) nbCancelBtn.addEventListener("click", hideNbCreateModal);
    const nbConfirmBtn = document.getElementById("nbConfirmBtn");
    if (nbConfirmBtn) nbConfirmBtn.addEventListener("click", confirmCreateNotebook);

    // Sidebar Toggle
    const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
    if (sidebarToggleBtn) {
      sidebarToggleBtn.addEventListener("click", () => {
        const collapsed = sidebarNotes.classList.toggle("collapsed");
        sidebarToggleBtn.textContent = collapsed ? "â–¶" : "â—€";
        sidebarToggleBtn.style.left = collapsed ? "0" : "0";
        setTimeout(resizeCanvas, 250); // Canvas nach Animation neu berechnen
      });
    }

    // Zoom-Buttons
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const zoomResetBtn = document.getElementById("zoomResetBtn");
    if (zoomInBtn) zoomInBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomToPoint(rect.left + rect.width/2, rect.top + rect.height/2, 1.3);
    });
    if (zoomOutBtn) zoomOutBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomToPoint(rect.left + rect.width/2, rect.top + rect.height/2, 1/1.3);
    });
    if (zoomResetBtn) zoomResetBtn.addEventListener("click", resetZoom);

    // Touch-Modus Toggle (Zeichnen â†” Scrollen)
    const touchModeBtn = document.getElementById("touchModeBtn");
    if (touchModeBtn) {
      touchModeBtn.addEventListener("click", () => {
        touchMode = touchMode === "draw" ? "scroll" : "draw";
        touchModeBtn.textContent = touchMode === "draw" ? "âœï¸" : "ğŸ‘†";
        touchModeBtn.classList.toggle("scroll-mode", touchMode === "scroll");
        touchModeBtn.title = touchMode === "draw" ? "Touch-Modus: Zeichnen (klicken fÃ¼r Scrollen)" : "Touch-Modus: Scrollen (klicken fÃ¼r Zeichnen)";
      });
    }

    // Scroll-Zoom mit Mausrad (Desktop/Magic Trackpad)
    const canvasContainer = document.getElementById("canvasContainer");
    if (canvasContainer) {
      canvasContainer.addEventListener("wheel", e => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
        zoomToPoint(e.clientX, e.clientY, factor);
      }, { passive: false });
    }

    // TastaturkÃ¼rzel
    document.addEventListener("keydown", e => {
      if (e.target !== document.body && e.target.tagName !== "CANVAS") return;
      if ((e.ctrlKey || e.metaKey) && e.key === "z") { e.preventDefault(); doUndo(); }
      if ((e.ctrlKey || e.metaKey) && (e.key === "y" || (e.shiftKey && e.key === "z"))) { e.preventDefault(); doRedo(); }
      if ((e.ctrlKey || e.metaKey) && e.key === "0") { e.preventDefault(); resetZoom(); }
      if ((e.ctrlKey || e.metaKey) && e.key === "=") { e.preventDefault(); zoomToPoint(window.innerWidth/2, window.innerHeight/2, 1.3); }
      if ((e.ctrlKey || e.metaKey) && e.key === "-") { e.preventDefault(); zoomToPoint(window.innerWidth/2, window.innerHeight/2, 1/1.3); }
    });

    // RastergrÃ¶ÃŸe Ã¤ndern
if (templateSizeSelect) {
  // Beim Start auf gespeicherten Wert setzen
  templateSizeSelect.value = data.templateScale || "medium";

  templateSizeSelect.addEventListener("change", (e) => {
    data.templateScale = e.target.value;  // "small" | "medium" | "large"
    saveData();
    redrawActivePage();                   // Canvas neu zeichnen mit neuer GrÃ¶ÃŸe
  });
}


    // Backup
    exportJsonBtn.addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "uni-hyper-notes-backup.json";
      a.click();
      URL.revokeObjectURL(url);
    });
// Backup laden (Import)
importJsonBtn.addEventListener("click", () => {
  importJsonInput.value = "";      // evtl. alte Auswahl zurÃ¼cksetzen
  importJsonInput.click();         // Datei-Dialog Ã¶ffnen
});

importJsonInput.addEventListener("change", () => {
  const file = importJsonInput.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);

      // Ganz grobe PlausibilitÃ¤tsprÃ¼fung
      if (!imported || !Array.isArray(imported.notebooks)) {
        alert("Diese Datei sieht nicht wie ein Uni-Hyper-Notes-Backup aus.");
        return;
      }

      // Unsere globale data ersetzen
      data = imported;

      // Sicherheitshalber: falls alte Backups ein paar Felder nicht hatten
      if (!data.cards) data.cards = { decks: [] };
      if (!data.planner) data.planner = { exams: [], focusSessions: [] };
      if (!data.formulas) data.formulas = [];
      if (!data.tasks) data.tasks = [];
      if (!data.brain) data.brain = { entries: [] };
      if (!data.theme) data.theme = "dark";

      // Aktive IDs setzen, falls fehlen
      if (!data.activeNotebookId && data.notebooks[0]) {
        data.activeNotebookId = data.notebooks[0].id;
      }
      const nb = data.notebooks.find(nb => nb.id === data.activeNotebookId) || data.notebooks[0];
      if (nb && !data.activePageId && nb.pages[0]) {
        data.activePageId = nb.pages[0].id;
      }

      // In localStorage speichern
      saveData();

      // UI komplett neu aufbauen
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      ensureNotebookMeta();
      renderNotebookLibrary();
      updateNotebookNameDisplay();
      // renderDecks() - handled by Karteikarten2 separately
      // renderExams() â€“ moved to Planner.html iframe
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();

      alert("Backup wurde erfolgreich geladen âœ…");

    } catch (err) {
      console.error(err);
      alert("Fehler beim Laden des Backups. Bist du sicher, dass es die richtige Datei ist?");
    }
  };

  reader.readAsText(file, "utf-8");
});

    // ---------- KARTEIKARTEN (old - replaced by Karteikarten2) ----------
    /* OLD CARDS CODE REMOVED */

    // ---------- PLANER ----------
    // Planner is now a separate Planner.html loaded via iframe â€“ no JS needed here.

    // ---------- FORMELN ----------
    // â†’ ausgelagert in formeln/index.html (iframe)
    function renderFormulas() {} // Stub â€“ wird nicht mehr gebraucht

    // ---------- TOOLS / RECHENTOOL ----------
    const toolFormulaSelect = document.getElementById("toolFormulaSelect");
    const toolInputs = document.getElementById("toolInputs");
    const toolCalcBtn = document.getElementById("toolCalcBtn");
    const toolResult = document.getElementById("toolResult");

    function renderToolInputs() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="dil_c1" placeholder="câ‚ (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="dil_v1" placeholder="Vâ‚"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="dil_c2" placeholder="câ‚‚"></div>
            <div><input type="number" step="any" id="dil_v2" placeholder="Vâ‚‚"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Hinweis: Eine der GrÃ¶ÃŸen (câ‚, Vâ‚, câ‚‚ oder Vâ‚‚) leer lassen, dann wird sie berechnet. Einheiten mÃ¼ssen zueinander passen.</div>
        `;
      } else if (mode === "lambert") {
        toolInputs.innerHTML = `
          <div class="row">
            <div><input type="number" step="any" id="lam_A" placeholder="A (Absorption)"></div>
            <div><input type="number" step="any" id="lam_eps" placeholder="Îµ (z.B. LÂ·molâ»Â¹Â·cmâ»Â¹)"></div>
          </div>
          <div class="row" style="margin-top:4px;">
            <div><input type="number" step="any" id="lam_c" placeholder="c [mol/L] (leer lassen, wenn gesucht)"></div>
            <div><input type="number" step="any" id="lam_l" placeholder="l [cm]"></div>
          </div>
          <div style="font-size:11px; opacity:0.8; margin-top:4px;">Lambert-Beer: A = Îµ Â· c Â· l. Eine der GrÃ¶ÃŸen (meist c) leer lassen, dann wird sie berechnet.</div>
        `;
      }
    }

    function calcTool() {
      const mode = toolFormulaSelect.value;
      toolResult.textContent = "";
      if (mode === "dilution") {
        const c1 = parseFloat(document.getElementById("dil_c1").value);
        const v1 = parseFloat(document.getElementById("dil_v1").value);
        const c2 = parseFloat(document.getElementById("dil_c2").value);
        const v2 = parseFloat(document.getElementById("dil_v2").value);

        const vals = { c1, v1, c2, v2 };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE GrÃ¶ÃŸe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "c1") result = c2 * v2 / v1;
          else if (missing === "v1") result = c2 * v2 / c1;
          else if (missing === "c2") result = c1 * v1 / v2;
          else if (missing === "v2") result = c1 * v1 / c2;
        } catch {
          toolResult.textContent = "Rechenfehler â€“ bitte Eingaben prÃ¼fen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      } else if (mode === "lambert") {
        const A = parseFloat(document.getElementById("lam_A").value);
        const eps = parseFloat(document.getElementById("lam_eps").value);
        const c = parseFloat(document.getElementById("lam_c").value);
        const l = parseFloat(document.getElementById("lam_l").value);

        const vals = { A, eps, c, l };
        const empty = Object.entries(vals).filter(([k,v]) => isNaN(v));
        if (empty.length !== 1) {
          toolResult.textContent = "Bitte genau EINE GrÃ¶ÃŸe leer lassen.";
          return;
        }
        const missing = empty[0][0];
        let result;
        try {
          if (missing === "A") result = eps * c * l;
          else if (missing === "eps") result = A / (c * l);
          else if (missing === "c") result = A / (eps * l);
          else if (missing === "l") result = A / (eps * c);
        } catch {
          toolResult.textContent = "Rechenfehler â€“ bitte Eingaben prÃ¼fen.";
          return;
        }
        toolResult.textContent = `Ergebnis: ${missing} = ${result}`;
      }
    }

    toolFormulaSelect.addEventListener("change", renderToolInputs);
    toolCalcBtn.addEventListener("click", calcTool);

    // ---------- AUFGABEN ----------
    const taskTitle = document.getElementById("taskTitle");
    const taskTopic = document.getElementById("taskTopic");
    const taskText = document.getElementById("taskText");
    const taskNotes = document.getElementById("taskNotes");
    const addTaskBtn = document.getElementById("addTaskBtn");
    const taskListDiv = document.getElementById("taskList");

    function renderTasks() {
      taskListDiv.innerHTML = "";
      data.tasks.forEach(t => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div><strong>${t.title}</strong></div>
            <div>
              <span class="pill">${t.topic || "-"}</span>
              <select data-id="${t.id}" class="taskStatusSel">
                <option value="open" ${t.status === "open" ? "selected" : ""}>unsicher</option>
                <option value="ok" ${t.status === "ok" ? "selected" : ""}>geht so</option>
                <option value="done" ${t.status === "done" ? "selected" : ""}>sicher</option>
              </select>
            </div>
          </div>
          <div style="margin-top:4px; font-size:13px; white-space:pre-wrap;">${t.text}</div>
          <div style="margin-top:4px; font-size:12px; opacity:0.8; white-space:pre-wrap;">${t.notes || ""}</div>`;
        taskListDiv.appendChild(div);
      });
      document.querySelectorAll(".taskStatusSel").forEach(sel => {
        sel.addEventListener("change", evt => {
          const id = evt.target.getAttribute("data-id");
          const task = data.tasks.find(tt => tt.id === id);
          if (!task) return;
          task.status = evt.target.value;
          saveData();
        });
      });
    }

    function addTask() {
      const title = taskTitle.value.trim();
      const text = taskText.value.trim();
      if (!title || !text) return;
      data.tasks.push({
        id: "task-" + Date.now(),
        title,
        topic: taskTopic.value.trim(),
        text,
        notes: taskNotes.value.trim(),
        status: "open"
      });
      taskTitle.value = "";
      taskTopic.value = "";
      taskText.value = "";
      taskNotes.value = "";
      saveData();
      renderTasks();
    }

    addTaskBtn.addEventListener("click", addTask);

    // ---------- BRAIN-DUMP ----------
    const brainText = document.getElementById("brainText");
    const saveBrainBtn = document.getElementById("saveBrainBtn");
    const brainStatus = document.getElementById("brainStatus");
    const brainHistory = document.getElementById("brainHistory");

    function renderBrainHistory() {
      brainHistory.innerHTML = "";
      const entries = data.brain.entries.slice().sort((a, b) => b.date - a.date);
      entries.forEach(e => {
        const div = document.createElement("div");
        div.className = "card";
        const d = new Date(e.date);
        div.innerHTML = `
          <div style="font-size:12px; opacity:0.7;">${d.toLocaleString()}</div>
          <div style="margin-top:4px; white-space:pre-wrap;">${e.text}</div>`;
        brainHistory.appendChild(div);
      });
    }

    function saveBrainEntry() {
      const text = brainText.value.trim();
      if (!text) return;
      data.brain.entries.push({ id: "brain-" + Date.now(), text, date: Date.now() });
      brainText.value = "";
      brainStatus.textContent = "Gespeichert.";
      setTimeout(() => (brainStatus.textContent = ""), 2000);
      saveData();
      renderBrainHistory();
    }

    saveBrainBtn.addEventListener("click", saveBrainEntry);

    // ---------- STATS ----------
    const statsContent = document.getElementById("statsContent");

    function renderStats() {
      const sessions = (data.planner && data.planner.focusSessions) ? data.planner.focusSessions : [];
      if (sessions.length === 0) {
        statsContent.textContent = "Fokus-Sessions werden jetzt im Planner-Tab erfasst.";
        return;
      }
      const totalMinutes = sessions.reduce((sum, s) => sum + (s.minutes || 0), 0);
      const byTopic = {};
      sessions.forEach(s => {
        const t = s.topic || "Sonstiges";
        byTopic[t] = (byTopic[t] || 0) + (s.minutes || 0);
      });
      let html = `<div>Gesamt-Lernzeit (nur Fokus-BlÃ¶cke): <strong>${totalMinutes} Minuten</strong></div>`;
      html += `<div style="margin-top:6px;">Verteilung nach Themen:</div>`;
      html += `<ul style="padding-left:16px; margin-top:4px;">`;
      Object.keys(byTopic).forEach(t => {
        html += `<li>${t}: ${byTopic[t]} Min</li>`;
      });
      html += `</ul>`;
      statsContent.innerHTML = html;
    }

    // ---------- INIT ----------
    window.addEventListener("load", () => {
      loadData();
      applyTheme();
      renderNotebookSelect();
      resizeCanvas();
      renderPageList();
      redrawActivePage();
      ensureNotebookMeta();
      renderNotebookLibrary();
      showLibrary();
      updateNotebookNameDisplay();
      // renderDecks() - handled by Karteikarten2
      // renderExams() â€“ moved to Planner.html iframe
      renderFormulas();
      renderTasks();
      renderBrainHistory();
      renderStats();
      renderToolInputs();
      syncFromCloud();
     });

       // --- Sync-Button: Sync-ID speichern + aus Cloud laden ---
if (syncSaveBtn && syncIdInput) {
     syncSaveBtn.addEventListener("click", () => {
      const entered = syncIdInput.value.trim();
    if (!entered) {
      alert("Bitte eine Sync-ID eingeben.");
      return;
    }

        syncId = entered;
    localStorage.setItem("uniHyperNotes_syncId", syncId);
    updateSyncStatus("Sync-ID gespeichert: " + syncId);

    // Beim Klick auch gleich aus der Cloud laden
    syncFromCloud();
  });
}
</script>   <!-- Ende des groÃŸen Haupt-Scripts -->

<script id="notebook-system">
           // HIER BAUT CODEX die Notebook- und FÃ¤cherlogik ein
</script>



<script id="flashcards-system">
// ---------- AminosÃ¤ure-Karteikarten â€“ Grundsystem ----------

// 1. Daten zu den AminosÃ¤uren
const aminoCards = [
  {
    id: "gly",
    name: "Glycin",
    three: "Gly",
    one: "G",
    category: "klein, unpolar",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” H
  |
 COOH`
  },
  {
    id: "ala",
    name: "Alanin",
    three: "Ala",
    one: "A",
    category: "klein, unpolar (CHâ‚ƒ-Seitenkette)",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” CHâ‚ƒ
  |
 COOH`
  },
  {
    id: "ser",
    name: "Serin",
    three: "Ser",
    one: "S",
    category: "polar, ungeladen (CHâ‚‚OH-Seitenkette)",
    structure: `
  H
  |
Hâ‚‚N â€” C â€” CHâ‚‚OH
  |
 COOH`
  },
  // ğŸ‘‰ hier spÃ¤ter die restlichen 17 eintragen

{
  id: "val",
  name: "Valin",
  three: "Val",
  one: "V",
  category: "unpolar, verzweigte Seitenkette",
  structure: `
  H
  |
       Hâ‚‚N â€” C â€” CH(CHâ‚ƒ)â‚‚
  |
 COOH`
},

{
  id: "thr",
  name: "Threonin",
  three: "Thr",
  one: "T",
  category: "polar, ungeladen (CH(OH)CHâ‚ƒ-Seitenkette)",
  structure: `
 OH
 |
   H â€” C â€” CHâ‚ƒ
 |
 âºHâ‚ƒN â€” C â€” COOâ»
 |
 H
`
},

{
  id: "cys",
  name: "Cystein",
  three: "Cys",
  one: "C",
  category: "polar, ungeladen (CHâ‚‚SH-Seitenkette)",
  structure: `
H
|
    âºHâ‚ƒN â€” C â€” CHâ‚‚ â€” SH
|
COOH`
},

{
  id: "met",
  name: "Methionin",
  three: "Met",
  one: "M",
  category: "unpolar (SCHâ‚ƒ-Seitenkette)",
  structure: `
H
|
               âºHâ‚ƒN â€” C â€” CHâ‚‚ â€” CHâ‚‚ â€” S â€” CHâ‚ƒ
|
COO`
},

{
  id: "pro",
  name: "Prolin",
  three: "Pro",
  one: "P",
  category: "unpolar (pyrrolidin-Ring)",
  structure: `

          CH2
        /     \\
       H2C        CH2
         \\        /
                H2N+ â€” C â€” COO-
                |
                H

`
},

{
  id: "phe",
  name: "Phenylalanin",
  three: "Phe",
  one: "F",
  category: "aromatisch, unpolar (Câ‚†Hâ‚…-Seitenkette)",
  structure: `

        H
        |
  H3N+ â€” C â€” H
        |
       CH2
        |
      /  \\
      /    \\
      \\     /
      \\ _ /
  `
},

{
  id: "tyr",
  name: "Tyrosin",
  three: "Tyr",
  one: "Y",
  category: "aromatisch, polar (Câ‚†Hâ‚„OH-Seitenkette)",
  structure: `
        H
        |
  H3N+ â€” C â€” H
        |
       CH2
        |
       / \\
       |   |
       |   |
       \\  /
        |
       HO
  `
},

{
  id: "trp",
  name: "Tryptophan",
  three: "Trp",
  one: "W",
  category: "aromatisch, unpolar (Indol-Ring)",
  structure: `
           H
           |
H3N+ â€” C â€” C â€” COO-
           |
          CH2
           |
        / \\ / \\ 
         |       |HN
       |       |
        \\ / \\ /
  `
},

{
  id: "asn",
  name: "Asparagin",
  three: "Asn",
  one: "N",
  category: "polar, ungeladen (CONHâ‚‚-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
          // \\
            O   NH2
  `
},

{
  id: "gln",
  name: "Glutamin",
  three: "Gln",
  one: "Q",
  category: "polar, ungeladen (CHâ‚‚CHâ‚‚CONHâ‚‚-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
           C
          // \\
            O   NH2
  `
},



{
  id: "lys",
  name: "Lysin",
  three: "Lys",
  one: "K",
  category: "basisch, positiv geladen (CHâ‚‚)â‚„NHâ‚ƒâº-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
          CH2
           |
          CH2
           |
          NH3+
`
},

{
  id: "arg",
  name: "Arginin",
  three: "Arg",
  one: "R",
  category: "basisch, positiv geladen (Guanidinium-Gruppe)",
  structure: `

           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
          CH2
           |
          NH
           |
           C
           /   \\

            H2N  +   NH2

`
},

{
  id: "his",
  name: "Histidin",
  three: "His",
  one: "H",
  category: "basisch, positiv geladen (Imidazol-Seitenkette)",
  structure: `

           H
           |
         H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
         /        \\
         N        CH
         \\        /
        HC â€” HN
  `

},

{
  id: "ile",
  name: "Isoleucin",
  three: "Ile",
  one: "I",
  category: "unpolar, verzweigt (CH(CHâ‚ƒ)CHâ‚‚CHâ‚ƒ-Seitenkette)",
  structure: `
 H   H
 |   |
   âºHâ‚ƒN â€” C â€” Câ€”CHâ‚‚â€” CHâ‚ƒ
 |   |
 COOH  CHâ‚ƒ

`
},

{
  id: "leu",
  name: "Leucin",
  three: "Leu",
  one: "L",
  category: "unpolar, verzweigt (CHâ‚‚CH(CHâ‚ƒ)â‚‚-Seitenkette)",
  structure: `
  H        H
  |        |
 âºHâ‚ƒN â€” C â€” CHâ‚‚â€” C â€” CHâ‚ƒ
  |        |
  COOâ»      CHâ‚ƒ
    `

},

{
    id: "glu",
    name: "Glutamat",
    three: "Glu",
    one: "E",
    category: "sauer, negativ geladen (COOâ»-Seitenkette)",
    structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
          CH2
           |
           C
           /   \\

            O  -   O

`
},

{
  id: "asp",
  name: "AsparaginsÃ¤ure",
  three: "Asp",
  one: "D",
  category: "negativ geladen (sauer, Carboxylat-Seitenkette)",
  structure: `
           H
           |
           H3N+ â€” C â€” COO-
           |
          CH2
           |
           C
           /   \\

            O  -   O
  `
},


];


// 2. Zustand (welche Karte + Vorder-/RÃ¼ckseite)
let currentAminoIndex = 0;
let showBack = false;

// 3. Karte rendern
function renderAminoCard() {
  const container = document.getElementById("flashcardPreview");
  if (!container || aminoCards.length === 0) return;

  const card = aminoCards[currentAminoIndex];

  let content;
  if (!showBack) {
    // Vorderseite: Infos & Aufgabe
    content =
`Name: ${card.name} (${card.three}, ${card.one})
Eigenschaft: ${card.category}

âœï¸ Aufgabe: Zeichne die vollstÃ¤ndige Strukturformel.`;
  } else {
    // RÃ¼ckseite: Struktur in voller Schreibweise
    content = card.structure;
  }

  container.innerHTML = `
    <div class="amino-pretty">
${content}
    </div>
  `;
}

// 4. Buttons verdrahten
function initAminoFlashcards() {
  const flipBtn = document.getElementById("aminoFlipBtn");
  const nextBtn = document.getElementById("aminoNextBtn");
  const randomBtn = document.getElementById("aminoRandomBtn");

  if (flipBtn) {
    flipBtn.addEventListener("click", () => {
      showBack = !showBack;
      renderAminoCard();
    });
  }

  if (nextBtn) {
    nextBtn.addEventListener("click", () => {
      currentAminoIndex = (currentAminoIndex + 1) % aminoCards.length;
      showBack = false; // immer wieder mit Frage anfangen
      renderAminoCard();
    });
  }

  if (randomBtn) {
    randomBtn.addEventListener("click", () => {
      currentAminoIndex = Math.floor(Math.random() * aminoCards.length);
      showBack = false;
      renderAminoCard();
    });
  }

  // erste Karte anzeigen
  renderAminoCard();
}

// 5. Starten, sobald das Skript geladen ist
initAminoFlashcards();


/* ===== Wachstums-Simulation Tool ===== */

(function () {
document.addEventListener("DOMContentLoaded", () => {

  const $ = (id) => document.getElementById(id);

  const els = {
    N0: $("bioN0"), R0: $("bioR0"), K0: $("bioK0"),
    nutr: $("bioNutr"), temp: $("bioTemp"), ph: $("bioPH"),
    tmax: $("bioTmax"), dt: $("bioDt"),
    N0Val: $("bioN0Val"), R0Val: $("bioR0Val"), K0Val: $("bioK0Val"),
    nutrVal: $("bioNutrVal"), tempVal: $("bioTempVal"), phVal: $("bioPHVal"),
    tmaxVal: $("bioTmaxVal"), dtVal: $("bioDtVal"),
    runBtn: $("bioRunBtn"), addBtn: $("bioAddBtn"), clearBtn: $("bioClearBtn"), exportPlotBtn: $("bioExportPlotBtn"),exportCsvBtn: $("bioExportCsvBtn"),
    exportJsonBtn: $("bioExportJsonBtn"),

    info: $("bioInfo"),
    canvas: $("bioCanvas"),

    stressThr: $("bioStressThr"),
    deathMax: $("bioDeathMax"),
    stressThrVal: $("bioStressThrVal"),
    deathMaxVal: $("bioDeathMaxVal"),

    presetOptimal: $("bioPresetOptimal"),
    presetCold: $("bioPresetCold"),
    presetPHStress: $("bioPresetPHStress"),
    presetLowNutr: $("bioPresetLowNutr"),

    axisLockBtn: $("bioAxisLockBtn"),
    axisAutoBtn: $("bioAxisAutoBtn"),
    axisStatus: $("bioAxisStatus"),

  advancedToggle: $("bioAdvancedToggle"),
  integrator: $("bioIntegrator"),
  integratorWrap: $("bioIntegratorWrap")



  };

  if (!els.canvas) return; // falls Card nicht drin ist

  const ctx = els.canvas.getContext("2d");
  const runs = [];

  function formatK(n) {
    if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
    if (n >= 1e3) return (n/1e3).toFixed(2) + "k";
    return String(Math.round(n));
  }

const axisLock = {
  locked: false,
  maxT: null,
  maxN: null
};


function updateAdvancedUI() {
  const on = !!els.advancedToggle?.checked;
  if (els.integratorWrap) els.integratorWrap.style.display = on ? "inline-block" : "none";
  if (els.integrator) els.integrator.disabled = !on;
}

if (els.advancedToggle) {
  els.advancedToggle.addEventListener("change", () => {
    updateAdvancedUI();
    runSingle(); // optional: direkt neu rechnen
  });
}

if (els.integrator) {
  els.integrator.addEventListener("change", () => runSingle());
}

updateAdvancedUI();



function setVals() {
  if (els.N0Val && els.N0) els.N0Val.textContent = Number(els.N0.value).toLocaleString("de-DE");
  if (els.R0Val && els.R0) els.R0Val.textContent = Number(els.R0.value).toFixed(2);
  if (els.K0Val && els.K0) els.K0Val.textContent = Number(els.K0.value).toLocaleString("de-DE");

  if (els.nutrVal && els.nutr) els.nutrVal.textContent = els.nutr.value + "%";
  if (els.tempVal && els.temp) els.tempVal.textContent = Number(els.temp.value).toFixed(1);
  if (els.phVal && els.ph) els.phVal.textContent = Number(els.ph.value).toFixed(1);

  if (els.tmaxVal && els.tmax) els.tmaxVal.textContent = els.tmax.value + "h";
  if (els.dtVal && els.dt) els.dtVal.textContent = Number(els.dt.value).toFixed(2) + "h";

  // âœ… HIER ganz unten rein:
  if (els.stressThrVal && els.stressThr) els.stressThrVal.textContent = Number(els.stressThr.value).toFixed(2);
  if (els.deathMaxVal && els.deathMax) els.deathMaxVal.textContent = Number(els.deathMax.value).toFixed(2);
}

  // Umweltfaktoren (vereinfacht, aber plausibel):
  // Temp- und pH-Faktor als "Glocke" um Optimum, NÃ¤hrstoffe skalieren K
  function gaussianFactor(x, opt, sigma) {
    const z = (x - opt) / sigma;
    return Math.exp(-0.5 * z * z);
  }

 function computeEffectiveParams() {
  const r0 = Number(els.R0.value);
  const K0 = Number(els.K0.value);

  const nutr = els.nutr ? Number(els.nutr.value) : 70;
  const T = els.temp ? Number(els.temp.value) : 37;
  const pH = els.ph ? Number(els.ph.value) : 7.0;

  // Optima
  const Topt = 37, sigmaT = 7;
  const pHopt = 7.0, sigmapH = 1.2;

  const fT = gaussianFactor(T, Topt, sigmaT);
  const fpH = gaussianFactor(pH, pHopt, sigmapH);

  // Fitness (0..1)
  const fitnessRaw = fT * fpH;
  const fitness = Math.max(0.0, Math.min(1.0, fitnessRaw));

  // Wachstumsrate: bei Stress wird r kleiner, aber nicht negativ
  const r = r0 * Math.max(0.0, fitness);

  // NÃ¤hrstoffe beeinflussen K stark
  const fN = 0.20 + 0.80 * (nutr / 100);
  const K = K0 * fN;

  // NEU: Sterberate d bei Stress
  const thr = els.stressThr ? Number(els.stressThr.value) : 0.30;     // Fitness-Schwelle
  const dMax = els.deathMax ? Number(els.deathMax.value) : 0.25;      // max. Sterberate

  // Wenn Fitness >= thr => d=0
  // Wenn Fitness < thr => d steigt bis dMax, je weiter drunter
  const stress = thr <= 0 ? 0 : Math.max(0, (thr - fitness) / thr);   // 0..1
  const d = dMax * stress;

  return { r, K, fitness, fT, fpH, fN, d, thr, dMax };
}


 function simulate() {
  const N0 = Number(els.N0.value);
  const tmax = Number(els.tmax.value);
  const dt = Number(els.dt.value);

  const { r, K, fitness, fT, fpH, fN, d, thr } = computeEffectiveParams();

  const points = [];
  let n = N0;

  const Ksafe = Math.max(K, 1);

  // âœ… Integrator-Wahl
  const advancedOn = !!els.advancedToggle?.checked;
  const method = advancedOn ? (els.integrator?.value || "euler") : "euler";

  // Ableitung dN/dt als Funktion (praktisch fÃ¼r RK2)
  const deriv = (nVal) => {
    const growth = r * nVal * (1 - nVal / Ksafe);
    const death = d * nVal;
    return growth - death;
  };

  for (let time = 0; time <= tmax + 1e-12; time += dt) {
    points.push({ t: time, N: n });

    if (method === "heun") {
      // RK2 / Heun
      const k1 = deriv(n);
      const nPred = n + dt * k1;
      const k2 = deriv(nPred);
      n = n + dt * 0.5 * (k1 + k2);
    } else {
      // Euler
      n = n + dt * deriv(n);
    }

    if (!Number.isFinite(n) || n < 0) n = 0;
  }

  const maxN = points.reduce((m, p) => Math.max(m, p.N), 0);


// Kennzahlen
const N_end = points.length ? points[points.length - 1].N : 0;

// t_half: Zeitpunkt, wo N >= 0.5*K (nur sinnvoll, wenn K>0)
let tHalf = null;
if (K > 0) {
  const target = 0.5 * K;
  const hit = points.find(p => p.N >= target);
  tHalf = hit ? hit.t : null;
}


  const methodLabel = (method === "heun") ? "RK2/Heun" : "Euler";

const warn = (advancedOn && dt > 0.2)
  ? (method === "euler" ? "âš ï¸ dt groÃŸ â†’ Euler kann ungenau/instabil werden" : "âš ï¸ dt groÃŸ â†’ Genauigkeit sinkt")
  : "";

const tHalfLabel = (tHalf == null)
  ? (N_end < 0.5 * K ? "â€” (nicht erreicht)" : "â€”")
  : `${tHalf.toFixed(2)}h`;

  if (els.info) {
  els.info.innerHTML =
    `Effektiv: r = <b>${r.toFixed(3)}</b> | K = <b>${formatK(K)}</b> | Fitness = <b>${fitness.toFixed(2)}</b>` +
    ` | d = <b>${d.toFixed(3)}</b> | Numerik: <b>${methodLabel}</b>` +
    `<br><span style="opacity:.85;">N_end=${formatK(N_end)} Â· N_max=${formatK(maxN)} Â· tÂ½=${tHalfLabel}</span>` +
    `<br><span style="opacity:.75;">Faktoren: Temp=${fT.toFixed(2)} Â· pH=${fpH.toFixed(2)} Â· Nutr(K)=${fN.toFixed(2)} Â· StressThr=${thr.toFixed(2)}</span>` +

    (warn ? `<br><span style="opacity:.7;">${warn}</span>` : "");


}


  return {
  points,
  maxT: tmax,
  maxN,
  r,
  K,
  meta: { r, K, dt, tmax, fitness, d, method }
};
}



  function clearCanvas() {
    ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
  }

function drawAxes(minT, maxT, minN, maxN) {
  const w = els.canvas.width, h = els.canvas.height;
  const pad = 42;
  
  const rangeT = maxT - minT;
  const rangeN = maxN - minN;

  // grid setup (wie vorher)
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 1;

  const yTicks = 4;  // 0..4 => 5 Labels
  const xTicks = 6;  // 0..6 => 7 Labels

  // horizontale Grid-Linien
  for (let i = 0; i <= yTicks; i++) {
    const frac = i / yTicks;
    const y = h - pad - frac * (h - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(w - pad, y);
    ctx.stroke();
  }

  // vertikale Grid-Linien
  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const x = pad + frac * (w - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(x, pad);
    ctx.lineTo(x, h - pad);
    ctx.stroke();
  }
  ctx.restore();

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, h - pad);
  ctx.lineTo(w - pad, h - pad);
  ctx.stroke();

  // labels
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("N", 18, pad + 4);
  ctx.fillText("t (h)", w - pad - 30, h - pad + 28);

  // âœ… Tick-Labels (statt nur min/max)
  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";

  // Y: links (minN..maxN)
  for (let i = 0; i <= yTicks; i++) {
    const frac = i / yTicks;
    const val = minN + frac * rangeN;
    const y = h - pad - frac * (h - 2 * pad);
    const text = formatK(val);
    ctx.fillText(text, 8, y + 4);
  }

  // X: unten (minT..maxT)
  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const val = minT + frac * rangeT;
    const x = pad + frac * (w - 2 * pad);
    const text = (val % 1 === 0) ? String(val) : val.toFixed(1);
    ctx.fillText(text, x - 8, h - pad + 14);
  }
}

  const palette = [
    "rgba(0,255,200,0.95)",
    "rgba(255,200,0,0.95)",
    "rgba(255,90,120,0.95)",
    "rgba(120,170,255,0.95)",
    "rgba(200,120,255,0.95)"
  ];

function plotRuns() {
  const w = els.canvas.width, h = els.canvas.height;
  const pad = 42;

  // Wenn keine Runs da sind: nur Achsen "default" zeichnen
  if (!runs.length) {
    const fallbackT = Number(els.tmax?.value ?? 24);
    const fallbackN = Number(els.K0?.value ?? 200000);
    clearCanvas();
    drawAxes(0, fallbackT, 0, fallbackN);
    if (els.axisStatus) els.axisStatus.textContent = `ğŸŸ¢ auto: tâ‰¤${fallbackT}h | Nâ‰¤${formatK(fallbackN)}`;
    return;
  }

  // Autoscale aus Runs (maxT/maxN) + Fallback aus Points
  const autoMaxT = Math.max(...runs.map(r => r.maxT ?? 0), 0);
  const autoMaxN = Math.max(...runs.map(r => r.maxN ?? 0), 0);

  const fallbackMaxT = Math.max(
    ...runs.map(r => (r.points?.length ? r.points[r.points.length - 1].t : 0)),
    0
  );
  const fallbackMaxN = Math.max(
    ...runs.flatMap(r => (r.points?.length ? r.points.map(p => p.N) : [0])),
    0
  );

  let maxT = Math.max(autoMaxT, fallbackMaxT, 1);
  let maxN = Math.max(autoMaxN, fallbackMaxN, 1);
  let minT = 0;
  let minN = 0;

  // Lock anwenden (fixe Achsen)
  if (axisLock.locked) {
    if (axisLock.maxT != null) maxT = axisLock.maxT;
    if (axisLock.maxN != null) maxN = axisLock.maxN;
    if (axisLock.minT != null) minT = axisLock.minT;
    if (axisLock.minN != null) minN = axisLock.minN;
  }

  // kleiner Puffer fÃ¼rs Zeichnen
  const shownMaxT = maxT;
  const shownMaxN = maxN;
  maxT *= 1.02;
  maxN *= 1.10;

  // Statusanzeige
  if (els.axisStatus) {
    els.axisStatus.textContent = axisLock.locked
      ? `ğŸ”’ fix: tâˆˆ[${minT},${shownMaxT.toFixed(1)}]h | Nâˆˆ[${formatK(minN)},${formatK(shownMaxN)}]`
      : `ğŸŸ¢ auto: tâ‰¤${shownMaxT.toFixed(1)}h | Nâ‰¤${formatK(shownMaxN)}`;
  }

  clearCanvas();
  drawAxes(minT, maxT, minN, maxN);

  const rangeT = maxT - minT;
  const rangeN = maxN - minN;

  // Kurven plotten
  runs.forEach((run, idx) => {
    const pts = run.points || [];
    if (!pts.length) return;

    ctx.save();
    ctx.strokeStyle = palette[idx % palette.length];
    ctx.lineWidth = (idx === runs.length - 1) ? 3 : 2;
    ctx.globalAlpha = (idx === runs.length - 1) ? 1 : 0.65;

    ctx.beginPath();
    pts.forEach((pt, i) => {
      const x = pad + ((pt.t - minT) / rangeT) * (w - 2 * pad);
      const y = h - pad - ((pt.N - minN) / rangeN) * (h - 2 * pad);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.restore();
  });

  // kleine Anzeige
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(`Runs: ${runs.length}`, 52, 22);
}

function downloadText(filename, text, mime = "text/plain;charset=utf-8") {
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function exportLatestRunCSV() {
  if (!runs.length) return;

  const run = runs[runs.length - 1];
  const pts = run.points || [];

  // Parameter (falls du sie im run speicherst; sonst hier aus simulate()/compute holen)
  const meta = run.meta || {}; 
  const sep = ";";

  // Kopfzeile
  let csv = [
    "t_h","N",
    "r_eff","K_eff","dt_h","tmax_h",
    "fitness","death_d","method"
  ].join(sep) + "\n";

  // Zeilen
  csv += pts.map(p => ([
    p.t,
    p.N,
    meta.r ?? "",
    meta.K ?? "",
    meta.dt ?? "",
    meta.tmax ?? "",
    meta.fitness ?? "",
    meta.d ?? "",
    meta.method ?? ""
  ].join(sep))).join("\n");

  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  downloadText(`wachstum_points_${stamp}.csv`, csv, "text/csv;charset=utf-8");
}


function exportAllRunsJSON() {
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  downloadText(`wachstum_runs_${stamp}.json`, JSON.stringify(runs, null, 2), "application/json");
}



  function runSingle() {
    runs.length = 0;
    runs.push(simulate());
    plotRuns();
  }

  function addRun() {
    runs.push(simulate());
    plotRuns();
  }

  function resetAll() {
    runs.length = 0;
    els.info.textContent = "";
    clearCanvas();
  }


function applyPreset(name) {
  const presets = {
    optimal: { nutr: 100, temp: 37, ph: 7.0 },
    cold: { nutr: 70, temp: 12, ph: 7.0 },
    phStress: { nutr: 70, temp: 37, ph: 5.2 },
    lowNutr: { nutr: 10, temp: 37, ph: 7.0 },
  };

  const p = presets[name];
  if (!p) return;

  if (els.nutr) els.nutr.value = p.nutr;
  if (els.temp) els.temp.value = p.temp;
  if (els.ph) els.ph.value = p.ph;

  setVals();
  // optional: direkt neu simulieren
  // runSingle();
}


  // init
setVals();

// alle Slider updaten nur setVals()
const allInputs = [
  els.N0, els.R0, els.K0,
  els.nutr, els.temp, els.ph,
  els.tmax, els.dt,
  els.stressThr, els.deathMax
].filter(Boolean);

["input", "change"].forEach(evt => {
  allInputs.forEach(el => el.addEventListener(evt, () => setVals()));
});

// ===== Bio-Simulation Tab Switching =====
document.querySelectorAll('.bio-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const targetTab = tab.dataset.bioTab;
    
    // Switch tab buttons
    document.querySelectorAll('.bio-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    // Switch tab content
    document.querySelectorAll('.bio-tab-content').forEach(content => {
      content.classList.remove('active');
    });
    document.querySelector(`[data-bio-content="${targetTab}"]`).classList.add('active');
  });
});

// preset buttons
if (els.presetOptimal) els.presetOptimal.addEventListener("click", () => applyPreset("optimal"));
if (els.presetCold) els.presetCold.addEventListener("click", () => applyPreset("cold"));
if (els.presetPHStress) els.presetPHStress.addEventListener("click", () => applyPreset("phStress"));
if (els.presetLowNutr) els.presetLowNutr.addEventListener("click", () => applyPreset("lowNutr"));

// tool buttons

if (els.exportCsvBtn) els.exportCsvBtn.addEventListener("click", exportLatestRunCSV);
if (els.exportJsonBtn) els.exportJsonBtn.addEventListener("click", exportAllRunsJSON);

// ===== pH-Rechner =====
const phCalcBtn = document.getElementById("phCalcBtn");
const phH = document.getElementById("phH");
const phResult = document.getElementById("phResult");

if (phCalcBtn) {
  phCalcBtn.addEventListener("click", () => {
    const h = parseFloat(phH.value);
    if (h > 0) {
      const ph = -Math.log10(h);
      phResult.textContent = `pH = ${ph.toFixed(2)}`;
      phResult.style.color = ph < 7 ? "#ff6b81" : (ph > 7 ? "#7b8cff" : "#4ecdc4");
    } else {
      phResult.textContent = "Bitte positive Zahl eingeben!";
      phResult.style.color = "#ff6b81";
    }
  });
}

// ===== Molmasse-Rechner =====
const molCalcBtn = document.getElementById("molCalcBtn");
const molFormula = document.getElementById("molFormula");
const molResult = document.getElementById("molResult");

// Atommassen (gerundet)
const atomicMass = {
  H: 1, C: 12, N: 14, O: 16, P: 31, S: 32, 
  Cl: 35.5, Br: 80, I: 127, F: 19, Na: 23, 
  K: 39, Ca: 40, Mg: 24, Fe: 56, Zn: 65,
  Cu: 64, Ag: 108, Au: 197, Al: 27, Si: 28
};

if (molCalcBtn) {
  molCalcBtn.addEventListener("click", () => {
    const formula = molFormula.value.trim();
    if (!formula) {
      molResult.textContent = "Bitte Formel eingeben!";
      return;
    }
    
    let totalMass = 0;
    const regex = /([A-Z][a-z]?)(\d*)/g;
    let match;
    let valid = true;
    
    while ((match = regex.exec(formula)) !== null) {
      const element = match[1];
      const count = match[2] ? parseInt(match[2]) : 1;
      
      if (atomicMass[element]) {
        totalMass += atomicMass[element] * count;
      } else {
        molResult.textContent = `Element ${element} nicht gefunden!`;
        molResult.style.color = "#ff6b81";
        valid = false;
        break;
      }
    }
    
    if (valid) {
      molResult.textContent = `Molmasse = ${totalMass.toFixed(2)} g/mol`;
      molResult.style.color = "#7b8cff";
    }
  });
}

// ===== ERWEITERTER Graphen-Plotter =====
const graphCanvas = document.getElementById("graphCanvas");
const graphCtx = graphCanvas ? graphCanvas.getContext("2d") : null;
const graphPlotBtn = document.getElementById("graphPlotBtn");
const graphClearBtn = document.getElementById("graphClearBtn");
const graphAddBtn = document.getElementById("graphAddBtn");
const graphFunc = document.getElementById("graphFunc");
const graphXmin = document.getElementById("graphXmin");
const graphXmax = document.getElementById("graphXmax");
const graphInfo = document.getElementById("graphInfo");

let graphFunctions = [];
let graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
let graphDragStart = null;
let graphShowDerivative = false;
let graphShowIntegral = false;
let graphShowZeros = false;
let graphShowExtrema = false;
let graphShowTangent = null;
let graphPlotMode = 'cartesian'; // cartesian, polar, parametric
let graphAnimationParam = 0;
let graphAnimationRunning = false;

// Erweiterte mathematische Funktionen
const mathFunctions = {
  // Trigonometrische Funktionen
  sin: Math.sin, cos: Math.cos, tan: Math.tan,
  asin: Math.asin, acos: Math.acos, atan: Math.atan,
  sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh,
  asinh: Math.asinh, acosh: Math.acosh, atanh: Math.atanh,
  sec: (x) => 1 / Math.cos(x),
  csc: (x) => 1 / Math.sin(x),
  cot: (x) => 1 / Math.tan(x),
  
  // Exponential und Logarithmus
  exp: Math.exp, ln: Math.log, log: Math.log10, log2: Math.log2,
  
  // Wurzeln und Potenzen
  sqrt: Math.sqrt, cbrt: Math.cbrt, pow: Math.pow,
  
  // Runden
  abs: Math.abs, floor: Math.floor, ceil: Math.ceil, round: Math.round,
  sign: Math.sign, trunc: Math.trunc,
  
  // Min/Max
  min: Math.min, max: Math.max,
  
  // Konstanten
  pi: Math.PI, e: Math.E,
  
  // Spezielle Funktionen
  fact: (n) => {
    if (n < 0) return NaN;
    if (n === 0 || n === 1) return 1;
    let result = 1;
    for (let i = 2; i <= n; i++) result *= i;
    return result;
  },
  
  // Heaviside-Funktion
  heaviside: (x) => x < 0 ? 0 : (x === 0 ? 0.5 : 1),
  step: (x) => x < 0 ? 0 : 1,
  
  // Signum
  sgn: Math.sign,
  
  // Modulo
  mod: (a, b) => ((a % b) + b) % b,
  
  // Gamma-Funktion (Approximation)
  gamma: (z) => {
    // Stirling-Approximation fÃ¼r groÃŸe z
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * mathFunctions.gamma(1 - z));
    z -= 1;
    const g = 7;
    const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
               771.32342877765313, -176.61502916214059, 12.507343278686905,
               -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    let x = p[0];
    for (let i = 1; i < g + 2; i++) {
      x += p[i] / (z + i);
    }
    const t = z + g + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
};

function evaluateFunction(funcStr, x, t = 0) {
  try {
    // Ersetze mathematische Notation
    let expr = funcStr
      .replace(/\^/g, '**')
      .replace(/Ï€/g, 'Math.PI')
      .replace(/Ã·/g, '/')
      .replace(/Ã—/g, '*')
      .replace(/Â²/g, '**2')
      .replace(/Â³/g, '**3');
    
    // Implizite Multiplikation: 2x -> 2*x, 3sin(x) -> 3*sin(x)
    expr = expr.replace(/(\d)([a-z])/gi, '$1*$2');
    expr = expr.replace(/\)([a-z0-9])/gi, ')*$1');
    expr = expr.replace(/(\d)\(/g, '$1*(');
    expr = expr.replace(/\)\(/g, ')*(');
    
    // Ersetze alle mathematischen Funktionen
    Object.keys(mathFunctions).forEach(fname => {
      const regex = new RegExp(`\\b${fname}\\b`, 'gi');
      expr = expr.replace(regex, `mathFunctions.${fname}`);
    });
    
    // Evaluiere
    const func = new Function('x', 't', 'mathFunctions', 'Math', `
      "use strict";
      return (${expr});
    `);
    
    return func(x, t, mathFunctions, Math);
  } catch (e) {
    return NaN;
  }
}

// Numerische Ableitung
function derivative(funcStr, x, h = 0.0001) {
  const f1 = evaluateFunction(funcStr, x + h);
  const f2 = evaluateFunction(funcStr, x - h);
  return (f1 - f2) / (2 * h);
}

// Zweite Ableitung
function secondDerivative(funcStr, x, h = 0.0001) {
  const f0 = evaluateFunction(funcStr, x);
  const f1 = evaluateFunction(funcStr, x + h);
  const f2 = evaluateFunction(funcStr, x - h);
  return (f1 - 2 * f0 + f2) / (h * h);
}

// Numerische Integration (Trapezregel)
function integrate(funcStr, a, b, n = 1000) {
  const h = (b - a) / n;
  let sum = (evaluateFunction(funcStr, a) + evaluateFunction(funcStr, b)) / 2;
  
  for (let i = 1; i < n; i++) {
    sum += evaluateFunction(funcStr, a + i * h);
  }
  
  return sum * h;
}

// Nullstellenfinder (Newton-Verfahren + Bisection)
function findZeros(funcStr, xMin, xMax, steps = 100) {
  const zeros = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 0; i < steps; i++) {
    const x0 = xMin + i * stepSize;
    const y0 = evaluateFunction(funcStr, x0);
    const x1 = xMin + (i + 1) * stepSize;
    const y1 = evaluateFunction(funcStr, x1);
    
    // Vorzeichenwechsel?
    if (isFinite(y0) && isFinite(y1) && y0 * y1 < 0) {
      // Newton-Raphson mit Bisection Fallback
      let x = (x0 + x1) / 2;
      let left = x0, right = x1;
      
      for (let iter = 0; iter < 30; iter++) {
        const fx = evaluateFunction(funcStr, x);
        const dfx = derivative(funcStr, x);
        
        if (Math.abs(fx) < 1e-10) {
          zeros.push(x);
          break;
        }
        
        if (Math.abs(dfx) > 1e-10) {
          // Newton-Schritt
          const newX = x - fx / dfx;
          if (newX >= left && newX <= right) {
            x = newX;
          } else {
            // Bisection Fallback
            x = (left + right) / 2;
          }
        } else {
          // Bisection
          x = (left + right) / 2;
        }
        
        const fNew = evaluateFunction(funcStr, x);
        if (fNew * evaluateFunction(funcStr, left) < 0) {
          right = x;
        } else {
          left = x;
        }
      }
    }
  }
  
  // Entferne Duplikate
  return zeros.filter((val, idx, arr) => 
    idx === 0 || Math.abs(val - arr[idx - 1]) > 0.001
  );
}

// Extrema finden (Maxima und Minima)
function findExtrema(funcStr, xMin, xMax, steps = 200) {
  const extrema = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 1; i < steps - 1; i++) {
    const x = xMin + i * stepSize;
    const dy = derivative(funcStr, x);
    const d2y = secondDerivative(funcStr, x);
    
    // Kritischer Punkt (erste Ableitung â‰ˆ 0)?
    if (Math.abs(dy) < 0.01) {
      const y = evaluateFunction(funcStr, x);
      if (isFinite(y)) {
        // Zweite Ableitung testen
        let type = 'saddle';
        if (d2y > 0.01) {
          type = 'min';
        } else if (d2y < -0.01) {
          type = 'max';
        }
        
        extrema.push({ x, y, type });
      }
    }
  }
  
  return extrema;
}

// Wendepunkte finden
function findInflectionPoints(funcStr, xMin, xMax, steps = 200) {
  const inflection = [];
  const stepSize = (xMax - xMin) / steps;
  
  for (let i = 1; i < steps - 1; i++) {
    const x = xMin + i * stepSize;
    const d2y = secondDerivative(funcStr, x);
    const xPrev = xMin + (i - 1) * stepSize;
    const d2yPrev = secondDerivative(funcStr, xPrev);
    
    // Vorzeichenwechsel der zweiten Ableitung?
    if (isFinite(d2y) && isFinite(d2yPrev) && d2y * d2yPrev < 0) {
      const y = evaluateFunction(funcStr, x);
      if (isFinite(y)) {
        inflection.push({ x, y });
      }
    }
  }
  
  return inflection;
}

// ===== High-DPI Canvas Setup for Sharp Rendering =====
function setupCanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  
  return { width: rect.width, height: rect.height, ctx, dpr };
}

// Hilfsfunktion um Zoom-Level anzuzeigen
function updateZoomDisplay() {
  const graphZoomLevel = document.getElementById('graphZoomLevel');
  if (graphZoomLevel) {
    graphZoomLevel.textContent = graphZoom.scale.toFixed(1) + 'x';
  }
}

// Hilfsfunktion um Button-Zustand zu aktualisieren
function updateButtonState(button, active) {
  if (button) {
    button.style.background = active ? 'var(--accent)' : '';
    button.style.color = active ? '#fff' : '';
  }
}

function plotGraph() {
  if (!graphCtx || !graphCanvas || graphFunctions.length === 0) return;
  
  const { width: w, height: h, ctx } = setupCanvas(graphCanvas);
  const pad = 60;
  
  let xMin = parseFloat(graphXmin.value);
  let xMax = parseFloat(graphXmax.value);
  
  // Zoom anwenden
  const xRange = (xMax - xMin) / graphZoom.scale;
  const xCenter = (xMax + xMin) / 2 + graphZoom.offsetX;
  xMin = xCenter - xRange / 2;
  xMax = xCenter + xRange / 2;
  
  // Hintergrund
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg').trim();
  ctx.fillRect(0, 0, w, h);
  
  // Y-Bereich berechnen
  let yMin = Infinity;
  let yMax = -Infinity;
  
  graphFunctions.forEach(func => {
    if (graphPlotMode === 'parametric') {
      // FÃ¼r parametrische Plots
      for (let tVal = 0; tVal <= 1; tVal += 0.001) {
        try {
          const tScaled = tVal * 2 * Math.PI;
          const xVal = evaluateFunction(func.x, 0, tScaled);
          const yVal = evaluateFunction(func.y, 0, tScaled);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    } else if (graphPlotMode === 'polar') {
      // FÃ¼r Polar-Plots
      for (let theta = 0; theta < 2 * Math.PI; theta += 0.01) {
        try {
          const r = evaluateFunction(func, theta);
          const xVal = r * Math.cos(theta);
          const yVal = r * Math.sin(theta);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    } else {
      // FÃ¼r kartesische Plots
      for (let px = 0; px < w; px++) {
        const xVal = xMin + (px / w) * (xMax - xMin);
        try {
          const yVal = evaluateFunction(func, xVal, graphAnimationParam);
          if (isFinite(yVal)) {
            yMin = Math.min(yMin, yVal);
            yMax = Math.max(yMax, yVal);
          }
        } catch (e) {}
      }
    }
  });
  
  if (!isFinite(yMin) || !isFinite(yMax)) {
    yMin = -10;
    yMax = 10;
  }
  
  // Manuelle Y-Achse
  if (manualYAxis.enabled && manualYAxis.yMin != null && manualYAxis.yMax != null) {
    yMin = manualYAxis.yMin;
    yMax = manualYAxis.yMax;
  } else {
    const yRange = yMax - yMin;
    yMin -= yRange * 0.1;
    yMax += yRange * 0.1;
  }
  
  // Zoom fÃ¼r Y auch anwenden
  const yRange = (yMax - yMin) / graphZoom.scale;
  const yCenter = (yMax + yMin) / 2 + graphZoom.offsetY;
  yMin = yCenter - yRange / 2;
  yMax = yCenter + yRange / 2;
  
  // Hilfsfunktion fÃ¼r Koordinaten-Transformation
  const toScreen = (xVal, yVal) => ({
    x: pad + ((xVal - xMin) / (xMax - xMin)) * (w - 2 * pad),
    y: h - pad - ((yVal - yMin) / (yMax - yMin)) * (h - 2 * pad)
  });
  
  // Gitter zeichnen
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  
  const gridStepsX = 20;
  const gridStepsY = 20;
  
  for (let i = 0; i <= gridStepsX; i++) {
    const xVal = pad + (i / gridStepsX) * (w - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(xVal, pad);
    ctx.lineTo(xVal, h - pad);
    ctx.stroke();
  }
  
  for (let i = 0; i <= gridStepsY; i++) {
    const yVal = pad + (i / gridStepsY) * (h - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(pad, yVal);
    ctx.lineTo(w - pad, yVal);
    ctx.stroke();
  }
  
  // Achsen zeichnen
  ctx.strokeStyle = "rgba(255,255,255,0.4)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  // Y-Achse
  const x0Screen = toScreen(0, 0).x;
  if (x0Screen >= pad && x0Screen <= w - pad) {
    ctx.moveTo(x0Screen, pad);
    ctx.lineTo(x0Screen, h - pad);
  }
  
  // X-Achse
  const y0Screen = toScreen(0, 0).y;
  if (y0Screen >= pad && y0Screen <= h - pad) {
    ctx.moveTo(pad, y0Screen);
    ctx.lineTo(w - pad, y0Screen);
  }
  
  ctx.stroke();
  
  // Achsenbeschriftung
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.font = "12px system-ui";
  ctx.textAlign = "center";
  
  // X-Achse Beschriftung
  for (let i = 0; i <= 10; i++) {
    const xVal = xMin + (i / 10) * (xMax - xMin);
    const screen = toScreen(xVal, 0);
    if (screen.x >= pad && screen.x <= w - pad) {
      ctx.fillText(xVal.toFixed(1), screen.x, h - pad + 20);
    }
  }
  
  ctx.textAlign = "right";
  // Y-Achse Beschriftung
  for (let i = 0; i <= 10; i++) {
    const yVal = yMin + (i / 10) * (yMax - yMin);
    const screen = toScreen(0, yVal);
    if (screen.y >= pad && screen.y <= h - pad) {
      ctx.fillText(yVal.toFixed(1), pad - 10, screen.y + 4);
    }
  }
  
  // Funktionen plotten
  const colors = ["#7b8cff", "#ff6b81", "#4ecdc4", "#ffd93d", "#a78bfa", "#ff9ff3", "#54a0ff"];
  
  graphFunctions.forEach((func, idx) => {
    const color = colors[idx % colors.length];
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    
    if (graphPlotMode === 'polar') {
      // Polar-Plot
      ctx.beginPath();
      let started = false;
      
      for (let theta = 0; theta <= 2 * Math.PI; theta += 0.005) {
        try {
          const r = evaluateFunction(func, theta);
          const xVal = r * Math.cos(theta);
          const yVal = r * Math.sin(theta);
          
          if (isFinite(xVal) && isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
          } else {
            started = false;
          }
        } catch (e) {
          started = false;
        }
      }
      ctx.stroke();
      
    } else if (graphPlotMode === 'parametric') {
      // Parametrischer Plot
      ctx.beginPath();
      let started = false;
      
      for (let tVal = 0; tVal <= 1; tVal += 0.0005) {
        try {
          const tScaled = tVal * 2 * Math.PI;
          const xVal = evaluateFunction(func.x, 0, tScaled);
          const yVal = evaluateFunction(func.y, 0, tScaled);
          
          if (isFinite(xVal) && isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
          } else {
            started = false;
          }
        } catch (e) {
          started = false;
        }
      }
      ctx.stroke();
      
    } else {
      // Kartesischer Plot
      ctx.beginPath();
      let started = false;
      let lastY = null;
      
      for (let px = 0; px < w - 2 * pad; px++) {
        const xVal = xMin + (px / (w - 2 * pad)) * (xMax - xMin);
        try {
          const yVal = evaluateFunction(func, xVal, graphAnimationParam);
          
          if (isFinite(yVal)) {
            const screen = toScreen(xVal, yVal);
            
            // DiskontinuitÃ¤ts-Check
            if (lastY !== null && Math.abs(yVal - lastY) > (yMax - yMin) * 0.5) {
              started = false;
            }
            
            if (!started) {
              ctx.moveTo(screen.x, screen.y);
              started = true;
            } else {
              ctx.lineTo(screen.x, screen.y);
            }
            lastY = yVal;
          } else {
            started = false;
            lastY = null;
          }
        } catch (e) {
          started = false;
          lastY = null;
        }
      }
      ctx.stroke();
      
      // Ableitung zeigen
      if (graphShowDerivative && graphPlotMode === 'cartesian') {
        ctx.strokeStyle = color.replace(')', ', 0.5)').replace('rgb', 'rgba').replace('#', 'rgba(');
        if (!ctx.strokeStyle.includes('rgba')) {
          ctx.strokeStyle = color + '80'; // Hex Alpha
        }
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        started = false;
        
        for (let px = 0; px < w - 2 * pad; px++) {
          const xVal = xMin + (px / (w - 2 * pad)) * (xMax - xMin);
          try {
            const dy = derivative(func, xVal);
            if (isFinite(dy)) {
              const screen = toScreen(xVal, dy);
              if (!started) {
                ctx.moveTo(screen.x, screen.y);
                started = true;
              } else {
                ctx.lineTo(screen.x, screen.y);
              }
            } else {
              started = false;
            }
          } catch (e) {
            started = false;
          }
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Nullstellen zeigen
      if (graphShowZeros && graphPlotMode === 'cartesian') {
        const zeros = findZeros(func, xMin, xMax);
        ctx.fillStyle = color;
        zeros.forEach(xVal => {
          const screen = toScreen(xVal, 0);
          if (screen.x >= pad && screen.x <= w - pad && screen.y >= pad && screen.y <= h - pad) {
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.strokeStyle = color;
          }
        });
      }
      
      // Extrema zeigen
      if (graphShowExtrema && graphPlotMode === 'cartesian') {
        const extrema = findExtrema(func, xMin, xMax);
        extrema.forEach(ext => {
          const screen = toScreen(ext.x, ext.y);
          if (screen.x >= pad && screen.x <= w - pad && screen.y >= pad && screen.y <= h - pad) {
            ctx.fillStyle = ext.type === 'max' ? '#ff6b81' : (ext.type === 'min' ? '#4ecdc4' : '#ffd93d');
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            const label = ext.type === 'max' ? 'MAX' : (ext.type === 'min' ? 'MIN' : 'SP');
            ctx.fillText(label, screen.x, screen.y - 12);
            ctx.strokeStyle = color;
          }
        });
      }
      
      // Tangente zeigen
      if (graphShowTangent !== null && graphPlotMode === 'cartesian') {
        const xVal = graphShowTangent;
        const yVal = evaluateFunction(func, xVal);
        const slope = derivative(func, xVal);
        
        if (isFinite(yVal) && isFinite(slope)) {
          ctx.strokeStyle = '#ffd93d';
          ctx.lineWidth = 2.5;
          ctx.setLineDash([10, 5]);
          ctx.beginPath();
          
          const x1 = xMin;
          const y1 = yVal + slope * (x1 - xVal);
          const x2 = xMax;
          const y2 = yVal + slope * (x2 - xVal);
          
          const screen1 = toScreen(x1, y1);
          const screen2 = toScreen(x2, y2);
          
          ctx.moveTo(screen1.x, screen1.y);
          ctx.lineTo(screen2.x, screen2.y);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Punkt markieren
          const screenPt = toScreen(xVal, yVal);
          ctx.fillStyle = '#ffd93d';
          ctx.beginPath();
          ctx.arc(screenPt.x, screenPt.y, 6, 0, 2 * Math.PI);
          ctx.fill();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Info-Text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 11px system-ui';
          ctx.textAlign = 'left';
          ctx.fillText(`m = ${slope.toFixed(3)}`, screenPt.x + 10, screenPt.y - 10);
        }
      }
    }
  });
  
  // Info-Text
  const funcCount = graphFunctions.length;
  const modeText = graphPlotMode === 'polar' ? 'Polar' : (graphPlotMode === 'parametric' ? 'Parametrisch' : 'Kartesisch');
  graphInfo.textContent = `${funcCount} Funktion(en) | ${modeText} | x: [${xMin.toFixed(2)}, ${xMax.toFixed(2)}] | y: [${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`;
  
  // Update Zoom-Anzeige
  updateZoomDisplay();
}

// Event-Listener
if (graphPlotBtn) {
  graphPlotBtn.addEventListener("click", () => {
    const input = graphFunc.value.trim();
    if (!input) return;
    
    // Parametrische Funktion? (Format: x(t); y(t))
    if (input.includes(';')) {
      const [xFunc, yFunc] = input.split(';').map(s => s.trim());
      graphFunctions = [{ x: xFunc, y: yFunc }];
      graphPlotMode = 'parametric';
    } else {
      graphFunctions = [input];
      graphPlotMode = 'cartesian';
    }
    
    plotGraph();
  });
}

if (graphClearBtn) {
  graphClearBtn.addEventListener("click", () => {
    graphFunctions = [];
    graphFunc.value = "x^2";
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    graphShowDerivative = false;
    graphShowZeros = false;
    graphShowExtrema = false;
    graphShowTangent = null;
    graphPlotMode = 'cartesian';
    
    if (graphCtx) {
      const w = graphCanvas.width;
      const h = graphCanvas.height;
      graphCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg').trim();
      graphCtx.fillRect(0, 0, w, h);
    }
    graphInfo.textContent = "";
  });
}

if (graphAddBtn) {
  graphAddBtn.addEventListener("click", () => {
    const input = graphFunc.value.trim();
    if (!input) return;
    
    // Check ob schon vorhanden
    const exists = graphFunctions.some(f => 
      typeof f === 'string' ? f === input : false
    );
    
    if (!exists) {
      if (input.includes(';')) {
        const [xFunc, yFunc] = input.split(';').map(s => s.trim());
        graphFunctions.push({ x: xFunc, y: yFunc });
        graphPlotMode = 'parametric';
      } else {
        graphFunctions.push(input);
      }
      plotGraph();
    }
  });
}

// Zoom und Pan mit Maus
if (graphCanvas) {
  // Zoom mit Mausrad
  graphCanvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.85 : 1.15;
    graphZoom.scale = Math.max(0.1, Math.min(100, graphZoom.scale * zoomFactor));
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  }, { passive: false });
  
  // Pan mit Drag
  graphCanvas.addEventListener('mousedown', (e) => {
    if (!e.shiftKey) {
      graphDragStart = { x: e.offsetX, y: e.offsetY };
      graphCanvas.style.cursor = 'grabbing';
    }
  });
  
  graphCanvas.addEventListener('mousemove', (e) => {
    if (graphDragStart && graphFunctions.length > 0) {
      const dx = e.offsetX - graphDragStart.x;
      const dy = e.offsetY - graphDragStart.y;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const xRange = (xMax - xMin) / graphZoom.scale;
      
      // Verbesserte Pan-SensitivitÃ¤t
      const sensitivity = 1.5;
      graphZoom.offsetX -= (dx / graphCanvas.offsetWidth) * xRange * sensitivity;
      graphZoom.offsetY += (dy / graphCanvas.offsetHeight) * xRange * sensitivity;
      
      graphDragStart = { x: e.offsetX, y: e.offsetY };
      plotGraph();
    }
  });
  
  graphCanvas.addEventListener('mouseup', () => {
    graphDragStart = null;
    graphCanvas.style.cursor = 'grab';
  });
  
  graphCanvas.addEventListener('mouseleave', () => {
    graphDragStart = null;
    graphCanvas.style.cursor = 'grab';
  });
  
  // Klick fÃ¼r Tangente (Shift + Click)
  graphCanvas.addEventListener('click', (e) => {
    if (e.shiftKey && graphFunctions.length > 0 && graphPlotMode === 'cartesian') {
      const rect = graphCanvas.getBoundingClientRect();
      const xClick = e.clientX - rect.left;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const pad = 60;
      
      const xRange = (xMax - xMin) / graphZoom.scale;
      const xCenter = (xMax + xMin) / 2 + graphZoom.offsetX;
      const adjXMin = xCenter - xRange / 2;
      const adjXMax = xCenter + xRange / 2;
      
      const xVal = adjXMin + ((xClick - pad) / (graphCanvas.offsetWidth - 2 * pad)) * (adjXMax - adjXMin);
      graphShowTangent = xVal;
      plotGraph();
    }
  });
  
  // Doppelklick zum ZurÃ¼cksetzen von Zoom und Pan
  graphCanvas.addEventListener('dblclick', (e) => {
    if (!e.shiftKey) {
      graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
      graphShowTangent = null;
      updateZoomDisplay();
      if (graphFunctions.length > 0) plotGraph();
    }
  });
  
  // Touch-Support fÃ¼r iPad/Tablet
  let touchStartDistance = 0;
  let touchStartZoom = 1;
  
  graphCanvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      // Pinch-to-Zoom
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      touchStartDistance = Math.sqrt(dx * dx + dy * dy);
      touchStartZoom = graphZoom.scale;
      e.preventDefault();
    } else if (e.touches.length === 1) {
      // Pan
      const rect = graphCanvas.getBoundingClientRect();
      graphDragStart = { 
        x: e.touches[0].clientX - rect.left, 
        y: e.touches[0].clientY - rect.top 
      };
    }
  }, { passive: false });
  
  graphCanvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      // Pinch-to-Zoom
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const zoomFactor = distance / touchStartDistance;
      graphZoom.scale = Math.max(0.1, Math.min(100, touchStartZoom * zoomFactor));
      updateZoomDisplay();
      if (graphFunctions.length > 0) plotGraph();
      e.preventDefault();
    } else if (e.touches.length === 1 && graphDragStart) {
      // Pan
      const rect = graphCanvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      const dx = x - graphDragStart.x;
      const dy = y - graphDragStart.y;
      
      const xMin = parseFloat(graphXmin.value);
      const xMax = parseFloat(graphXmax.value);
      const xRange = (xMax - xMin) / graphZoom.scale;
      
      const sensitivity = 1.5;
      graphZoom.offsetX -= (dx / graphCanvas.offsetWidth) * xRange * sensitivity;
      graphZoom.offsetY += (dy / graphCanvas.offsetHeight) * xRange * sensitivity;
      
      graphDragStart = { x, y };
      if (graphFunctions.length > 0) plotGraph();
      e.preventDefault();
    }
  }, { passive: false });
  
  graphCanvas.addEventListener('touchend', () => {
    graphDragStart = null;
    touchStartDistance = 0;
  });
}

// Tastatur-Shortcuts fÃ¼r Graph-Plotter
document.addEventListener('keydown', (e) => {
  // Nur wenn der Graph-Bereich aktiv ist
  if (!document.querySelector('#toolsSection.section.active')) return;
  
  // D-Taste: Toggle Ableitung
  if (e.key === 'd' || e.key === 'D') {
    graphShowDerivative = !graphShowDerivative;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // Z-Taste: Toggle Nullstellen
  if (e.key === 'z' || e.key === 'Z') {
    graphShowZeros = !graphShowZeros;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // E-Taste: Toggle Extrema
  if (e.key === 'e' || e.key === 'E') {
    graphShowExtrema = !graphShowExtrema;
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // T-Taste: Toggle Tangente
  if (e.key === 't' || e.key === 'T') {
    if (graphShowTangent !== null) {
      graphShowTangent = null;
    }
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // P-Taste: Toggle Polar-Modus
  if (e.key === 'p' || e.key === 'P') {
    graphPlotMode = graphPlotMode === 'polar' ? 'cartesian' : 'polar';
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
  
  // R-Taste: Reset Zoom
  if (e.key === 'r' || e.key === 'R') {
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    if (graphFunctions.length > 0) plotGraph();
    e.preventDefault();
  }
});

// Button Event-Listener fÃ¼r neue Features
const graphDerivBtn = document.getElementById('graphDerivBtn');
const graphZerosBtn = document.getElementById('graphZerosBtn');
const graphExtremaBtn = document.getElementById('graphExtremaBtn');
const graphPolarBtn = document.getElementById('graphPolarBtn');
const graphZoomInBtn = document.getElementById('graphZoomInBtn');
const graphZoomOutBtn = document.getElementById('graphZoomOutBtn');
const graphResetZoomBtn = document.getElementById('graphResetZoomBtn');
const graphPanUpBtn = document.getElementById('graphPanUpBtn');
const graphPanDownBtn = document.getElementById('graphPanDownBtn');
const graphPanLeftBtn = document.getElementById('graphPanLeftBtn');
const graphPanRightBtn = document.getElementById('graphPanRightBtn');
const graphCenterBtn = document.getElementById('graphCenterBtn');

if (graphDerivBtn) {
  graphDerivBtn.addEventListener('click', () => {
    graphShowDerivative = !graphShowDerivative;
    updateButtonState(graphDerivBtn, graphShowDerivative);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphZerosBtn) {
  graphZerosBtn.addEventListener('click', () => {
    graphShowZeros = !graphShowZeros;
    updateButtonState(graphZerosBtn, graphShowZeros);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphExtremaBtn) {
  graphExtremaBtn.addEventListener('click', () => {
    graphShowExtrema = !graphShowExtrema;
    updateButtonState(graphExtremaBtn, graphShowExtrema);
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPolarBtn) {
  graphPolarBtn.addEventListener('click', () => {
    graphPlotMode = graphPlotMode === 'polar' ? 'cartesian' : 'polar';
    updateButtonState(graphPolarBtn, graphPlotMode === 'polar');
    if (graphFunctions.length > 0) plotGraph();
  });
}

// Zoom Buttons
if (graphZoomInBtn) {
  graphZoomInBtn.addEventListener('click', () => {
    graphZoom.scale = Math.min(100, graphZoom.scale * 1.3);
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphZoomOutBtn) {
  graphZoomOutBtn.addEventListener('click', () => {
    graphZoom.scale = Math.max(0.1, graphZoom.scale / 1.3);
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphResetZoomBtn) {
  graphResetZoomBtn.addEventListener('click', () => {
    graphZoom = { offsetX: 0, offsetY: 0, scale: 1 };
    graphShowTangent = null;
    updateZoomDisplay();
    if (graphFunctions.length > 0) plotGraph();
  });
}

// Pan Buttons
const panAmount = 0.2; // 20% des sichtbaren Bereichs

if (graphPanUpBtn) {
  graphPanUpBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetY += xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanDownBtn) {
  graphPanDownBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetY -= xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanLeftBtn) {
  graphPanLeftBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetX -= xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphPanRightBtn) {
  graphPanRightBtn.addEventListener('click', () => {
    const xMin = parseFloat(graphXmin.value);
    const xMax = parseFloat(graphXmax.value);
    const xRange = (xMax - xMin) / graphZoom.scale;
    graphZoom.offsetX += xRange * panAmount;
    if (graphFunctions.length > 0) plotGraph();
  });
}

if (graphCenterBtn) {
  graphCenterBtn.addEventListener('click', () => {
    graphZoom.offsetX = 0;
    graphZoom.offsetY = 0;
    if (graphFunctions.length > 0) plotGraph();
  });
}


if (els.runBtn) els.runBtn.addEventListener("click", runSingle);
if (els.addBtn) els.addBtn.addEventListener("click", addRun);
if (els.clearBtn) els.clearBtn.addEventListener("click", resetAll);

if (els.exportPlotBtn) els.exportPlotBtn.addEventListener("click", () => {
  const url = els.canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = `wachstum_plot_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.png`;
  document.body.appendChild(a);
  a.click();
  a.remove();
});



if (els.axisLockBtn) els.axisLockBtn.addEventListener("click", () => {
  axisLock.locked = true;

  // fixiere X auf aktuelle Simulationsdauer
  axisLock.maxT = Number(els.tmax?.value ?? 24);

  // fixiere Y auf aktuell sichtbare Daten (max aus Runs) ODER K0
  const maxFromRuns = runs.length
    ? Math.max(...runs.flatMap(r => (r.points?.length ? r.points.map(p => p.N) : [0])))
    : 0;

  const k0 = Number(els.K0?.value ?? 200000);
  axisLock.maxN = Math.max(maxFromRuns, k0, 1);

  plotRuns();
});

if (els.axisAutoBtn) els.axisAutoBtn.addEventListener("click", () => {
  axisLock.locked = false;
  axisLock.maxT = null;
  axisLock.maxN = null;
  plotRuns();
});

// ===== Manuelle Achsen-Steuerung Bio-Simulation =====
const bioManualAxisDiv = document.getElementById('bioManualAxisDiv');
const bioToggleManualAxisBtns = document.querySelectorAll('#bioToggleManualAxis');
const bioApplyAxisBtn = document.getElementById('bioApplyAxisBtn');
const bioAxisTmin = document.getElementById('bioAxisTmin');
const bioAxisTmax = document.getElementById('bioAxisTmax');
const bioAxisNmin = document.getElementById('bioAxisNmin');
const bioAxisNmax = document.getElementById('bioAxisNmax');

bioToggleManualAxisBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    bioManualAxisDiv.style.display = bioManualAxisDiv.style.display === 'none' ? 'block' : 'none';
  });
});

if (bioApplyAxisBtn) {
  bioApplyAxisBtn.addEventListener('click', () => {
    axisLock.locked = true;
    axisLock.minT = Number(bioAxisTmin.value) || 0;
    axisLock.maxT = Number(bioAxisTmax.value) || 24;
    axisLock.minN = Number(bioAxisNmin.value) || 0;
    axisLock.maxN = Number(bioAxisNmax.value) || 200000;
    plotRuns();
  });
}

// ===== Manuelle Y-Achsen-Steuerung Graph-Plotter =====
const graphToggleYAxis = document.getElementById('graphToggleYAxis');
const graphManualYAxisDiv = document.getElementById('graphManualYAxisDiv');
const graphApplyYAxis = document.getElementById('graphApplyYAxis');
const graphResetYAxis = document.getElementById('graphResetYAxis');
const graphYmin = document.getElementById('graphYmin');
const graphYmax = document.getElementById('graphYmax');

let manualYAxis = { enabled: false, yMin: null, yMax: null };

if (graphToggleYAxis) {
  graphToggleYAxis.addEventListener('click', () => {
    graphManualYAxisDiv.style.display = graphManualYAxisDiv.style.display === 'none' ? 'block' : 'none';
  });
}

if (graphApplyYAxis) {
  graphApplyYAxis.addEventListener('click', () => {
    const yMin = graphYmin.value;
    const yMax = graphYmax.value;
    if (yMin !== '' && yMax !== '') {
      manualYAxis.enabled = true;
      manualYAxis.yMin = Number(yMin);
      manualYAxis.yMax = Number(yMax);
      plotGraph();
    }
  });
}

if (graphResetYAxis) {
  graphResetYAxis.addEventListener('click', () => {
    manualYAxis.enabled = false;
    manualYAxis.yMin = null;
    manualYAxis.yMax = null;
    graphYmin.value = '';
    graphYmax.value = '';
    plotGraph();
  });
}


// Startbild
runSingle();
  });
})();

</script>








</html
>

</body>
</html>
